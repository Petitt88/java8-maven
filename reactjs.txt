Components:
	- Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called “props”) and return React elements describing what should appear on the screen.
		function Welcome(props) {
		  return <h1>Hello, {props.name}</h1>;
		}
		
Props:
	- input parameters, readonly

State:
	- State is similar to props, but it is private and fully controlled by the component.
	- We mentioned before that components defined as classes have some additional features. Local state is exactly that: a feature available only to classes.
	- While this.props is set up by React itself and this.state has a special meaning, you are free to add additional fields to the class manually if you need to store something that is not used for the visual output.
	- If you don’t use something in render(), it shouldn’t be in the state.
	
	- In React apps, whether a component is stateful or stateless is considered an implementation detail of the component that may change over time. You can use stateless components inside stateful components, and vice versa.
	- this.setState({value: event.target.value}); - MERGES the state - not overrides the state the passed object, but merges it with it.
	- Also, since setState() automatically merges a partial state into the current state, we only needed to call it with the changed parts
	
	- State is reserved only for interactivity, that is, data that changes over time

Prevent component from rendering:
	- return null from the "render" function
	- Returning null from a component’s render method does not affect the firing of the component’s lifecycle methods. For instance, componentWillUpdate and componentDidUpdate will still be called.
	
	
Thinking in React
	The original list of products is passed in as props, so that’s not state. The search text and the checkbox seem to be state since they change over time and can’t be computed from anything. And finally, the filtered list of products isn’t state because it can be computed by combining the original list of products with the search text and value of the checkbox.
	
Lifecycle events: works only on class components (not on functional components)
	componentDidMount		- hook runs after the component output has been rendered to the DOM
	componentWillUnmount	- runs before the component is about to be removed from the DOM
	
JSX:
	- Fundamentally, JSX just provides syntactic sugar for the React.createElement(component, props, ...children) function. The JSX code:
		<MyButton color="blue" shadowSize={2}>
		  Click Me
		</MyButton>
		
		compiles to: React.createElement(MyButton, {color: 'blue', shadowSize: 2}, 'Click Me')
		
		- Capitalized types indicate that the JSX tag is referring to a React component. 
			These tags get compiled into a direct reference to the named variable, so if you use the JSX <Foo /> expression, Foo must be in scope.
			lowercase types (like div, span) get passed as strings to React.createElement:
				React.createElement(Foo, props, ...children)
				React.createElement("div", props, ...children)
		
		User-Defined Components Must Be Capitalized
			When an element type starts with a lowercase letter, it refers to a built-in component like <div> or <span> and results in a string 'div' or 'span' passed to React.createElement. Types that start with a capital letter like <Foo /> compile to React.createElement(Foo) and correspond to a component defined or imported in your JavaScript file.		
		
		- React Must Be in Scope since JSX compiles into calls to React.createElement, the React library must also always be in scope from your JSX code.
		
		- Children:
			- Booleans, Null, and Undefined Are Ignored
			- can be string or expression
			
Ref attribute: works only on DOM elements and custom elements that are classes
	- the "ref" attribute makes it possible to store the DOM element/React component (only if it is a class, not a function!) in our component
		<CustomTextInput ref={(input) => { this.textInput = input; }} />	- CustomTextInput extends from React.Component
	- does not work on functional components because they don’t have instances
		function MyFunctionalComponent() {
		  return <input />;
		}
	
	- There are a few good use cases for refs:
		Managing focus, text selection, or media playback.
		Triggering imperative animations.
		Integrating with third-party DOM libraries.
		
	- Exposing DOM Refs to Parent Components: this works both for classes and for functional components.
	
		function CustomTextInput(props) {
		  return (
			<div>
			  <input ref={props.inputRef} />
			</div>
		  );
		}
		class Parent extends React.Component {
		  render() {
			return (
			  <CustomTextInput
				inputRef={el => this.inputElement = el}
			  />
			);
		  }
		}
		
		
		function CustomTextInput(props) {
		  return (
			<div>
			  <input ref={props.inputRef} />
			</div>
		  );
		}
		function Parent(props) {
		  return (
			<div>
			  My input: <CustomTextInput inputRef={props.inputRef} />
			</div>
		  );
		}
		class Grandparent extends React.Component {
		  render() {
			return (
			  <Parent
				inputRef={el => this.inputElement = el}
			  />
			);
		  }
		}
	
	
Controlled Components
	- In HTML, form elements such as <input>, <textarea>, and <select> typically maintain their own state and update it based on user input. In React, mutable state is typically kept in the state property of components, and only updated with setState().
	We can combine the two by making the React state be the “single source of truth”. Then the React component that renders a form also controls what happens in that form on subsequent user input. An input form element whose value is controlled by React in this way is called a “controlled component”.
	- A controlled input accepts its current value as a prop, as well as a callback to change that value. You could say it’s a more “React way” of approaching this (which doesn’t mean you should always use it).
	- This flow kind of ‘pushes’ the value changes to the form component
	- This means your data (state) and UI (inputs) are always in sync. The state gives the value to the input, and the input asks the Form to change the current value.
	- A form element becomes “controlled” if you set its value via a prop. That’s all.
	
	<input type="text" value={this.state.value} onChange={this.handleChange} />
	handleChange(event) {
		this.setState({value: event.target.value});

	}
	
Uncontrolled Components
	- Controlled components are the recommended approach
	- In this case form data is handled by the DOM, not by React
	- To write an uncontrolled component, instead of writing an event handler for every state update, you can use a ref to get form values from the DOM.
	- you have to ‘pull’ the value from the field when you need it
	
	<input
          defaultValue="Bob"
          type="text"
          ref={(input) => this.input = input} />
		  
Performance:	
	React builds and maintains an internal representation of the rendered UI. It includes the React elements you return from your components.
	This representation lets React avoid creating DOM nodes and accessing existing ones beyond necessity, as that can be slower than operations on JavaScript objects.
	Sometimes it is referred to as a “virtual DOM”, but it works the same way on React Native.

	When a component’s props or state change, React decides whether an actual DOM update is necessary by comparing the newly returned element with the previously rendered one. When they are not equal, React will update the DOM.
	In some cases, your component can speed all of this up by overriding the lifecycle function shouldComponentUpdate, which is triggered before the re-rendering process starts. The default implementation of this function returns true, leaving React to perform the update:
	shouldComponentUpdate(nextProps, nextState) {
	  return true;
	}
	
	Scnenario:
		shouldComponentUpdate: tells whether React should rerender the component and call its "render()" function.
		if shouldComponentUpdate returns false, we are done
		if shouldComponentUpdate returns true, react call the render() method and checks whether the react element is equivalent to the one stored on the Virtual DOM
			- this is just a javascript comparison it should be relatively fast
		if they aren't equivalent react has to update the DOM, otherwise no DOM operation is performed
		

	React.PureComponent: shouldComponentUpdate is just do a “shallow comparison” between all the fields of props and state to determine if the component should update
	
	pure function: they do not attempt to change their inputs, and always return the same result for the same inputs.
		function sum(a, b) {
		  return a + b;
		}
		
		
		
		
ES6:
	computed property name: 
		this.setState({
		  [name]: value
		});
		It is equivalent to this ES5 code:
		var partialState = {};
		partialState[name] = value;
		this.setState(partialState);