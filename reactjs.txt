React

	v16 new features:
		- render() can return an array of components or <> (fragment) to cover multiple components
			- fragments do not need "key" prop to be specified
		- Error boundaries: use the componentDidCatch method to make a component an error boundary
			-  Error boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed.
		- ReactDOM.createPortal()
		- setState() can return null --> this causes React not to invoke the render() function

	Components:
		- Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called “props”) and return React elements describing what should appear on the screen.
			function Welcome(props) {
			  return <h1>Hello, {props.name}</h1>;
			}
			
		- Remember that components may accept arbitrary props, including primitive values, React elements, or functions.
		
		- If you want to reuse non-UI functionality between components, we suggest extracting it into a separate JavaScript module. The components may import it and use that function, object, or a class, without extending it.
		
		- For building a static prototype, don’t use state at all to build this static version. State is reserved only for interactivity, that is, data that changes over time. 
		
		- Render function can return string, React element or a list of these things:
			- either a single React element or string
			- or an array of React elements or strings
				render() {
					return [
						<div key={1} />,
						(
							<div key={2}>
								Hallo!
						</ div>)
					];
				}
		
	Functional components: 
		- a function with "props" parameter and a render method. 
		- State is unique to class components. 
		- 2nd parameter is the context if specified (context is an anti-pattern, use a state-management library like redux instead). 
			- Moreover context is an opt-in feature, meaning Component.contextTypes must be specified otherwise it won't get passed as an argument.
			- So it is important to declare them anytime you use the context.
		
		You’ll need to change this.props to props both times it appears. Many components in your apps will be able to be written as functional components: these components tend to be easier to write and React will optimize them more in the future.
		
		function Square(props, [context]) {
		  return (
			<button className="square" onClick={props.onClick}>
			  {props.value}
			</button>
		  );
		}
		
	Props vs state:
		1. Is it passed in from a parent via props? If so, it probably isn’t state.
		2. Does it remain unchanged over time? If so, it probably isn’t state.
		3. Can you compute it based on any other state or props in your component? If so, it isn’t state.
		
	State's place:
		- Identify every component that renders something based on that state.
		- Find a common owner component (a single component above all the components that need the state in the hierarchy).
		- Either the common owner or another component higher up in the hierarchy should own the state.
		- If you can’t find a component where it makes sense to own the state, create a new component simply for holding the state and add it somewhere in the hierarchy above the common owner component.
			
			
	Event handling:
		1. <button onClick={(e) => this.handleClick(e)}>
			Click me
		  </button>
			The problem with this syntax is that a different callback is created each time the LoggingButton renders. In most cases, this is fine. However, if this callback is passed as a prop to lower components, those components might do an extra re-rendering. 
			
		2. <button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>
		
		3.	<button onClick={this.handleClick}>
				Click me
			</button>
			  
			and in ctor: 
				// This binding is necessary to make `this` work in the callback
				this.handleClick = this.handleClick.bind(this);
				
		Passing parameters:
			<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>
			<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>
			
		It is, however, conventional in React apps to use on* names for the attributes and handle* for the handler methods.
			 <Square value={this.state.squares[i]} onClick={() => this.handleClick(i)}/>



	Props:
		- input parameters, readonly
		
		- to pass all props without having to explicitly type each parameter we can use the spread operator:
			 <Greeting {...props} /> = <Greeting firstName="Ben" lastName="Hector" />

	State:
		- State is similar to props, but it is private and fully controlled by the component.
		- We mentioned before that components defined as classes have some additional features. Local state is exactly that: a feature available only to classes.
		- While this.props is set up by React itself and this.state has a special meaning, you are free to add additional fields to the class manually if you need to store something that is not used for the visual output.
		- If you don’t use something in render(), it shouldn’t be in the state.
		
		- In React apps, whether a component is stateful or stateless is considered an implementation detail of the component that may change over time. You can use stateless components inside stateful components, and vice versa.
		- this.setState({value: event.target.value}); - MERGES the state - not overrides the state the passed object, but merges it with it.
		- Also, since setState() automatically merges a partial state into the current state, we only needed to call it with the changed parts
		
		- State is reserved only for interactivity, that is, data that changes over time
		- If the state changes and we invoke setState React will re-render the entire component 
			- Only in the virtual DOM, then compares it with the real DOM - if the two do not match, only then updates the DOM and only the relevant parts that really changed (does not re-render the whole component into the DOM)
			- State changes are asynchronous. If you read from this.state immediately after calling this.setState, it probably won’t reflect the changes yet.
				- If the current value of the state is needed for calculating the next state, specify a function as the parameter: this.setState((prevState, props) => ({...}), () => {/* state update has just happened*/});

	Prevent component from rendering:
		- return null from the "render" function
		- Returning null from a component’s render method does not affect the firing of the component’s lifecycle methods. For instance, componentWillUpdate and componentDidUpdate will still be called.
		
		
	Thinking in React
		The original list of products is passed in as props, so that’s not state. The search text and the checkbox seem to be state since they change over time and can’t be computed from anything. And finally, the filtered list of products isn’t state because it can be computed by combining the original list of products with the search text and value of the checkbox.
		
	Lifecycle events: works only on class components (not on functional components)
	
		Mounting: these methods are called when an instance of a component is being created and inserted into the DOM:
			constructor()
			componentWillMount()
			render()
			componentDidMount()
			
		Updating: an update can be caused by changes to props or state. These methods are called when a component is being re-rendered:
			componentWillReceiveProps()
			shouldComponentUpdate()
			componentWillUpdate()
			render()
			componentDidUpdate()
			
		Unmounting: this method is called when a component is being removed from the DOM:
			componentWillUnmount()
			
		Error Handling: this method is called when there is an error during rendering, in a lifecycle method, or in the constructor of any child component.
			componentDidCatch()
			
		
		Lifecycle methods in more details:
			render(): can render:
				- React elements. Typically created via JSX. An element can either be a representation of a native DOM component (<div />), or a user-defined composite component (<MyComponent />).
					- React components are what composes the entire virtual DOM. For example: <h1>Hello!</h1> - this is a virtual DOM element
					- ReactDOM.render(<App />, document.getElementById('container')) - renders the <App /> virtual dom element into the real dom element
				- String and numbers. These are rendered as text nodes in the DOM.
				- Portals. Created with ReactDOM.createPortal.
				- null. Renders nothing.
				- Booleans. Render nothing. (Mostly exists to support return test && <Child /> pattern, where test is boolean.)
				
			constructor(props)
				- The constructor for a React component is called before it is mounted.
				- Avoid introducing any side-effects or subscriptions in the constructor. For those use cases, use componentDidMount() instead.
				- The constructor is the right place to initialize state. To do so, just assign an object to this.state; don’t try to call setState() from the constructor. The constructor is also often used to bind event handlers to the class instance.
				
			componentWillMount()
				- componentWillMount() is invoked immediately before mounting occurs. It is called before render(), therefore calling setState() synchronously in this method will not trigger an extra rendering.
				- Generally, we recommend using the constructor() instead.
				- Avoid introducing any side-effects or subscriptions in this method. For those use cases, use componentDidMount() instead.
				
			componentDidMount()
				- it is like ngOnInit()
				- hook runs after the component output has been rendered to the DOM
				- componentDidMount() is invoked immediately after a component is mounted. 
				- Initialization that requires DOM nodes should go here. If you need to load data from a remote endpoint, this is a good place to instantiate the network request.
				- This method is a good place to set up any subscriptions. If you do that, don’t forget to unsubscribe in componentWillUnmount().
				- Calling setState() in this method will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the render() will be called twice in this case, the user won’t see the intermediate state. Use this pattern with caution because it often causes performance issues. It can, however, be necessary for cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.
				
			componentWillReceiveProps(nextProps)
				- componentWillReceiveProps() is invoked before a mounted component receives new props.
				- If you need to update the state in response to prop changes (for example, to reset it), you may compare this.props and nextProps and perform state transitions using this.setState() in this method.
				- Note that React may call this method even if the props have not changed, so make sure to compare the current and next values if you only want to handle changes. This may occur when the parent component causes your component to re-render.
				
			shouldComponentUpdate(nextProps, nextState)
				- Use shouldComponentUpdate() to let React know if a component’s output is not affected by the current change in state or props. 
				- The default behavior is to re-render on every state change, and in the vast majority of cases you should rely on the default behavior. - the function returns "true" by default
				- This method is not called for the initial render or when forceUpdate() is used.
				- Returning false does not prevent child components from re-rendering when their state changes.
				- Currently, if shouldComponentUpdate() returns false, then componentWillUpdate(), render(), and componentDidUpdate() will not be invoked
				
			componentWillUpdate(nextProps, nextState)
				- componentWillUpdate() is invoked immediately before rendering when new props or state are being received. Use this as an opportunity to perform preparation before an update occurs. This method is not called for the initial render.
				- Note that you cannot call this.setState() here; nor should you do anything else (e.g. dispatch a Redux action) that would trigger an update to a React component before componentWillUpdate() returns.
				- If you need to update state in response to props changes, use componentWillReceiveProps() instead.
				
			componentDidUpdate(prevProps, prevState)
				- componentDidUpdate() is invoked immediately after updating occurs. This method is not called for the initial render.
				- Use this as an opportunity to operate on the DOM when the component has been updated. 
				- This is also a good place to do network requests as long as you compare the current props to previous props (e.g. a network request may not be necessary if the props have not changed).
			
			componentWillUnmount()
				- it is like ngOnDestroy()
				- componentWillUnmount() is invoked immediately before a component is unmounted and destroyed. 
				- Perform any necessary cleanup in this method, such as invalidating timers, canceling network requests, or cleaning up any subscriptions that were created in componentDidMount().
				
			componentDidCatch(error, info)
				- Error boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed. 
				- Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them.
				- A class component becomes an error boundary if it defines this lifecycle method. Calling setState() in it lets you capture an unhandled JavaScript error in the below tree and display a fallback UI. 
				- Only use error boundaries for recovering from unexpected exceptions; don’t try to use them for control flow.
				
		Class methods:
		
			setState(updater[, callback])
				- setState() enqueues changes to the component state and tells React that this component and its children need to be re-rendered with the updated state. 
				- This is the primary method you use to update the user interface in response to event handlers and server responses.
				- Think of setState() as a request rather than an immediate command to update the component. For better perceived performance, React may delay it, and then update several components in a single pass. React does not guarantee that the state changes are applied immediately.
				- setState() will always lead to a re-render unless shouldComponentUpdate() returns false. If mutable objects are being used and conditional rendering logic cannot be implemented in shouldComponentUpdate(), calling setState() only when the new state differs from the previous state will avoid unnecessary re-renders.
				
					(prevState, props) => stateChange
					prevState is a reference to the previous state. 
					It should not be directly mutated. 
					Instead, changes should be represented by building a new object based on the input from prevState and props.
					For instance, suppose we wanted to increment a value in state by props.step:
						this.setState((prevState, props) => {
						  return {counter: prevState.counter + props.step};
						});
					Both prevState and props received by the updater function are guaranteed to be up-to-date. The output of the updater is shallowly merged with prevState.
					
				- The second parameter to setState() is an optional callback function that will be executed once setState is completed and the component is re-rendered. Generally we recommend using componentDidUpdate() for such logic instead.
				- You may optionally pass an object as the first argument to setState() instead of a function:
					setState(stateChange[, callback])
					This performs a shallow merge of stateChange into the new state, e.g., to adjust a shopping cart item quantity:
					this.setState({quantity: 2})
					
					This form of setState() is also asynchronous, and multiple calls during the same cycle may be batched together. For example, if you attempt to increment an item quantity more than once in the same cycle, that will result in the equivalent of:
						Object.assign(
						  previousState,
						  {quantity: state.quantity + 1},
						  {quantity: state.quantity + 1},
						  ...
						)
						
					Subsequent calls will override values from previous calls in the same cycle, so the quantity will only be incremented once. If the next state depends on the previous state, we recommend using the updater function form, instead:
						this.setState((prevState) => {
						  return {quantity: prevState.quantity + 1};
						});
			
			component.forceUpdate(callback)
				- By default, when your component’s state or props change, your component will re-render. 
				- If your render() method depends on some other data, you can tell React that the component needs re-rendering by calling forceUpdate().
				
				- Calling forceUpdate() will cause render() to be called on the component, skipping shouldComponentUpdate(). 
				- This will trigger the normal lifecycle methods for child components, including the shouldComponentUpdate() method of each child. 
				- React will still only update the DOM if the markup changes.
				
				- Normally you should try to avoid all uses of forceUpdate() and only read from this.props and this.state in render().


		Class Properties
			defaultProps
				defaultProps can be defined as a property on the component class itself, to set the default props for the class. This is used for undefined props, but not for null props.
					CustomButton.defaultProps = {
						color: 'blue'
					};
					
			displayName
				The displayName string is used in debugging messages. 
				Usually, you don’t need to set it explicitly because it’s inferred from the name of the function or class that defines the component. 
				You might want to set it explicitly if you want to display a different name for debugging purposes or when you create a higher-order component, see Wrap the Display Name for Easy Debugging for details.
						
		Instance Properties
			props
				this.props contains the props that were defined by the caller of this component. See Components and Props for an introduction to props.
				In particular, this.props.children is a special prop, typically defined by the child tags in the JSX expression rather than in the tag itself.

			state
				The state contains data specific to this component that may change over time. The state is user-defined, and it should be a plain JavaScript object.
				If you don’t use it in render(), it shouldn’t be in the state. For example, you can put timer IDs directly on the instance.
				See State and Lifecycle for more information about the state.
				Never mutate this.state directly, as calling setState() afterwards may replace the mutation you made. Treat this.state as if it were immutable.
		
		
	JSX:
		- Fundamentally, JSX just provides syntactic sugar for the React.createElement(component, props, ...children) function. The JSX code:
			<MyButton color="blue" shadowSize={2}>
			  Click Me
			</MyButton>
			
			compiles to: React.createElement(MyButton, {color: 'blue', shadowSize: 2}, 'Click Me')
			
			- Capitalized types indicate that the JSX tag is referring to a React component. 
				These tags get compiled into a direct reference to the named variable, so if you use the JSX <Foo /> expression, Foo must be in scope.
				lowercase types (like div, span) get passed as strings to React.createElement:
					React.createElement(Foo, props, ...children)
					React.createElement("div", props, ...children)
			
			User-Defined Components Must Be Capitalized
				When an element type starts with a lowercase letter, it refers to a built-in component like <div> or <span> and results in a string 'div' or 'span' passed to React.createElement. Types that start with a capital letter like <Foo /> compile to React.createElement(Foo) and correspond to a component defined or imported in your JavaScript file.		
			
			- React Must Be in Scope since JSX compiles into calls to React.createElement, the React library must also always be in scope from your JSX code.
			
			- Children:
				- Booleans, Null, and Undefined Are Ignored
				- can be string or expression
				
	Ref attribute: works only on DOM elements and custom elements that are classes
		- the "ref" attribute makes it possible to store the DOM element/React component (only if it is a class, not a function!) in our component
			<CustomTextInput ref={(input) => { this.textInput = input; }} />	- CustomTextInput extends from React.Component
		- does not work on functional components because they don’t have instances
			function MyFunctionalComponent() {
			  return <input />;
			}
		
		- There are a few good use cases for refs:
			Managing focus, text selection, or media playback.
			Triggering imperative animations.
			Integrating with third-party DOM libraries.
			
		React will call the ref callback with the DOM element when the component mounts, and call it with null when it unmounts. ref callbacks are invoked before componentDidMount or componentDidUpdate lifecycle hooks.
			
		- Exposing DOM Refs to Parent Components: this works both for classes and for functional components.
		
			function CustomTextInput(props) {
			  return (
				<div>
				  <input ref={props.inputRef} />
				</div>
			  );
			}
			class Parent extends React.Component {
			  render() {
				return (
				  <CustomTextInput
					inputRef={el => this.inputElement = el}
				  />
				);
			  }
			}
			
			
			function CustomTextInput(props) {
			  return (
				<div>
				  <input ref={props.inputRef} />
				</div>
			  );
			}
			function Parent(props) {
			  return (
				<div>
				  My input: <CustomTextInput inputRef={props.inputRef} />
				</div>
			  );
			}
			class Grandparent extends React.Component {
			  render() {
				return (
				  <Parent
					inputRef={el => this.inputElement = el}
				  />
				);
			  }
			}
			
	Forwarding Refs: 
		- Ref forwarding is a technique for passing a ref through a component to one of its descendants. This technique can be particularly useful with higher-order components (also known as HOCs).
		- By default Refs can only be assigned to the component they are specified to, or can be lifted up as props to any parent component
			
			function logProps(WrappedComponent) {
			  class LogProps extends React.Component {
				componentDidUpdate(prevProps) {
				  console.log('old props:', prevProps);
				  console.log('new props:', this.props);
				}

				render() {
				  return <WrappedComponent {...this.props} />;
				}
			  }

			  return LogProps;
			}
			The “logProps” HOC passes all props through to the component it wraps, so the rendered output will be the same.
			There is one caveat to the above example: refs will not get passed through. That’s because ref is not a prop. Like key, it’s handled differently by React. If you add a ref to a HOC, the ref will refer to the outermost container component, not the wrapped component.
			
			This means that refs intended for our FancyButton component will actually be attached to the LogProps component:
				class FancyButton extends React.Component {
				  focus() {
					// ...
				  }

				  // ...
				}

				// Rather than exporting FancyButton, we export LogProps.
				// It will render a FancyButton though.
				export default logProps(FancyButton);
			
				import FancyButton from './FancyButton';
				const ref = React.createRef();

				// The FancyButton component we imported is the LogProps HOC.
				// Even though the rendered output will be the same,
				// Our ref will point to LogProps instead of the inner FancyButton component!
				// This means we can't call e.g. ref.current.focus()
				<FancyButton
				  label="Click Me"
				  handleClick={handleClick}
				  ref={ref}
				/>;
		
		
		- Fortunately, we can explicitly forward refs to the inner FancyButton component using the React.forwardRef API. React.forwardRef accepts a render function that receives props and ref parameters and returns a React node. For example:
		
			function logProps(Component) {
			  class LogProps extends React.Component {
				componentDidUpdate(prevProps) {
				  console.log('old props:', prevProps);
				  console.log('new props:', this.props);
				}

				render() {
				  const {forwardedRef, ...rest} = this.props;

				  // Assign the custom prop "forwardedRef" as a ref
				  return <Component ref={forwardedRef} {...rest} />;
				}
			  }

			  // Note the second param "ref" provided by React.forwardRef.
			  // We can pass it along to LogProps as a regular prop, e.g. "forwardedRef"
			  // And it can then be attached to the Component.
			  function forwardRef(props, ref) {
				return <LogProps {...props} forwardedRef={ref} />;
			  }

			  // These next lines are not necessary,
			  // But they do give the component a better display name in DevTools,
			  // e.g. "ForwardRef(logProps(MyComponent))"
			  const name = Component.displayName || Component.name;
			  forwardRef.displayName = `logProps(${name})`;

			  return React.forwardRef(forwardRef);
			}
		
			
	Conditional rendering:
		This works because in JavaScript, true && expression always evaluates to expression, and false && expression always evaluates to false.
			return (
				<div>
				  <h1>Hello!</h1>
				  {unreadMessages.length > 0 &&
					<h2>
					  You have {unreadMessages.length} unread messages.
					</h2>
				  }
				</div>
			);
			
	State:
		
		1. Do Not Modify State Directly: use .setState
		
		2. State Updates May Be Asynchronous - use a second form of setState() that accepts a function rather than an object. That function will receive the previous state as the first argument, and the props at the time the update is applied as the second argument:
			// Correct
			this.setState((prevState, props) => ({
			  counter: prevState.counter + props.increment
			}));
			
		3. State Updates are Merged
		
		While this.props is set up by React itself and this.state has a special meaning, you are free to add additional fields to the class manually if you need to store something that is not used for the visual output.
		If you don’t use something in render(), it shouldn’t be in the state.
		
		
	Controlled Components
		- In HTML, form elements such as <input>, <textarea>, and <select> typically maintain their own state and update it based on user input. In React, mutable state is typically kept in the state property of components, and only updated with setState().
		We can combine the two by making the React state be the “single source of truth”. Then the React component that renders a form also controls what happens in that form on subsequent user input. An input form element whose value is controlled by React in this way is called a “controlled component”.
		- A controlled input accepts its current value as a prop, as well as a callback to change that value. You could say it’s a more “React way” of approaching this (which doesn’t mean you should always use it).
		- This flow kind of ‘pushes’ the value changes to the form component
		- This means your data (state) and UI (inputs) are always in sync. The state gives the value to the input, and the input asks the Form to change the current value.
		- A form element becomes “controlled” if you set its value via a prop. That’s all.
		
		<input type="text" value={this.state.value} onChange={this.handleChange} />
		handleChange(event) {
			this.setState({value: event.target.value});

		}
		
	Uncontrolled Components
		- Controlled components are the recommended approach
		- In this case form data is handled by the DOM, not by React
		- To write an uncontrolled component, instead of writing an event handler for every state update, you can use a ref to get form values from the DOM.
		- you have to "pull" the value from the field when you need it
		
		<input
			  defaultValue="Bob"
			  type="text"
			  ref={(input) => this.input = input} />
			  
	Performance:	
		React builds and maintains an internal representation of the rendered UI. It includes the React elements you return from your components.
		This representation lets React avoid creating DOM nodes and accessing existing ones beyond necessity, as that can be slower than operations on JavaScript objects.
		Sometimes it is referred to as a “virtual DOM”, but it works the same way on React Native.

		When a component’s props or state change, React decides whether an actual DOM update is necessary by comparing the newly returned element with the previously rendered one. When they are not equal, React will update the DOM.
		In some cases, your component can speed all of this up by overriding the lifecycle function shouldComponentUpdate, which is triggered before the re-rendering process starts. The default implementation of this function returns true, leaving React to perform the update:
		shouldComponentUpdate(nextProps, nextState) {
		  return true;
		}
		
		Scenario:
			shouldComponentUpdate: tells whether React should rerender the component and call its "render()" function. (whenever we change the state, react will invoke the shouldComponentUpdate function)
			if shouldComponentUpdate returns false, we are done
			if shouldComponentUpdate returns true, react calls the render() method and checks whether the react element is equivalent to the one stored on the Virtual DOM
				- this is just a javascript comparison it should be relatively fast
			if they aren't equivalent react has to update the DOM, otherwise no DOM operation is performed
			

		React.PureComponent: shouldComponentUpdate just does a “shallow comparison” between all the fields of props and state to determine if the component should update
		
		pure function: they do not attempt to change their inputs, and always return the same result for the same inputs.
			function sum(a, b) {
			  return a + b;
			}
			
			
		The biggest benefit of immutability in React comes when you build simple pure components. Since immutable data can more easily determine if changes have been made, it also helps to determine when a component requires being re-rendered.
			
			
	Functional vs class components:
		- function components are simpler
		- class components can have state and lifecycle hooks
		
		
	Context:
		In some cases, you want to pass data through the component tree without having to pass the props down manually at every level. You can do this directly in React with the powerful “context” API.
		
		Why Not To Use Context:
			- most applications do not need it
			- If you want your application to be stable, don’t use context. It is an experimental API and it is likely to break in future releases of React.
			- If you aren’t familiar with state management libraries like Redux or MobX, don’t use context.
				- For many practical applications, these libraries and their React bindings are a good choice for managing state that is relevant to many components. 
				
		Example:
			class Button extends React.Component {
			  render() {
				return (
				  <button style={{background: this.context.color}}>
					{this.props.children}
				  </button>
				);
			  }
			}
			Button.contextTypes = {
			  color: PropTypes.string
			};
			
			class Message extends React.Component {
			  render() {
				return (
				  <div>
					{this.props.text} <Button>Delete</Button>
				  </div>
				);
			  }
			}

			class MessageList extends React.Component {
			  getChildContext() {
				return {color: "purple"};
			  }

			  render() {
				const children = this.props.messages.map((message) =>
				  <Message text={message.text} />
				);
				return <div>{children}</div>;
			  }
			}
			MessageList.childContextTypes = {
			  color: PropTypes.string
			};
			
				By adding childContextTypes and getChildContext to MessageList (the context provider), React passes the information down automatically and any component in the subtree (in this case, Button) can access it by defining contextTypes.

				If contextTypes is not defined, then context will be an empty object.
				
		Parent-Child Coupling: React Router V4 uses this context API
		
		Referencing Context in Lifecycle Methods:
			If contextTypes is defined within a component, the following lifecycle methods will receive an additional parameter, the context object:
				- constructor(props, context)
				- componentWillReceiveProps(nextProps, nextContext)
				- shouldComponentUpdate(nextProps, nextState, nextContext)
				- componentWillUpdate(nextProps, nextState, nextContext)

				
	Fragments: a common pattern for a component to return multiple elements
		- the react components (capitalized classes) do not get rendered into the DOM - so for example in case of <Column /> we will never see <Column /> DOM node.
		- however a component in its render() function can return only 1 element
			- another component, text, numbers
			- or an array of one of the above
		- fragments are good for returning multiple elements	

		class Columns extends React.Component {
		  render() {
			return (
			  <React.Fragment> 		or <>
				<td>Hello</td>
				<td>World</td>
			  </React.Fragment>		or </>
			);
		  }
		}
		
		class Table extends React.Component {
		  render() {
			return (
			  <table>
				<tr>
				  <Columns />
				</tr>
			  </table>
			);
		  }
		}
		
		Use <Fragment> when a key prop is required:

			import React, { Fragment } from 'react';

			function Glossary(props) {
			  return (
				<dl>
				  {props.items.map(item => (
					// Without the `key`, React will fire a key warning
					<Fragment key={item.id}>
					  <dt>{item.term}</dt>
					  <dd>{item.description}</dd>
					</Fragment>
				  ))}
				</dl>
			  );
			}
		Use <></> syntax everywhere else:

			function ListItem({ item }) {
			  return ( 
				<>
				  <dt>{item.term}</dt>
				  <dd>{item.description}</dd>>
				</>
			  );    
			}
		
		
	Portals: Portals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy of the parent component.

		ReactDOM.createPortal(child, container)
		
		render() {
		  // React mounts a new div and renders the children into it
		  return (
			<div>
			  {this.props.children}
			</div>
		  );
		}
		render() {
		  // React does *not* create a new div. It renders the children into `domNode`.
		  // `domNode` is any valid DOM node, regardless of its location in the DOM.
		  return ReactDOM.createPortal(
			this.props.children,
			domNode,
		  );
		}
		
		Event Bubbinlg Through Portals:
			Even though a portal can be anywhere in the DOM tree, it behaves like a normal React child in every other way. Features like context work exactly the same regardless of whether the child is a portal, as the portal still exists in the React tree regardless of position in the DOM tree.

			This includes event bubbling. An event fired from inside a portal will propagate to ancestors in the containing React tree, even if those elements are not ancestors in the DOM tree. Assuming the following HTML structure:
			

	Error Boundaries
		A JavaScript error in a part of the UI shouldn’t break the whole app. To solve this problem for React users, React 16 introduces a new concept of an “error boundary”.

		Error boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed.
		Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them.
		
		Error boundaries do not catch errors for:
			- Event handlers (learn more)
			- Asynchronous code (e.g. setTimeout or requestAnimationFrame callbacks)
			- Server side rendering
			- Errors thrown in the error boundary itself (rather than its children)
			
		A class component becomes an error boundary if it defines a new lifecycle method called "componentDidCatch(error, info)"
		
			componentDidCatch(error, info) {
				// Display fallback UI
				this.setState({ hasError: true });
				// You can also log the error to an error reporting service
				logErrorToMyService(error, info);
			}
			
		The componentDidCatch() method works like a JavaScript catch {} block, but for components. Only class components can be error boundaries. In practice, most of the time you’ll want to declare an error boundary component once and use it throughout your application.
		
		Where to Place Error Boundaries
			The granularity of error boundaries is up to you. 
			You may wrap top-level route components to display a “Something went wrong” message to the user, just like server-side frameworks often handle crashes. 
			You may also wrap individual widgets in an error boundary to protect them from crashing the rest of the application.
			
		New Behavior for Uncaught Errors
			This change has an important implication. As of React 16, errors that were not caught by any error boundary will result in unmounting of the whole React component tree.
			
		How About try/catch?
			try / catch is great but it only works for imperative code:
				try {
				  showButton();
				} catch (error) {
				  // ...
				}
			However, React components are declarative and specify what should be rendered:
				<Button />
				Error boundaries preserve the declarative nature of React, and behave as you would expect. For example, even if an error occurs in a componentDidUpdate hook caused by a setState somewhere deep in the tree, it will still correctly propagate to the closest error boundary.
			
		How About Event Handlers?
			Error boundaries do not catch errors inside event handlers.

			React doesn’t need error boundaries to recover from errors in event handlers. Unlike the render method and lifecycle hooks, the event handlers don’t happen during rendering. So if they throw, React still knows what to display on the screen.

			If you need to catch an error inside event handler, use the regular JavaScript try / catch statement:
				class MyComponent extends React.Component {
				  constructor(props) {
					super(props);
					this.state = { error: null };
				  }
				  
				  handleClick = () => {
					try {
					  // Do something that could throw
					} catch (error) {
					  this.setState({ error });
					}
				  }

				  render() {
					if (this.state.error) {
					  return <h1>Caught an error.</h1>
					}
					return <div onClick={this.handleClick}>Click Me</div>
				  }
				}
				
	Higher-Order Components	(HOC)
		A higher-order component (HOC) is an advanced technique in React for reusing component logic. HOCs are not part of the React API, per se. They are a pattern that emerges from React’s compositional nature.
		Concretely, a higher-order component is a function that takes a component and returns a new component.
			const EnhancedComponent = higherOrderComponent(WrappedComponent);
			
			The function receives a Component as its 1st parameter and that component becomes the child of the returned new, enhanced Component.
			
		Whereas a component transforms props into UI, a higher-order component transforms a component into another component.
		HOCs are common in third-party React libraries, such as Redux’s connect and Relay’s createFragmentContainer.
		
		Note that a HOC doesn’t modify the input component, nor does it use inheritance to copy its behavior. Rather, a HOC composes the original component by wrapping it in a container component. 
		A HOC is a pure function with zero side-effects.
		
			const CommentListWithSubscription = withSubscription(
			  CommentList,
			  (DataSource) => DataSource.getComments()
			);

			const BlogPostWithSubscription = withSubscription(
			  BlogPost,
			  (DataSource, props) => DataSource.getBlogPost(props.id)
			);
		
			// This function takes a component...
			function withSubscription(WrappedComponent, selectData) {
			  // ...and returns another component...
			  return class extends React.Component {
				constructor(props) {
				  super(props);
				  this.handleChange = this.handleChange.bind(this);
				  this.state = {
					data: selectData(DataSource, props)
				  };
				}

				componentDidMount() {
				  // ... that takes care of the subscription...
				  DataSource.addChangeListener(this.handleChange);
				}

				componentWillUnmount() {
				  DataSource.removeChangeListener(this.handleChange);
				}

				handleChange() {
				  this.setState({
					data: selectData(DataSource, this.props)
				  });
				}

				render() {
				  // ... and renders the wrapped component with the fresh data!
				  // Notice that we pass through any additional props
				  return <WrappedComponent data={this.state.data} {...this.props} />;
				}
			  };
			}
			
		Don’t Mutate the Original Component. Use Composition.
				function logProps(InputComponent) {
				  InputComponent.prototype.componentWillReceiveProps = function(nextProps) {
					console.log('Current props: ', this.props);
					console.log('Next props: ', nextProps);
				  };
				  // The fact that we're returning the original input is a hint that it has
				  // been mutated.
				  return InputComponent;
				}

				// EnhancedComponent will log whenever props are received
				const EnhancedComponent = logProps(InputComponent);
			
			Instead of mutation, HOCs should use composition, by wrapping the input component in a container component:

				function logProps(WrappedComponent) {
				  return class extends React.Component {
					componentWillReceiveProps(nextProps) {
					  console.log('Current props: ', this.props);
					  console.log('Next props: ', nextProps);
					}
					render() {
					  // Wraps the input component in a container, without mutating it. Good!
					  return <WrappedComponent {...this.props} />;
					}
				  }
				}
				
				This HOC has the same functionality as the mutating version while avoiding the potential for clashes. It works equally well with class and functional components. And because it’s a pure function, it’s composable with other HOCs, or even with itself.
				
		Convention: Pass Unrelated Props Through to the Wrapped Component
			render() {
			  // Filter out extra props that are specific to this HOC and shouldn't be
			  // passed through
			  const { extraProp, ...passThroughProps } = this.props;

			  // Inject props into the wrapped component. These are usually state values or
			  // instance methods.
			  const injectedProp = someStateOrInstanceMethod;

			  // Pass props to wrapped component
			  return (
				<WrappedComponent
				  injectedProp={injectedProp}
				  {...passThroughProps}
				/>
			  );
			}
			
		Convention: Maximizing Composability
			// React Redux's `connect`
			const ConnectedComment = connect(commentSelector, commentActions)(CommentList);
			
			What?! If you break it apart, it’s easier to see what’s going on.
				// connect is a function that returns another function
				const enhance = connect(commentListSelector, commentListActions);
				// The returned function is a HOC, which returns a component that is connected
				// to the Redux store
				const ConnectedComment = enhance(CommentList);
				
			// Instead of doing this...
			const EnhancedComponent = withRouter(connect(commentSelector)(WrappedComponent))

			// ... you can use a function composition utility
			// compose(f, g, h) is the same as (...args) => f(g(h(...args)))
			const enhance = compose(
			  // These are both single-argument HOCs
			  withRouter,
			  connect(commentSelector)
			)
			const EnhancedComponent = enhance(WrappedComponent)
			
		Convention: Wrap the Display Name for Easy Debugging
			The most common technique is to wrap the display name of the wrapped component. So if your higher-order component is named withSubscription, and the wrapped component’s display name is CommentList, use the display name WithSubscription(CommentList):

			function withSubscription(WrappedComponent) {
			  class WithSubscription extends React.Component {/* ... */}
			  WithSubscription.displayName = `WithSubscription(${getDisplayName(WrappedComponent)})`;
			  return WithSubscription;
			}

			function getDisplayName(WrappedComponent) {
			  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
			}
			
		Caveats
			Don’t Use HOCs Inside the render Method
				-Instead, apply HOCs outside the component definition so that the resulting component is created only once. Then, its identity will be consistent across renders. This is usually what you want, anyway.
				- In those rare cases where you need to apply a HOC dynamically, you can also do it inside a component’s lifecycle methods or its constructor.
			
				render() {
				  // A new version of EnhancedComponent is created on every render
				  // EnhancedComponent1 !== EnhancedComponent2
				  const EnhancedComponent = enhance(MyComponent);
				  // That causes the entire subtree to unmount/remount each time!
				  return <EnhancedComponent />;
				}
				The problem here isn’t just about performance — remounting a component causes the state of that component and all of its children to be lost.
				
			Static Methods Must Be Copied Over
				function enhance(WrappedComponent) {
				  class Enhance extends React.Component {/*...*/}
				  // Must know exactly which method(s) to copy :(
				  Enhance.staticMethod = WrappedComponent.staticMethod;
				  return Enhance;
				}
				
				However, this requires you to know exactly which methods need to be copied. You can use hoist-non-react-statics to automatically copy all non-React static methods.
				
					import hoistNonReactStatic from 'hoist-non-react-statics';
					function enhance(WrappedComponent) {
					  class Enhance extends React.Component {/*...*/}
					  hoistNonReactStatic(Enhance, WrappedComponent);
					  return Enhance;
					}
					
			Refs Aren’t Passed Through


	Render props: More concretely, a render prop is a function prop that a component uses to know what to render.

		- In fact, any prop that is a function that a component uses to know what to render is technically a “render prop”.
		- One interesting thing to note about render props is that you can implement most higher-order components (HOC) using a regular component with a render prop. 

		Example:
			class MouseTracker extends React.Component {
			  render() {
				return (
				  <div>
					<h1>Move the mouse around!</h1>
					<Mouse render={mouse => (
					  <Cat mouse={mouse} />
					)}/>
				  </div>
				);
			  }
			}
			class Mouse extends React.Component {
			  constructor(props) {
				super(props);
				this.handleMouseMove = this.handleMouseMove.bind(this);
				this.state = { x: 0, y: 0 };
			  }

			  handleMouseMove(event) {
				this.setState({
				  x: event.clientX,
				  y: event.clientY
				});
			  }

			  render() {
				return (
				  <div style={{ height: '100%' }} onMouseMove={this.handleMouseMove}>

					{/*
					  Instead of providing a static representation of what <Mouse> renders,
					  use the `render` prop to dynamically determine what to render.
					*/}
					{this.props.render(this.state)}
				  </div>
				);
			  }
			}
		
		HOC example:
			// If you really want a HOC for some reason, you can easily
			// create one using a regular component with a render prop!
			function withMouse(Component) {
			  return class extends React.Component {
				render() {
				  return (
					<Mouse render={mouse => (
					  <Component {...this.props} mouse={mouse} />
					)}/>
				  );
				}
			  }
			}
			
		children as render prop:
			Although the examples above use render, we could just as easily use the children prop!
				<Mouse children={mouse => (
				  <p>The mouse position is {mouse.x}, {mouse.y}</p>
				)}/>
				
			And remember, the children prop doesn’t actually need to be named in the list of “attributes” in your JSX element. Instead, you can put it directly inside the element!
				<Mouse>
				  {mouse => (
					<p>The mouse position is {mouse.x}, {mouse.y}</p>
				  )}
				</Mouse>
				
		Caveats! Be careful when using Render Props with React.PureComponent
			class Mouse extends React.PureComponent {
			  // Same implementation as above...
			}
			class MouseTracker extends React.Component {
			  render() {
				return (
				  <div>
					<h1>Move the mouse around!</h1>

					{/*
					  This is bad! The value of the `render` prop will
					  be different on each render.
					*/}
					<Mouse render={mouse => (
					  <Cat mouse={mouse} />
					)}/>
				  </div>
				);
			  }
			}
			
			To get around this problem, you can sometimes define the prop as an instance method, like so:

				class MouseTracker extends React.Component {
				  constructor(props) {
					super(props);

					// This binding ensures that `this.renderTheCat` always refers
					// to the *same* function when we use it in render.
					this.renderTheCat = this.renderTheCat.bind(this);
				  }

				  renderTheCat(mouse) {
					return <Cat mouse={mouse} />;
				  }

				  render() {
					return (
					  <div>
						<h1>Move the mouse around!</h1>
						<Mouse render={this.renderTheCat} />
					  </div>
					);
				  }
				}
				In cases where you cannot bind the instance method ahead of time in the constructor (e.g. because you need to close over the component’s props and/or state) <Mouse> should extend React.Component instead.
			

	Code splitting: to produce smaller bundles:
		Before:
			import { add } from './math';
			console.log(add(16, 26));
		After:
			import("./math").then(math => {
			  console.log(math.add(16, 26));
			});
			
		Create React App has this configured automatically with webpack (because this syntax in not yet in the ECMAScript standard)
			
		Libraries: 
			React Loadable: React Loadable wraps dynamic imports in a nice, React-friendly API for introducing code splitting into your app at a given component.
		
		Route-based code splitting: Here’s an example of how to setup route-based code splitting into your app using libraries like React Router and React Loadable.
			import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';
			import Loadable from 'react-loadable';

			const Loading = () => <div>Loading...</div>;

			const Home = Loadable({
			  loader: () => import('./routes/Home'),
			  loading: Loading,
			});

			const About = Loadable({
			  loader: () => import('./routes/About'),
			  loading: Loading,
			});

			const App = () => (
			  <Router>
				<Switch>
				  <Route exact path="/" component={Home}/>
				  <Route path="/about" component={About}/>
				</Switch>
			  </Router>
			);
			
			
	React elements vs HTML elements
		React JSX				HTML
		camelCasing				lowercasing
		className				class
		htmlForm				for
		

React Router
	Currently, a link's pathname must be absolute
	
	Most important components:
		<BrowserRouter>
		<Route> - to create placeholders where the router injects the specified component into
			What does the <Route> render?
				1. component: a React component. When a route with a component prop matches, the route will return a new element whose type is the provided React component (created using React.createElement).
				2. render: a function that returns a React element [5]. It will be called when the path matches. This is similar to component, but is useful for inline rendering and passing extra props to the element.
				3. children: a function that returns a React element. Unlike the prior two props, this will always be rendered, regardless of whether the route’s path matches the current location.
				
				<Route path='/page' component={Page} />
				
				const extraProps = { color: 'red' }
				<Route path='/page' render={(props) => (
				  <Page {...props} data={extraProps}/>
				)}/>
				
				<Route path='/page' children={(props) => (
				  props.match
					? <Page {...props}/>
					: <EmptyPage {...props}/>
				)}/>
		<Link> - to create links
		<Switch> - renders only the 1st <Route /> that matches the url
			- by default each <Route /> gets rendered
				<Route path="/about" component={About}/>
				<Route path="/:user" component={User}/>
				<Route component={NoMatch}/>
				- If the URL is /about, then <About>, <User>, and <NoMatch> will all render because they all match the path. This is by design, allowing us to compose <Route>s into our apps in many ways, like sidebars and breadcrumbs, bootstrap tabs, etc.
		<Redirect> - to redirect the user to the specified component. This changes the browser history along with the browser url as well.
		
		
		<Route path="/cats/:id" component={CatPage} />
			The <Route> injects routing props to its child component (the one it renders. In this case it is CatPage)
				- match
				- location
				- history - can be used to programatically change the url. This initiates a navigation
					- this.props.history.push('url');
			
			- The CatPage will have a props called "match" which "params" property will contain the url parameters:
				props.match.params.id
				To access this from the mapStateToProps function: ownProps.match.params.id
			All properties of match:
				- isExact
				- params
				- path
				- url
				
		404 pages:
			- <Route component={NotFound} /> - this renders the NotFound component no matter what the url is
			- place this Route to be the last
			- wrap all the routes with the <Switch> component

	Connected React Router: 
		- a Redux binding for React Router v4
		- the Redux Chrome browser extension will display history related to route changes and we can go back in time
	
	
Redux

	Overview:
		Redux manages the state of an app using a single store. To modify the state, an action is dispatched to the store and a reducer updates the store based on the type and other values of the action. 
		In order to use the new state, the store can be subscribed to. Subscribing requires a callback function which is called whenever the store updates.
		
	What makes redux fast:
		- I have to create a new instance for the state at each dispatch though
		- I can keep using previous references to arrays, complex objects if they did not change! - this makes it fast
			- React PureComponents do a shallow comparison on props passed to them
			- react-redux's connect() function implements shouldComponentUpdate and does a shallow reference comparison
		- Though on each state change all of the mapStateToProps() functions get executed again, but the reference of the props stay the same => shouldComponentUpdate() returns false => and no render() is invoked
			- For complex calculations in mapStateToProps reselect can be used which uses caching
		
	Data flow in React: dispatch(action) -> reducer -> new state -> re-render

	Redux is a predictable state container for JavaScript apps.
	
	- The whole state of your app is stored in an object tree inside a single store.
	- The only way to change the state tree is to emit an action, an object describing what happened.
	- To specify how the actions transform the state tree, you write pure reducers.
	
	Glossary:
	
		State:
			- State (also called the state tree) is a broad term, but in the Redux API it usually refers to the single state value that is managed by the store and returned by getState(). It represents the entire state of a Redux application, which is often a deeply nested object. TRhe state is readonly. The only way to change the state tree is to dispatch an action.
			
		Action: 
			- An action is a plain object that represents an intention to change the state. Actions are the only way to get data into the store. Any data, whether from UI events, network callbacks, or other sources such as WebSockets needs to eventually be dispatched as actions.
			- Actions must have a type field that indicates the type of action being performed. Types can be defined as constants and imported from another module. It's better to use strings for type than Symbols because strings are serializable.
			
		Reducer:
			type Reducer<S, A> = (state: S, action: A) => S
			- A reducer (also called a reducing function) is a function that accepts an accumulation and a value and returns a new accumulation. They are used to reduce a collection of values down to a single value.
			- In Redux, the accumulated value is the state object, and the values being accumulated are actions. Reducers calculate a new state given the previous state and an action. They must be pure functions—functions that return the exact same output for given inputs. They should also be free of side-effects. This is what enables exciting features like hot reloading and time travel.
			- They must be synchronous
			- No side effects (no going to the server, debounce, setTimeout, etc.)
			- Do not modify the values passed to them - they are immutable
			- A useful convention is to always name the reducers after the state-key they manage. This way combineReducers will produce a state with the exact same as the reducers have.
			
		Dispatching function:
			type BaseDispatch = (a: Action) => Action
			type Dispatch = (a: Action | AsyncAction) => any
			A dispatching function (or simply dispatch function) is a function that accepts an action or an async action; it then may or may not dispatch one or more actions to the store.

			We must distinguish between dispatching functions in general and the base dispatch function provided by the store instance without any middleware.

			The base dispatch function always synchronously sends an action to the store's reducer, along with the previous state returned by the store, to calculate a new state. 
			It expects actions to be plain objects ready to be consumed by the reducer.

			Middleware wraps the base dispatch function. It allows the dispatch function to handle async actions, or even Observables in addition to actions. 
			Middleware may transform, delay, ignore, dispatch a new action, or otherwise interpret actions or async actions before passing them to the next middleware. 
			See below for more information.
	
		Action Creator
			type ActionCreator = (...args: any) => Action | AsyncAction
			An action creator is, quite simply, a function that creates an action. Do not confuse the two terms—again, an action is a payload of information, and an action creator is a factory that creates an action.

			Calling an action creator only produces an action, but does not dispatch it. You need to call the store's dispatch function to actually cause the mutation. Sometimes we say bound action creators to mean functions that call an action creator and immediately dispatch its result to a specific store instance.

			If an action creator needs to read the current state, perform an API call, or cause a side effect, like a routing transition, it should return an async action instead of an action.
			
		Async Action
			type AsyncAction = any
			An async action is a value that is sent to a dispatching function, but is not yet ready for consumption by the reducer. It will be transformed by middleware into an action (or a series of actions) before being sent to the base dispatch() function. Async actions may have different types, depending on the middleware you use. They are often asynchronous primitives, like a Promise or a thunk, which are not passed to the reducer immediately, but trigger action dispatches once an operation has completed.
			
		Middleware
			type MiddlewareAPI = { dispatch: Dispatch, getState: () => State }
			type Middleware = (api: MiddlewareAPI) => (next: Dispatch) => Dispatch
			A middleware is a higher-order function that composes a dispatch function to return a new dispatch function. It often turns async actions into actions.

			Middleware is composable using function composition. It is useful for logging actions, performing side effects like routing, or turning an asynchronous API call into a series of synchronous actions.
			
			Middleware enhances the store by enabling you to interact with dispatched actions before they reach the store. 
			To do this, the store's dispatch function is modified to run the middleware functions before the original dispatch function is called which ultimately sends the action to the reducers.
			
			Middleware provides a way to interact with actions that have been dispatched to the store before they reach the store's reducer.
				Middleware is used by composing the functions together and passing that function to your createStore call. 
				The composed middleware function is used to replace the store's default dispatch method with one that dispatches the action to each middleware function in a chain, 
				with the last middleware function dispatching the action to the store.
			
		Store
			type Store = {
			  dispatch: Dispatch
			  getState: () => State
			  subscribe: (listener: () => void) => () => void
			  replaceReducer: (reducer: Reducer) => void
			}
			A store is an object that holds the application's state tree.
			There should only be a single store in a Redux app, as the composition happens on the reducer level.

			dispatch(action) is the base dispatch function described above.
			getState() returns the current state of the store.
			subscribe(listener) registers a function to be called on state changes.
			replaceReducer(nextReducer) can be used to implement hot reloading and code splitting. Most likely you won't use it.
		
		Store creator
			type StoreCreator = (reducer: Reducer, preloadedState: ?State) => Store
			A store creator is a function that creates a Redux store. Like with dispatching function, we must distinguish the base store creator, createStore(reducer, preloadedState) exported from the Redux package, from store creators that are returned from the store enhancers.
			
		Store enhancer
			type StoreEnhancer = (next: StoreCreator) => StoreCreator
			A store enhancer is a higher-order function that composes a store creator to return a new, enhanced store creator. This is similar to middleware in that it allows you to alter the store interface in a composable way.

			Store enhancers are much the same concept as higher-order components in React, which are also occasionally called "component enhancers".
	
	
	Reducer: a pure function with (state, action) => state signature.
		The shape of the state is up to you: it can be a primitive, an array, an object, or even an Immutable.js data structure. The only important part is that you should not mutate the state object, but return a new object if the state changes.

	Example:		
		// Create a Redux store holding the state of your app.
		// Its API is { subscribe, dispatch, getState }.
		let store = createStore(counter)

		// You can use subscribe() to update the UI in response to state changes.
		// Normally you'd use a view binding library (e.g. React Redux) rather than subscribe() directly.
		// However it can also be handy to persist the current state in the localStorage.

		store.subscribe(() =>
		  console.log(store.getState())
		)

		// The only way to mutate the internal state is to dispatch an action.
		// The actions can be serialized, logged or stored and later replayed.
		store.dispatch({ type: 'INCREMENT' })
		// 1
		store.dispatch({ type: 'INCREMENT' })
		// 2
		store.dispatch({ type: 'DECREMENT' })
		
	Instead of mutating the state directly, you specify the mutations you want to happen with plain objects called actions. Then you write a special function called a reducer to decide how every action transforms the entire application's state.
	
	If you're coming from Flux, there is a single important difference you need to understand. Redux doesn't have a Dispatcher or support many stores. Instead, there is just a single store with a single root reducing function. As your app grows, instead of adding stores, you split the root reducer into smaller reducers independently operating on the different parts of the state tree. This is exactly like how there is just one root component in a React app, but it is composed out of many small components.
	
	Finally, to tie state and actions together, we write a function called a reducer. It would be hard to write such a function for a big app, so we write smaller functions managing parts of the state:
		function visibilityFilter(state = 'SHOW_ALL', action) {
		  if (action.type === 'SET_VISIBILITY_FILTER') {
			return action.filter
		  } else {
			return state
		  }
		}

		function todos(state = [], action) {
		  switch (action.type) {
			case 'ADD_TODO':
			  return state.concat([{ text: action.text, completed: false }])
			case 'TOGGLE_TODO':
			  return state.map(
				(todo, index) =>
				  action.index === index
					? { text: todo.text, completed: !todo.completed }
					: todo
			  )
			default:
			  return state
		  }
		}
	And we write another reducer that manages the complete state of our app by calling those two reducers for the corresponding state keys:
		function todoApp(state = {}, action) {
		  return {
			todos: todos(state.todos, action),
			visibilityFilter: visibilityFilter(state.visibilityFilter, action)
		  }
		}
		
	Three Principles:
		1. Single source of truth: The state of your whole application is stored in an object tree within a single store.
		2. State is read-only: The only way to change the state is to emit an action, an object describing what happened.
			This ensures that neither the views nor the network callbacks will ever write directly to the state. Instead, they express an intent to transform the state. Because all changes are centralized and happen one by one in a strict order, there are no subtle race conditions to watch out for. As actions are just plain objects, they can be logged, serialized, stored, and later replayed for debugging or testing purposes.
		3. Changes are made with pure functions: To specify how the state tree is transformed by actions, you write pure reducers.
			Reducers are just pure functions that take the previous state and an action, and return the next state. Remember to return new state objects, instead of mutating the previous state. You can start with a single reducer, and as your app grows, split it off into smaller reducers that manage specific parts of the state tree. Because reducers are just functions, you can control the order in which they are called, pass additional data, or even make reusable reducers for common tasks such as pagination.
			
			import { combineReducers, createStore } from 'redux'
			const reducer = combineReducers({ visibilityFilter, todos })
			const store = createStore(reducer)

		
	API:
		combineReducers(reducers)
			- As your app grows more complex, you'll want to split your reducing function into separate functions, each managing independent parts of the state.
			- The combineReducers helper function turns an object whose values are different reducing functions into a single reducing function you can pass to createStore.
			- The resulting reducer calls every child reducer delegating them parts of the state tree, and gathers their results into a single state object. The state produced by combineReducers() namespaces the states of each reducer under their keys as passed to combineReducers()
			
			All combineReducers() does is generate a function that calls your reducers with the slices of state selected according to their keys, and combining their results into a single object again.
			
		compose(...functions)
			Composes functions from right to left.
			
		Store
			A store holds the whole state tree of your application.
			The only way to change the state inside it is to dispatch an action on it.

			A store is not a class. It's just an object with a few methods on it.
			To create it, pass your root reducing function to createStore.
			
			Methods:
				- getState(): Returns the current state tree of your application.
				- dispatch(action): Dispatches an action. This is the only way to trigger a state change. The store's reducing function will be called with the current getState() result and the given action synchronously. Its return value will be considered the next state.
				- subscribe(listener): Adds a change listener. It will be called any time an action is dispatched, and some part of the state tree may potentially have changed.
				- replaceReducer(nextReducer): Replaces the reducer currently used by the store to calculate the state. It is advanced API, you might need this if your app implements code splitting.
		
		createStore(reducer, [preloadedState], [enhancer]):
			Creates a Redux store that holds the complete state tree of your app.
			There should only be a single store in your app.
			
			reducer (Function): A reducing function that returns the next state tree, given the current state tree and an action to handle.

			[preloadedState] (any): The initial state. You may optionally specify it to hydrate the state from the server in universal apps, or to restore a previously serialized user session. If you produced reducer with combineReducers, this must be a plain object with the same shape as the keys passed to it. Otherwise, you are free to pass anything that your reducer can understand.

			[enhancer] (Function): The store enhancer. You may optionally specify it to enhance the store with third-party capabilities such as middleware, time travel, persistence, etc. The only store enhancer that ships with Redux is applyMiddleware().
	
		applyMiddleware
			Middleware is the suggested way to extend Redux with custom functionality. Middleware lets you wrap the store's dispatch method for fun and profit. The key feature of middleware is that it is composable. Multiple middleware can be combined together, where each middleware requires no knowledge of what comes before or after it in the chain.

			The most common use case for middleware is to support asynchronous actions without much boilerplate code or a dependency on a library like Rx. It does so by letting you dispatch async actions in addition to normal actions.
			
			So basically with middleware the dispatch method (that accepts action objects by default) can be extended via composition.
			
		bindActionCreators(actionCreators, dispatch)
			Turns an object whose values are action creators, into an object with the same keys, but with every action creator wrapped into a dispatch call so they may be invoked directly.
			Normally you should just call dispatch directly on your Store instance. If you use Redux with React, react-redux will provide you with the dispatch function so you can call it directly, too.
			The only use case for bindActionCreators is when you want to pass some action creators down to a component that isn't aware of Redux, and you don't want to pass dispatch or the Redux store to it.
			
	Data Flow:
		1. You call store.dispatch(action)
			An action is a plain object describing what happened.
			You can call store.dispatch(action) from anywhere in your app, including components and XHR callbacks, or even at scheduled intervals.
		2. The Redux store calls the reducer function you gave it - the root reducer by default, or enhanced one
			The store will pass two arguments to the reducer: the current state tree and the action.
			Note that a reducer is a pure function. It only computes the next state.
			It shouldn't perform any side effects like API calls or router transitions. These should happen before an action is dispatched.
		3. The root reducer may combine the output of multiple reducers into a single state tree.
		4. The Redux store saves the complete state tree returned by the root reducer.
			This new tree is now the next state of your app! Every listener registered with store.subscribe(listener) will now be invoked; listeners may call store.getState() to get the current state
			Now, the UI can be updated to reflect the new state. If you use bindings like React Redux, this is the point at which component.setState(newState) is called.


React Redux:

	React bindings for Redux embrace the idea of separating presentational and container components. 
	The current suggested best practice is to categorize your components as "presentational" or "container" components, and extract a connected container component wherever it makes sense:
	
	Presentational components:
		- Are concerned with how things look.
		- May contain both presentational and container components** inside, and usually have some DOM markup and styles of their own.
		- Have no dependencies on the rest of the app, such as Flux actions or stores.
		- Don’t specify how the data is loaded or mutated.
		- Receive data and callbacks exclusively via props.
		- Are written as functional components unless they need state, lifecycle hooks, or performance optimizations.
		- Examples: Page, Sidebar, Story, UserInfo, List.
		
	Container components:
		- Are concerned with how things work.
		- May contain both presentational and container components** inside but usually don’t have any DOM markup of their own except for some wrapping divs, and never have any styles.
		- Provide the data and behavior to presentational or other container components.
		- Call Flux actions and provide these as callbacks to the presentational components.
		- Are often stateful, as they tend to serve as data sources.
		- Are usually generated using higher order components such as connect() from React Redux, createContainer() from Relay, or Container.create() from Flux Utils, rather than written by hand.
		- Examples: UserPage, FollowersSidebar, StoryContainer, FollowedUserList.
		
	When to Introduce Containers?
		When you notice that some components don’t use the props they receive but merely forward them down and you have to rewire all those intermediate components any time the children need more data, it’s a good time to introduce some container components. 
		This way you can get the data and the behavior props to the leaf components without burdening the unrelated components in the middle of the tree.
		
	Components:
		- Stateful and Stateless. Some components use React setState() method and some don’t. While container components tend to be stateful and presentational components tend to be stateless, this is not a hard rule. Presentational components can be stateful, and containers can be stateless too.
		- Classes and Functions. Since React 0.14, components can be declared both as classes and as functions. Functional components are simpler to define but they lack certain features currently available only to class components. Some of these restrictions may go away in the future but they exist today. Because functional components are easier to understand, I suggest you to use them unless you need state, lifecycle hooks, or performance optimizations, which are only available to the class components at this time.
		- Pure and Impure. People say that a component is pure if it is guaranteed to return the same result given the same props and state. Pure components can be defined both as classes and functions, and can be both stateful and stateless. Another important aspect of pure components is that they don’t rely on deep mutations in props or state, so their rendering performance can be optimized by a shallow comparison in their shouldComponentUpdate() hook. Currently only classes can define shouldComponentUpdate() but that may change in the future.
		- Pure and logical: 
			- logical components tends to have state their own state management (React state) and may take place in React lifecycle
			- pure components solely rely only on props, stateless, pure functions, don't take place in React lifecycle
		
		
							Presentational Components				Container Components
	Purpose					How things look (markup, styles)		How things work (data fetching, state updates)
	Aware of Redux			No										Yes
	To read data			Read data from props					Subscribe to Redux state
	To change data			Invoke callbacks from props				Dispatch Redux actions
	Are written				By hand									Usually generated by React Redux
	
	Container components: use React Redux's "connect()" function
		Technically, a container component is just a React component that uses store.subscribe() to read a part of the Redux state tree and supply props to a presentational component it renders.
	
		You could write a container component by hand using store.subscribe(), but we suggest instead generating container components with the React Redux library's connect() function, which provides many useful optimizations to prevent unnecessary re-renders.
		
	Separation of container and presentational components are not required by redux but it is recommended because it decouples the rendering from redux so later it is easier to move to different frameworks other then redux
		while keeping the presentational components exactly the same.
		
		
	connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options]):
			- implements shouldComponentUpdate() for performance
			- if mapDispatchToProps is not provided, or it is any falsy value like "null", the "dispatch" function gets mapped to the connected component's props. It can directly be invoked then.
			- subscribes to store changes in the componentDidMount(), unsubscribes in componentWillUnmount(), and opts-in to context API to be able to access the store provided by <Provider>
				does not subscribe is mapStateToProps is a falsy value
			- mapStateToProps gets invoked anytime the redux state changes (if the 2nd parameter is specified then also gets invoked anytime the ownProps on the connected component changes)
			- mapDispatchToProps gets invoked only after the component gets mounted (or if the 2nd parameter is specified then also gets invoked anytime the ownProps on the connected component changes)
			- it calculates the props that need to get passed to the presentational component by merging the objects returned from mapStateToProps, mapDispatchToProps and its own props
			- passes all additional props to the enhanced Component, not just the ones mapped in mapStateToProps and mapDispatchToProps
				- so this works like a charm: withRouter(connect(null, null)(MyComponent)) --> MyComponent will receive the "history" and "match" objects as props
		
		mapStateToProps(state, [ownProps]): stateProps: that tells how to transform the current Redux store state into the props you want to pass to a presentational component you are wrapping
			- If your mapStateToProps function is declared as taking two parameters, it will be called with the store state as the first parameter and the props passed to the connected component as the second parameter, and will also be re-invoked whenever the connected component receives new props as determined by shallow equality comparisons
			- If mapStateToProps is null, it tells connect() there is no need to subscribe to the store
					- connect(null)
			
			mapStateToProps is a function that will be called when our component mounts, updates, or our store state is changed
				- Use componentWillReceiveProps if you want to handle the update in the props: for example to set the component's internal state object to make it possible to have some interaction with forms
				
					Example:
						- There's only one problem. Earlier, we set up our mapStateToProps function to contain a default, empty cat object, as well as default, empty catHobbies and checkBoxHobbies collections. These default objects would get passed to props, should the component render before our application's state gets populated with the cat and hobby collections from our API.
						- When the actions that retrieve that data from the API are finished being handled by the reducers, and the new versions of state are pushed out to the components, the mapStateToProps function runs again, and the component re-renders with new props.
						- But wait! The constructor function will only be invoked once, not again and again every time application state changes and mapStateToProps get re-invoked. So, how will we insure that our CatPage component's internal state, which gets its cat, catHobbies and checkBoxHobbies properties from the component's props, gets updated when those props change?
						- For this, we will use the component lifecycle method componentWillReceiveProps.
						- The componentWillReceiveProps function will be invoked every time a component's props are updated by a re-invocation of the mapStateToProps function. This is the perfect place to update the CatPage's state whenever props get updated.
		
		mapDispatchToProps(dispatch, [ownProps]): dispatchProps: In addition to reading the state, container components can dispatch actions.
			- If an object is passed, each function inside it is assumed to be a Redux action creator. An object with the same function names, but with every action creator wrapped into a dispatch call so they may be invoked directly, will be merged into the component’s props.
			- If a function is passed, it will be given dispatch as the first parameter. It’s up to you to return an object that somehow uses dispatch to bind action creators in your own way. (Tip: you may use the bindActionCreators() helper from Redux.)
			- If your mapDispatchToProps function is declared as taking two parameters, it will be called with dispatch as the first parameter and the props passed to the connected component as the second parameter, and will be re-invoked whenever the connected component receives new props
			- if connect() receives any falsy value as mapDispatchToProps (undefined, null, false, 0) then the dispatch itself gets passed to the presentational component
			
		mergeProps(stateProps, dispatchProps, ownProps): props
			If specified, it is passed the result of mapStateToProps(), mapDispatchToProps(), and the parent props. 
			The plain object you return from it will be passed as props to the wrapped component. 
			You may specify this function to select a slice of the state based on props, or to bind action creators to a particular variable from props. 
			If you omit it, Object.assign({}, ownProps, stateProps, dispatchProps) is used by default.
			
			
	Passing the Store		
		The option we recommend is to use a special React Redux component called <Provider> to magically make the store available to all container components in the application without passing it explicitly. You only need to use it once when you render the root component:
		
		ReactDOM.render(
		  <Provider store={store}>
			<App />
		  </Provider>,
		  document.getElementById('root')
		)
		
		<Provider> uses the Context API but it is best to use the mapStateToProps, mapDispatchToProps functions on connect().
		
		connect()(PresentationalComponent) - this is a special case:
			- connect does not subscribe to store changes, and dispatch itself is passed as a prop to PresentationalComponent
			- could have been also written as: connect(null), connect(null, null)
		
	Reselect:
		Reselect is a memoized selector function, composed of selectors, that returns something you want in your component’s props.
		Memoisation is an optimization technique and it means storing the results of expensive function calls and returning the cached result when the same inputs occur again.
		
		In Redux, whenever an action is called anywhere in the application, all mounted & connected components call their mapStateToProps function. 
		This means every single (state --> props) mapping would be recalculated.
		This is why Reselect is awesome. It will just return the memoized result if nothing has changed.
		
		1. Selectors can compute derived data, allowing Redux to store the minimal possible state.
		2. Selectors are efficient. A selector is not recomputed unless one of its arguments change.
		3. Selectors are composable. They can be used as input to other selectors.
		
		
		API
			createSelector(...inputSelectors | [inputSelectors], resultFunc)
				Takes one or more selectors, or an array of selectors, computes their values and passes them as arguments to resultFunc.
	
	
	Async actions:
	
		Usually, for any API request you'll want to dispatch at least 3 different kinds of actions:
			- An action informing the reducers that the request began.
			- An action informing the reducers that the request finished successfully.
			- An action informing the reducers that the request failed.
			
			{ type: 'FETCH_POSTS_REQUEST' }
			{ type: 'FETCH_POSTS_FAILURE', error: 'Oops' }
			{ type: 'FETCH_POSTS_SUCCESS', response: { ... } }
			
			Multiple types leave less room for a mistake, but this is not an issue if you generate action creators and reducers with a helper library like redux-actions.
		
		Redux Thunk: Thunk Middleware
		
			A thunk is a function that wraps an expression to delay its evaluation.
			A thunk is a function returned from other function.
			By using this specific middleware, an action creator can return a function instead of an action object. This way, the action creator becomes a thunk.
		
			Redux Thunk middleware allows you to write action creators that return a function instead of an action. 
			The thunk can be used to delay the dispatch of an action, or to dispatch only if a certain condition is met. 
			The inner function receives the store methods dispatch and getState as parameters.
			The thunk middleware does not use what we return from the thunk --> 
				- As a convention we can always return a promise that represents the corresponding async operation
				- The return value of the thunk becomes the return value of dispatching the thunk (mapDispatchToProps is needed to wrap the thunk action creator with dispatching to the store)
			
				let nextNotificationId = 0
				export function showNotificationWithTimeout(text) {
				  return function (dispatch, getState) {
					// Unlike in a regular action creator, we can exit early in a thunk
					// Redux doesn’t care about its return value (or lack of it)
					if (!getState().areNotificationsEnabled) {
					  return
					}

					const id = nextNotificationId++
					dispatch(showNotification(id, text))

					setTimeout(() => {
					  dispatch(hideNotification(id))
					}, 5000)
				  }
				}
				
			Finally, how do we use the synchronous action creators we defined earlier together with network requests? The standard way to do it with Redux is to use the Redux Thunk middleware.
			
		Thunk middleware isn't the only way to orchestrate asynchronous actions in Redux:

			- You can use redux-promise or redux-promise-middleware to dispatch Promises instead of functions.
			- You can use redux-observable to dispatch Observables.
			- You can use the redux-saga middleware to build more complex asynchronous actions.
			- You can use the redux-pack middleware to dispatch promise-based asynchronous actions.
			- You can even write a custom middleware to describe calls to your API, like the real world example does.
			
		
		Middleware in general: 
			Important: if invoking the original store.dispatch(action) function from any middleware instead of the next(action):
				- it re-executes the whole middleware pipeline on that action, including the current middleware
				- this is useful for async middlewares
		
			In Express, KOA, Asp.Net Core: middleware is some code you can put between the framework receiving a request, and the framework generating a response.
			In Redux it provides a third-party extension point between dispatching an action, and the moment it reaches the reducer.
			
			Naive apply middleware implementation:
				function applyMiddleware(store, middlewares) {
				  middlewares = middlewares.slice()
				  middlewares.reverse()
				  let dispatch = store.dispatch
				  middlewares.forEach(middleware =>
					dispatch = middleware(store)(dispatch)
				  )
				  return Object.assign({}, store, { dispatch })
				}
				
			The implementation of applyMiddleware() that ships with Redux is similar, but different in three important aspects:
				1. It only exposes a subset of the store API to the middleware: dispatch(action) and getState().
				2. It does a bit of trickery to make sure that if you call store.dispatch(action) from your middleware instead of next(action):
					The action will actually travel the whole middleware chain again, including the current middleware. 
					This is useful for asynchronous middleware, as we have seen previously. There is one caveat when calling dispatch during setup, described below.
				3. To ensure that you may only apply middleware once, it operates on createStore() rather than on store itself. Instead of (store, middlewares) => store, its signature is (...middlewares) => (createStore) => createStore.
				
			Stopping the Chain
				Sometimes an action doesn't need to reach the store's reducer because it doesn't update the store based on that action's type. 
				In those cases, the middleware function does not need to call the nextDispatch for that action. 
				
				function middleware(store) {
				  unsubscribeHistory = history.listen(location => {
					// a listener is attached to the history. When the
					// history changes locations, an UPDATE_LOCATION
					// action is dispatched to the store
					store.dispatch(updateLocation(location))
				  })

				  return next => action => {
					// the middleware only listens for TRANSITION actions
					// and the next middlewares do not care about this action, not even the reducers (in fact, they do not know about this action because it is React Router v4 specific) --> do not pass TRANSITION actions down the chain
					if (action.type !== TRANSITION) {
					  // pass it down the action to the chain to make possible for it to reach the root reducer
					  return next(action)
					}
					// when there is a TRANSITION action the middleware
					// calls a history function to update the location
					history[action.payload.method](action.payload.arg)
					// the middleware doesn't bother passing the TRANSITION
					// action down the middleware chain, since no reducer
					// will update the state of the store based on it
				  }
				}
				
			
			Good explanation about the signature: You may have noticed that middleware functions look a bit confusing. It's a function, that returns a function, that returns a function.
				const logger = store => dispatch => action => {
				  return dispatch(action)
				}
				
				Forget about its strange look. Think of it as a single function.
					function logger (store, dispatch, action) {  
					
				Having them as functions-that-return-functions makes for something interesting: it breaks the middleware into 3 steps that are applied separately.
					const logger = function (store) {
					  // This function runs on createStore().
					  // It returns a decorator for dispatch().
					  // You can get store.getState() here.
					  return function (dispatch) {
						// This function runs on createStore() too.
						// This returns a new dispatch() function to
						// replace the old one.
						return function (action) {
						  // This runs every dispatch().
						}
					  }
					}
					Most middleware will not need this, but the Redux docs has examples when this can be useful.
					
				- Middleware are Redux plugins you can attach to your store.
					createStore(reducer, {}, applyMiddleware(logger, thunk))
					
				- They give dispatch() more powers. (enhance it via higher order functions)
					store.dispatch({ type: 'SAVE' })     	Normal
					store.dispatch(fetch('/data.json'))	  	Promises
					store.dispatch(() => {  })     F		unctions/thunks
					store.dispatch()               			...and more
					
				- You can use middleware to write side effects to actions.
					const middleware = store => dispatch => action => {
					  if (action.type === 'FETCH') {
						doSomethingDifferent()
					  }
					  dispatch(action)
					}
					
				
	Redux Observable
	
		Epic: a function that takes a stream of all actions dispatched and returns a stream of new actions to dispatch.
			"actions in, actions out" - other actions out
			
			When defining the epics I'm just setting up the pipeline, the setup is executed exactly once during the application boot.
			Whenever an action gets dispatched, AFTER it went through the reducers it will reach my epic pipeline. 
			If the epic maps it to another action, then it will be dispatched again to the store, calling my reducers then my epics again.
			So the newly dispatched action 1st reaches the reducers and after that my epics. To escape this the epic pipeline just do not match it (ofType is not true, does not match to any action.type).
			
		Workflow:
			1. calling store.dispatch(action)
			2. reducers receive the action		--> so the pipeline goes to the "handler", the last and original dispatch function gets invoked
			3. epics receive the action			--> only when "going back" in the pipeline (state has been updated by the reducers) receives the epic the action
				3.a) if the epic does not map it to another action then we are finished
				3.b) if the epic maps it to another action then the new action (action out) gets dispatched my the epicMiddleware under the hood via store.dispatch(action) --> and we go to 2.
					--> reducers receive the new action and after handling it (synchronously ofc) the epic gets invoked again
					
		action$.ofType(FETCH_USER)
			.mergeMap(action =>
			  ajax.getJSON(`/api/users/${action.payload}`)				using an inner observable: so if the ajax request fails it does not bring the whole epic pipeline down if catching the error
				.map(response => fetchUserFulfilled(response))
				.takeUntil(action$.ofType(FETCH_USER_CANCELLED))
				.catch(err => Observable.of(defaultUser))				catch the possible error, do not let them propagate to the outer observable resulting in briging the epic pipeline down
			);
				

ES6:
	computed property name: 
		this.setState({
		  [name]: value
		});
		It is equivalent to this ES5 code:
		var partialState = {};
		partialState[name] = value;
		this.setState(partialState);
		
		
	Data change with mutation
		var player = {score: 1, name: 'Jeff'};
		player.score = 2;
		// Now player is {score: 2, name: 'Jeff'}
		
	Data change without mutation
		var player = {score: 1, name: 'Jeff'};

		var newPlayer = Object.assign({}, player, {score: 2});
		// Now player is unchanged, but newPlayer is {score: 2, name: 'Jeff'}

		// Or if you are using object spread syntax proposal, you can write:
		var newPlayer = {...player, {score: 2}};
		
		
	Currying: these 2 are equivalent:
		function logger(store) {
		  return function wrapDispatchToAddLogging(next) {
			return function dispatchAndLog(action) {
			  console.log('dispatching', action)
			  let result = next(action)
			  console.log('next state', store.getState())
			  return result
			}
		  }
		}
		
		const logger = store => next => action => {
		  console.log('dispatching', action)
		  let result = next(action)
		  console.log('next state', store.getState())
		  return result
		}
		
		
TypeScript:
	import { ComponentClass, ReactChild } from "react";
		ComponentClass: 	e.g.: Component		- so this is a class and the callee instantiates it (props gets specified by the callee) - used in HOC patterns
		ReactChild: 		e.g.: <Component /> - so this is a component instance (props specified by the caller)
		
		export interface Button {
		  component: ComponentClass;
		  content: string | ReactChild;
		  key: string | number;
		  options?: object;
		}
		
		import classnames from "classnames";
		
		const button: Button =  {
			component: Button,
			content: (
			  <Icon icon="notification" size={<Medium />} className={classnames("Button", className, { "Button--primary": primary })} {...rest}>
				<span>Peter</span>
				{' '}
				<img src={...} />
			  </Icon>
			),
			key: "notifications",
			options: {
			  className: "Button--no_padding",
			  onClick: () => ({})
			}
		}



Goode examples:

	1.
		<div className="Header__right Layout__cell Layout__cell--tight Layout__cell--align-middle">
			{buttons.map(button => (
			  <button.component key={button.key} {...button.options}>
				{button.content}
			  </button.component>
			))}
		</div>
		vs
		<div className="Header__right Layout__cell Layout__cell--tight Layout__cell--align-middle">
            {buttons.map((button: ButtonInterface) => (
              React.createElement(button.component, { key: button.key, ...button.options }, button.content);
            ))}
        </div>

	2.
		export default class Button extends React.PureComponent<Props> {
		  render() {
			const { className, children, primary, ...rest } = this.props;
			return (
			  <button className={classnames("Button", className, { "Button--primary": primary })} {...rest}>		// notice how we pass all other parameters down to the react button representing a DOM button
				{children}
			  </button>
			);
		  }
		}
		
		usage:
		<Button key={index} {...button.options} className={"Button--primary"} onClick={this.handleClick}>
			{button.children}
		</Button>
		
	Epics:
		export const updateLoggingLevelAsync = createEpic<SecurityEpic>(actions$ =>
		  actions$
			.ofType(ActionTypes.UpdateLoggingLevel)
			.switchMap(action => SecurityApi.updateLoggingLevel(action.payload.loggingLevel))
			.map(() => setUpdateLoggingLevelOpState(OperationState.Default))
		);
		
		
		
		type AccountEpic = Epic<Action, AppState, any, ReduxAction>;

		export const whoAmIAsync = createEpic<AccountEpic>(actions$ =>
		  actions$.ofType(ActionTypes.WhoAmI).switchMap(() =>
			Observable.concat(
			  Observable.of(setCurrentUser(loading())),
			  AccountApi.whoAmI()
				.mergeMap(response => [
				  setServerConfig(response.serverConfig),
				  setCurrentUser(loaded(accountInfoToUser(response.accountInfo)))
				])
				.catch(() => Observable.of(setCurrentUser(error())))
			)
		  )
		);

		export const loginAsync = createEpic<AccountEpic>(actions$ =>
		  actions$.ofType(ActionTypes.Login).switchMap(action => {
			const { userName, password, mode } = action.payload;
			return Observable.concat(
			  Observable.of(setLoginResult(loading())),
			  AccountApi.login({
				userName,
				password,
				loginMode: mode
			  })
				.map(info => setCurrentUser(loaded(accountInfoToUser(info))))
				.catch((err: AjaxError) =>
				  Observable.of(setLoginResult(error({ errorCode: err.response.errorCodeCode })))
				)
			);
		  })
		);

		export const logoutAsync = createEpic<AccountEpic>(actions$ =>
		  actions$.ofType(ActionTypes.Logout).switchMap(() =>
			AccountApi.logout()
			  .map(() => setCurrentUser(loaded({ isLoggedIn: false })))
			  .catch(() => Observable.of(setCurrentUser(error())))
		  )
		);

		export const setCurrentUserAsync = createEpic<AccountEpic>(actions$ =>
		  actions$.ofType(ActionTypes.SetCurrentUser).map(() => setLoginResult(loaded({})))
		);

		export const loadBroadcastMessagesAsync = createEpic<AccountEpic>(actions$ =>
		  actions$.ofType(ActionTypes.LoadActiveBroadcastMessages).switchMap(() => {
			return BroadcastApi.listActiveBroadcastMessages()
			  .map(messages => setBroadcastMessages(loaded(messages.map(BroadcastMessage.fromServer))))
			  .catch((err: AjaxError) =>
				Observable.of(setBroadcastMessages(error({ errorCode: err.response.errorCodeCode })))
			  );
		  })
		);
		
	Lifecycle hooks:

		componentWillReceiveProps vs componentWillUpdate:

			componentWillReceiveProps is called before componentWillUpdate in React's update lifecycle. You are right that componentWillReceiveProps allows you to call setState. On the other hand componentWillUpdate is a callback to use when you need to respond to a state change.
			
			So the default workflow for the parent-child component relationship would be the following:
				- Parent passes new props to the child
				- Child handles new props in 'componentWillReceiveProps', calls setState if necessary
				- Child handles new state in 'componentWillUpdate' - but if your component is stateful, handling props in 'componentWillReceiveProps' will be enough.
			
			
		componentDidUpdate:
			componentDidUpdate(prevProps) {
				// only initiate webservice request if the filter in the props has changed!
				if(this.props.filter !== prevProps.filter) {
					fetchTodos(this.props.filter).then(todos => this.setState({todos}));
				}
			}
			
	Redux:
		useful npm packages:
			- redux-observable: to dispatch Observables
			- redux-promise: adds support for dispatching functions that return promises
			- redux-thunk: adds a middleware to support dispatching thunks (functions returned from other functions)
			- redux-logger: logging middleware
			- normalizr: normalize deeply nested api objects and returning nested entities with their IDs, gathered in dictionaries