React

	v16 new features:
		- render() can return an array of components or <> (fragment) to cover multiple components
			- fragments do not need "key" prop to be specified
		- Error boundaries: use the componentDidCatch method to make a component an error boundary
			-  Error boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed.
		- ReactDOM.createPortal()
		- setState:
			- Calling setState with null no longer triggers an update. This allows you to decide in an updater function if you want to re-render.
			- Calling setState directly in render always causes an update. This was not previously the case. Regardless, you should not be calling setState from render.
			- setState callbacks (second argument) now fire immediately after componentDidMount / componentDidUpdate instead of after all components have rendered.
		- Support for custom DOM attributes: 
			- Instead of ignoring unrecognized HTML and SVG attributes, React will now pass them through to the DOM. This has the added benefit of allowing us to get rid of most of React’s attribute whitelist, resulting in reduced file sizes.
		- When replacing <A /> with <B />, B.componentWillMount now always happens before A.componentWillUnmount. Previously, A.componentWillUnmount could fire first in some cases.
		
	v16.3 new features: https://reactjs.org/blog/2018/03/29/react-v-16-3.html
		- deprecating lifecycle hooks: componentWillMount, componentWillReceiveProps, componentWillUpdate
		- 2 new lifecycle methods: static getDerivedStateFromProps(), and getSnapshotBeforeUpdate()
			- the recommended way to update state in response to props changes is with the new static getDerivedStateFromProps lifecycle
			- return null from it to indicate no change to state
		- official Context API
		- createRef API
		- forwardRef API
			- Ref forwarding is a new opt-in feature that lets some components take a ref they receive, and pass it further down (in other words, "forward" it) to a child. 
		- StrictMode Component
			StrictMode is a tool for highlighting potential problems in an application. Like Fragment, StrictMode does not render any visible UI. It activates additional checks and warnings for its descendants.
			StrictMode checks are run in development mode only; they do not impact the production build.
			
	v16.4.1 - You Probably Don't Need Derived State:
		Common bugs when using derived state:
			- Anti-pattern: Unconditionally copying props to state
			- Anti-pattern: Erasing state when props change -  updating state whenever props and state don’t match
		Preferred solutions:
			- Fully controlled component
			- Fully uncontrolled component with a key
				- Recomendation: To reset all internal state, use the key attribute.
				- Alternative 1: To reset only certain state fields, watch for changes in a special property (e.g. props.userID).
				- Alternative 2: You can also consider fall back to an imperative instance method using refs.
			
		getDerivedStateFromProps exists for only one purpose: it enables a component to update its internal state as the result of changes in props. 
		
		The terms “controlled” and “uncontrolled” usually refer to form inputs, but they can also describe where any component’s data lives. 
			- Data passed in as props can be thought of as controlled (because the parent component controls that data). 
			- Data that exists only in internal state can be thought of as uncontrolled (because the parent can’t directly change it).
		The most common mistake with derived state is mixing these two; when a derived state value is also updated by setState calls, there isn’t a single source of truth for the data.
		
		- Anti-pattern: Unconditionally copying props to state:
			A common misconception is that getDerivedStateFromProps and componentWillReceiveProps are only called when props “change”. 
			These lifecycles are called any time a parent component rerenders, regardless of whether the props are “different” from before. 
			Because of this, it has always been unsafe to unconditionally override state using either of these lifecycles. Doing so will cause state updates to be lost.
					class EmailInput extends Component {
					  state = { email: this.props.email };

					  render() {
						return <input onChange={this.handleChange} value={this.state.email} />;
					  }

					  handleChange = event => {
						this.setState({ email: event.target.value });
					  };

					  componentWillReceiveProps(nextProps) {
						// This will erase any local state updates!
						// Do not do this.
						this.setState({ email: nextProps.email });
					  }
					}
					
		- Anti-pattern: Erasing state when props change:
				class EmailInput extends Component {
				  state = {
					email: this.props.email
				  };

				  componentWillReceiveProps(nextProps) {
					// Any time props.email changes, update state.
					if (nextProps.email !== this.props.email) {
					  this.setState({
						email: nextProps.email
					  });
					}
				  }
				  
				  // ...
				}
			There is still a subtle problem. Imagine a password manager app using the above input component. When navigating between details for two accounts with the same email, the input would fail to reset. This is because the prop value passed to the component would be the same for both accounts! This would be a surprise to the user, as an unsaved change to one account would appear to affect other accounts that happened to share the same email. 
			
		
		Fortunately there are two alternatives that work better. The key to both is that for any piece of data, you need to pick a single component that owns it as the source of truth, and avoid duplicating it in other components.
		
		Preferred Solutions:
			- Recommendation: Fully controlled component
				One way to avoid the problems mentioned above is to remove state from our component entirely. 
				If the email address only exists as a prop, then we don’t have to worry about conflicts with state. 
				We could even convert EmailInput to a lighter-weight functional component:
					function EmailInput(props) {
					  return <input onChange={props.onChange} value={props.email} />;
					}
			- Recommendation: Fully uncontrolled component with a key
				Another alternative would be for our component to fully own the "draft" email state. 
				In that case, our component could still accept a prop for the initial value, but it would ignore subsequent changes to that prop:
					class EmailInput extends Component {
					  state = { email: this.props.defaultEmail };

					  handleChange = event => {
						this.setState({ email: event.target.value });
					  };

					  render() {
						return <input onChange={this.handleChange} value={this.state.email} />;
					  }
					}
					
				In order to reset the value when moving to a different item (as in our password manager scenario), we can use the special React attribute called "key". 
				When a key changes, React will create a new component instance rather than update the current one. 
				Keys are usually used for dynamic lists but are also useful here. In our case, we could use the user ID to recreate the email input any time a new user is selected:
					<EmailInput
					  defaultEmail={this.props.user.email}
					  key={this.props.user.id}
					/>
				Each time the ID changes, the EmailInput will be recreated and its state will be reset to the latest defaultEmail value. 
				In most cases, this is the best way to handle state that needs to be reset.
				
			
				- Alternative 1: Reset uncontrolled component with an ID prop:
					If key doesn’t work for some reason (perhaps the component is very expensive to initialize), a workable but cumbersome solution would be to watch for changes to "userID" in getDerivedStateFromProps:
					class EmailInput extends Component {
					  state = {
						email: this.props.defaultEmail,
						prevPropsUserID: this.props.userID
					  };

					  static getDerivedStateFromProps(props, state) {
						// Any time the current user changes,
						// Reset any parts of state that are tied to that user.
						// In this simple example, that's just the email.
						if (props.userID !== state.prevPropsUserID) {
						  return {
							prevPropsUserID: props.userID,
							email: props.defaultEmail
						  };
						}
						return null;
					  }

					  // ...
					}
					
				- Alternative 2: Reset uncontrolled component with an instance method:
					class EmailInput extends Component {
					  state = {
						email: this.props.defaultEmail
					  };

					  resetEmailForNewUser(newEmail) {
						this.setState({ email: newEmail });
					  }

					  // ...
					}
					The parent form component could then use a ref to call this method.
					Refs can be useful in certain cases like this one, but generally we recommend you use them sparingly, because imperative methods are unideals and two renders will occur instead of one.
					
			Recap: 
				To recap, when designing a component, it is important to decide whether its data will be controlled or uncontrolled. 
				- Instead of trying to "mirror" a prop value in state, make the component controlled, and consolidate the two diverging values in the state of some parent component.
				- For uncontrolled components, if you’re trying to reset state when a particular prop (usually an ID) changes, you have a few options:
					- Recomendation: To reset all internal state, use the key attribute.
					- Alternative 1: To reset only certain state fields, watch for changes in a special property (e.g. props.userID).
					- Alternative 2: You can also consider fall back to an imperative instance method using refs.
					
		What about memoization?
			Using derived state for memoization isn’t necessarily bad, but it’s usually not the best solution. 
				class Example extends Component {
				  state = {
					filterText: "",
				  };

				  // *******************************************************
				  // NOTE: this example is NOT the recommended approach.
				  // See the examples below for our recommendations instead.
				  // *******************************************************

				  static getDerivedStateFromProps(props, state) {
					// Re-run the filter whenever the list array or filter text change.
					// Note we need to store prevPropsList and prevFilterText to detect changes.
					if (
					  props.list !== state.prevPropsList ||
					  state.prevFilterText !== state.filterText
					) {
					  return {
						prevPropsList: props.list,
						prevFilterText: state.filterText,
						filteredList: props.list.filter(item => item.text.includes(state.filterText))
					  };
					}
					return null;
				  }

				  handleChange = event => {
					this.setState({ filterText: event.target.value });
				  };

				  render() {
					return (
					  <Fragment>
						<input onChange={this.handleChange} value={this.state.filterText} />
						<ul>{this.state.filteredList.map(item => <li key={item.id}>{item.text}</li>)}</ul>
					  </Fragment>
					);
				  }
				}
				
			This implementation avoids recalculating filteredList more often than necessary. But it is more complicated than it needs to be, because it has to separately track and detect changes in both props and state in order to properly update the filtered list. In this example, we could simplify things by using PureComponent and moving the filter operation into the render method:
				// PureComponents only rerender if at least one state or prop value changes.
				// Change is determined by doing a shallow comparison of state and prop keys.
				class Example extends PureComponent {
				  // State only needs to hold the current filter text value:
				  state = {
					filterText: ""
				  };

				  handleChange = event => {
					this.setState({ filterText: event.target.value });
				  };

				  render() {
					// The render method on this PureComponent is called only if
					// props.list or state.filterText has changed.
					const filteredList = this.props.list.filter(
					  item => item.text.includes(this.state.filterText)
					)

					return (
					  <Fragment>
						<input onChange={this.handleChange} value={this.state.filterText} />
						<ul>{filteredList.map(item => <li key={item.id}>{item.text}</li>)}</ul>
					  </Fragment>
					);
				  }
				}
				
				The above approach is much cleaner and simpler than the derived state version. Occasionally, this won’t be good enough—filtering may be slow for large lists, and PureComponent won’t prevent rerenders if another prop were to change. To address both of these concerns, we could add a memoization helper to avoid unnecessarily re-filtering our list:
				
			Memoization:
				import memoize from "memoize-one";
				class Example extends Component {
				  // State only needs to hold the current filter text value:
				  state = { filterText: "" };

				  // Re-run the filter whenever the list array or filter text changes:
				  filter = memoize(
					(list, filterText) => list.filter(item => item.text.includes(filterText))
				  );

				  handleChange = event => {
					this.setState({ filterText: event.target.value });
				  };

				  render() {
					// Calculate the latest filtered list. If these arguments haven't changed
					// since the last render, `memoize-one` will reuse the last return value.
					const filteredList = this.filter(this.props.list, this.state.filterText);

					return (
					  <Fragment>
						<input onChange={this.handleChange} value={this.state.filterText} />
						<ul>{filteredList.map(item => <li key={item.id}>{item.text}</li>)}</ul>
					  </Fragment>
					);
				  }
				}
				This is much simpler and performs just as well as the derived state version!
				When using memoization, remember a couple of constraints:
					1. In most cases, you’ll want to attach the memoized function to a component instance. This prevents multiple instances of a component from resetting each other’s memoized keys.
					2. Typically you’ll want to use a memoization helper with a limited cache size in order to prevent memory leaks over time. (In the example above, we used memoize-one because it only caches the most recent argument and result.)
					3. None of the implementations shown in this section will work if props.list is recreated each time the parent component renders. But in most cases, this setup is appropriate.
			
		
	Best practices:
		- Initializing state: 
			instead of componentWillMount, the simplest refactor for this type of component is to move state initialization to the constructor or to a property initializer.
		- Fetching external data: 
			instead of componentWillMount, the recommended upgrade path for most use cases is to move data-fetching into componentDidMount.
		- Adding event listeners (or subscriptions):
			For memory leaking reasons on SSE For, the recommended way to add listeners/subscriptions is to use the componentDidMount lifecycle.
			People often assume that componentWillMount and componentWillUnmount are always paired, but that is not guaranteed. Only once componentDidMount has been called does React guarantee that componentWillUnmount will later be called for clean up.
		- Updating state based on props:
			instead of componentWillReceiveProps (there is nothing wrong doing the state update in this method, only thing it that it will be deprecated), as of version 16.3, the recommended way to update state in response to props changes is with the new static getDerivedStateFromProps lifecycle. (That lifecycle is called when a component is created and each time it receives new props).
		- Invoking external callbacks:
			- Sometimes people use componentWillUpdate out of a misplaced fear that by the time componentDidUpdate fires, it is "too late" to update the state of other components. 
				This is not the case. React ensures that any setState calls that happen during componentDidMount and componentDidUpdate are flushed before the user sees the updated UI (this triggers an extra render() though). 
				In general, it is better to avoid cascading updates like this, but in some cases they are necessary (for example, if you need to position a tooltip after measuring the rendered DOM element)
			- it is unsafe to use componentWillUpdate for this purpose in async mode, because the external callback might get called multiple times for a single update. Instead, the componentDidUpdate lifecycle should be used since it is guaranteed to be invoked only once per update.
		- Side effects on props change
			- Like componentWillUpdate, componentWillReceiveProps might get called multiple times for a single update. For this reason it is important to avoid putting side effects in this method. Instead, componentDidUpdate should be used since it is guaranteed to be invoked only once per update.
		- Fetching external data when props change
			- Instead of using componentWillReceiveProps, the recommended upgrade path for this component is to move data updates into componentDidUpdate. 
				Not to mention that componentWillReceiveProps may be invoked multiple times during a single update.
				You can also use the new getDerivedStateFromProps lifecycle to clear stale data before rendering the new props.
		- Reading DOM properties before an update:
			- In the above example, componentWillUpdate is used to read the DOM property. However with async rendering, there may be delays between “render” phase lifecycles (like componentWillUpdate and render) and “commit” phase lifecycles (like componentDidUpdate). If the user does something like resize the window during this time, the scrollHeight value read from componentWillUpdate will be stale.
			- The solution to this problem is to use the new "commit" phase lifecycle, getSnapshotBeforeUpdate. This method gets called immediately before mutations are made (e.g. before the DOM is updated). It can return a value for React to pass as a parameter to componentDidUpdate, which gets called immediately after mutations.
		- Flux dispatches typically belong inside the originating event handler (Flux dispatch is a side effect)
		- Manual DOM mutations belong inside componentDidMount or componentDidUpdate
			

	Components:
		- Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called “props”) and return React elements describing what should appear on the screen.
			function Welcome(props) {
			  return <h1>Hello, {props.name}</h1>;
			}
			
		- Remember that components may accept arbitrary props, including primitive values, React elements, or functions.
		
		- If you want to reuse non-UI functionality between components, we suggest extracting it into a separate JavaScript module. The components may import it and use that function, object, or a class, without extending it.
		
		- For building a static prototype, don’t use state at all to build this static version. State is reserved only for interactivity, that is, data that changes over time. 
		
		- Render function can return string, React element or a list of these things:
			- either a single React element or string
			- or an array of React elements or strings
				render() {
					return [
						<div key={1} />,
						(
							<div key={2}>
								Hallo!
						</ div>)
					];
				}
				
		- Default Prop Values: defaultProps property:
			You can define default values for your props by assigning to the special "defaultProps" property:
				class Greeting extends React.Component {
				  render() {
					return (
					  <h1>Hello, {this.props.name}</h1>
					);
				  }
				}

				// Specifies the default values for props:
				Greeting.defaultProps = {
				  name: 'Stranger'
				};

				// Renders "Hello, Stranger":
				ReactDOM.render(
				  <Greeting />,
				  document.getElementById('example')
				);
		
	Functional components: 
		- a function with "props" parameter and a render method. 
		- State is unique to class components. 
		- 2nd parameter is the context if specified (context is an anti-pattern, use a state-management library like redux instead). 
			- Moreover context is an opt-in feature, meaning Component.contextTypes must be specified otherwise it won't get passed as an argument.
			- So it is important to declare them anytime you use the context.
		
		You’ll need to change this.props to props both times it appears. Many components in your apps will be able to be written as functional components: these components tend to be easier to write and React will optimize them more in the future.
		
		function Square(props, [context]) {
		  return (
			<button className="square" onClick={props.onClick}>
			  {props.value}
			</button>
		  );
		}
		
	Props vs state:
		1. Is it passed in from a parent via props? If so, it probably isn’t state.
		2. Does it remain unchanged over time? If so, it probably isn’t state.
		3. Can you compute it based on any other state or props in your component? If so, it isn’t state.
		
	State's place:
		- Identify every component that renders something based on that state.
		- Find a common owner component (a single component above all the components that need the state in the hierarchy).
		- Either the common owner or another component higher up in the hierarchy should own the state.
		- If you can’t find a component where it makes sense to own the state, create a new component simply for holding the state and add it somewhere in the hierarchy above the common owner component.
			
			
	Event handling:
		1. <button onClick={(e) => this.handleClick(e)}>
			Click me
		  </button>
			The problem with this syntax is that a different callback is created each time the LoggingButton renders. In most cases, this is fine. However, if this callback is passed as a prop to lower components, those components might do an extra re-rendering. 
			
		2. <button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>
		
		3.	<button onClick={this.handleClick}>
				Click me
			</button>
			  
			and in ctor: 
				// This binding is necessary to make `this` work in the callback
				this.handleClick = this.handleClick.bind(this);
				
		Passing parameters:
			<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>
			<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>
			
		It is, however, conventional in React apps to use on* names for the attributes and handle* for the handler methods.
			 <Square value={this.state.squares[i]} onClick={() => this.handleClick(i)}/>



	Props:
		- input parameters, readonly
		
		- to pass all props without having to explicitly type each parameter we can use the spread operator:
			 <Greeting {...props} /> = <Greeting firstName="Ben" lastName="Hector" />

	State:
		- State is similar to props, but it is private and fully controlled by the component.
		- We mentioned before that components defined as classes have some additional features. Local state is exactly that: a feature available only to classes.
		- While this.props is set up by React itself and this.state has a special meaning, you are free to add additional fields to the class manually if you need to store something that is not used for the visual output.
		- If you don’t use something in render(), it shouldn’t be in the state.
		
		- In React apps, whether a component is stateful or stateless is considered an implementation detail of the component that may change over time. You can use stateless components inside stateful components, and vice versa.
		- this.setState({value: event.target.value}); - MERGES the state - not overrides the state the passed object, but merges it with it.
		- Also, since setState() automatically merges a partial state into the current state, we only needed to call it with the changed parts
		
		- State is reserved only for interactivity, that is, data that changes over time
		- If the state changes and we invoke setState React will re-render the entire component 
			- Only in the virtual DOM, then compares it with the real DOM - if the two do not match, only then updates the DOM and only the relevant parts that really changed (does not re-render the whole component into the DOM)
			- State changes are asynchronous. If you read from this.state immediately after calling this.setState, it probably won’t reflect the changes yet.
				- If the current value of the state is needed for calculating the next state, specify a function as the parameter: this.setState((prevState, props) => ({...}), () => {/* state update has just happened*/});

	Prevent component from rendering:
		- return null from the "render" function
		- Returning null from a component’s render method does not affect the firing of the component’s lifecycle methods. For instance, componentWillUpdate and componentDidUpdate will still be called.
		
		
	Thinking in React
		The original list of products is passed in as props, so that’s not state. The search text and the checkbox seem to be state since they change over time and can’t be computed from anything. And finally, the filtered list of products isn’t state because it can be computed by combining the original list of products with the search text and value of the checkbox.
		
	Lifecycle events: works only on class components (not on functional components)
	
		Mounting: these methods are called when an instance of a component is being created and inserted into the DOM:
			constructor()
			static getDerivedStateFromProps()
			componentWillMount() / UNSAFE_componentWillMount()
			render()
			componentDidMount()
			
		Updating: an update can be caused by changes to props or state. These methods are called when a component is being re-rendered:
			componentWillReceiveProps() / UNSAFE_componentWillReceiveProps()
			static getDerivedStateFromProps()
			shouldComponentUpdate()
			componentWillUpdate() / UNSAFE_componentWillUpdate()
			render()
			getSnapshotBeforeUpdate()
			componentDidUpdate()
			
		Unmounting: this method is called when a component is being removed from the DOM:
			componentWillUnmount()
			
		Error Handling: this method is called when there is an error during rendering, in a lifecycle method, or in the constructor of any child component.
			componentDidCatch()
			
		
		Lifecycle methods in more details:
			render(): can render:
				- React elements. Typically created via JSX. An element can either be a representation of a native DOM component (<div />), or a user-defined composite component (<MyComponent />).
					- React components are what composes the entire virtual DOM. For example: <h1>Hello!</h1> - this is a virtual DOM element
					- ReactDOM.render(<App />, document.getElementById('container')) - renders the <App /> virtual dom element into the real dom element
				- String and numbers. These are rendered as text nodes in the DOM.
				- Portals. Created with ReactDOM.createPortal.
				- null. Renders nothing.
				- Booleans. Render nothing. (Mostly exists to support return test && <Child /> pattern, where test is boolean.)
				
			constructor(props)
				- The constructor for a React component is called before it is mounted.
				- Avoid introducing any side-effects or subscriptions in the constructor. For those use cases, use componentDidMount() instead.
				- The constructor is the right place to initialize state. To do so, just assign an object to this.state; don’t try to call setState() from the constructor. The constructor is also often used to bind event handlers to the class instance.
				
			componentWillMount()
				- componentWillMount() is invoked immediately before mounting occurs. It is called before render(), therefore calling setState() synchronously in this method will not trigger an extra rendering.
				- Generally, we recommend using the constructor() instead.
				- Avoid introducing any side-effects or subscriptions in this method. For those use cases, use componentDidMount() instead.
				
			componentDidMount()
				- it is like ngOnInit()
				- hook runs after the component output has been rendered to the DOM
				- componentDidMount() is invoked immediately after a component is mounted. 
				- Initialization that requires DOM nodes should go here. If you need to load data from a remote endpoint, this is a good place to instantiate the network request.
				- This method is a good place to set up any subscriptions. If you do that, don’t forget to unsubscribe in componentWillUnmount().
				- Calling setState() in this method will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the render() will be called twice in this case, the user won’t see the intermediate state. Use this pattern with caution because it often causes performance issues. It can, however, be necessary for cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.
				
			componentWillReceiveProps(nextProps)
				- componentWillReceiveProps() is invoked before a mounted component receives new props.
				- If you need to update the state in response to prop changes (for example, to reset it), you may compare this.props and nextProps and perform state transitions using this.setState() in this method.
				- Note that React may call this method even if the props have not changed, so make sure to compare the current and next values if you only want to handle changes. This may occur when the parent component causes your component to re-render.
				
			shouldComponentUpdate(nextProps, nextState)
				- Use shouldComponentUpdate() to let React know if a component’s output is not affected by the current change in state or props. 
				- The default behavior is to re-render on every state change, and in the vast majority of cases you should rely on the default behavior. - the function returns "true" by default
				- This method is not called for the initial render or when forceUpdate() is used.
				- Returning false does not prevent child components from re-rendering when their state changes.
				- Currently, if shouldComponentUpdate() returns false, then componentWillUpdate(), render(), and componentDidUpdate() will not be invoked
				
			componentWillUpdate(nextProps, nextState)
				- componentWillUpdate() is invoked immediately before rendering when new props or state are being received. Use this as an opportunity to perform preparation before an update occurs. This method is not called for the initial render.
				- Note that you cannot call this.setState() here; nor should you do anything else (e.g. dispatch a Redux action) that would trigger an update to a React component before componentWillUpdate() returns.
				- If you need to update state in response to props changes, use componentWillReceiveProps() instead.
				- In async rendering mode this hook may get called multiple times (by the time when this comes the hook will be called UNSAFE_componentWillUpdate()
				
			componentDidUpdate(prevProps, prevState)
				- componentDidUpdate() is invoked immediately after updating occurs. This method is not called for the initial render.
				- Use this as an opportunity to operate on the DOM when the component has been updated. 
				- This is also a good place to do network requests as long as you compare the current props to previous props (e.g. a network request may not be necessary if the props have not changed).
			
			componentWillUnmount()
				- it is like ngOnDestroy()
				- componentWillUnmount() is invoked immediately before a component is unmounted and destroyed. 
				- Perform any necessary cleanup in this method, such as invalidating timers, canceling network requests, or cleaning up any subscriptions that were created in componentDidMount().
				
			componentDidCatch(error, info)
				- Error boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed. 
				- Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them.
				- A class component becomes an error boundary if it defines this lifecycle method. Calling setState() in it lets you capture an unhandled JavaScript error in the below tree and display a fallback UI. 
				- Only use error boundaries for recovering from unexpected exceptions; don’t try to use them for control flow.
				
			static getDerivedStateFromProps(nextProps, prevState)
				- getDerivedStateFromProps is invoked after a component is instantiated as well as when it receives new props. 
					Fix in 16.4: getDerivedStateFromProps is now called every time a component is rendered, regardless of the cause of the update. Previously, it was only called if the component was re-rendered by its parent, and would not fire as the result of a local setState.
				- It should return an object to update state, or null to indicate that the new props do not require any state updates.
				- Together with componentDidUpdate, this new lifecycle should cover all use cases for the legacy componentWillReceiveProps.
				
			getSnapshotBeforeUpdatee(prevProps, prevState)
				- getSnapshotBeforeUpdate() is invoked right before the most recently rendered output is committed to e.g. the DOM. 
				- It enables your component to capture current values (e.g. scroll position) before they are potentially changed.
				- Any value returned by this lifecycle will be passed as a parameter to componentDidUpdate().
				- The new getSnapshotBeforeUpdate lifecycle is called right before mutations are made (e.g. before the DOM is updated). 
				- The return value for this lifecycle will be passed as the third parameter to componentDidUpdate. 
				- (This lifecycle isn’t often needed, but can be useful in cases like manually preserving scroll position during rerenders.)
				- Together with componentDidUpdate, this new lifecycle should cover all use cases for the legacy componentWillUpdate.
				
		Class methods:
		
			setState(updater[, callback])
				- setState() enqueues changes to the component state and tells React that this component and its children need to be re-rendered with the updated state. 
				- This is the primary method you use to update the user interface in response to event handlers and server responses.
				- Think of setState() as a request rather than an immediate command to update the component. For better perceived performance, React may delay it, and then update several components in a single pass. React does not guarantee that the state changes are applied immediately.
				- setState() will always lead to a re-render unless shouldComponentUpdate() returns false. If mutable objects are being used and conditional rendering logic cannot be implemented in shouldComponentUpdate(), calling setState() only when the new state differs from the previous state will avoid unnecessary re-renders.
				
					(prevState, props) => stateChange
					prevState is a reference to the previous state. 
					It should not be directly mutated. 
					Instead, changes should be represented by building a new object based on the input from prevState and props.
					For instance, suppose we wanted to increment a value in state by props.step:
						this.setState((prevState, props) => {
						  return {counter: prevState.counter + props.step};
						});
					Both prevState and props received by the updater function are guaranteed to be up-to-date. The output of the updater is shallowly merged with prevState.
					
				- The second parameter to setState() is an optional callback function that will be executed once setState is completed and the component is re-rendered. Generally we recommend using componentDidUpdate() for such logic instead.
				- You may optionally pass an object as the first argument to setState() instead of a function:
					setState(stateChange[, callback])
					This performs a shallow merge of stateChange into the new state, e.g., to adjust a shopping cart item quantity:
					this.setState({quantity: 2})
					
					This form of setState() is also asynchronous, and multiple calls during the same cycle may be batched together. For example, if you attempt to increment an item quantity more than once in the same cycle, that will result in the equivalent of:
						Object.assign(
						  previousState,
						  {quantity: state.quantity + 1},
						  {quantity: state.quantity + 1},
						  ...
						)
						
					Subsequent calls will override values from previous calls in the same cycle, so the quantity will only be incremented once. If the next state depends on the previous state, we recommend using the updater function form, instead:
						this.setState((prevState) => {
						  return {quantity: prevState.quantity + 1};
						});
			
			component.forceUpdate(callback)
				- By default, when your component’s state or props change, your component will re-render. 
				- If your render() method depends on some other data, you can tell React that the component needs re-rendering by calling forceUpdate().
				
				- Calling forceUpdate() will cause render() to be called on the component, skipping shouldComponentUpdate(). 
				- This will trigger the normal lifecycle methods for child components, including the shouldComponentUpdate() method of each child. 
				- React will still only update the DOM if the markup changes.
				
				- Normally you should try to avoid all uses of forceUpdate() and only read from this.props and this.state in render().


		Class Properties
			defaultProps
				defaultProps can be defined as a property on the component class itself, to set the default props for the class. This is used for undefined props, but not for null props.
					CustomButton.defaultProps = {
						color: 'blue'
					};
					
			displayName
				The displayName string is used in debugging messages. 
				Usually, you don’t need to set it explicitly because it’s inferred from the name of the function or class that defines the component. 
				You might want to set it explicitly if you want to display a different name for debugging purposes or when you create a higher-order component, see Wrap the Display Name for Easy Debugging for details.
						
		Instance Properties
			props
				this.props contains the props that were defined by the caller of this component. See Components and Props for an introduction to props.
				In particular, this.props.children is a special prop, typically defined by the child tags in the JSX expression rather than in the tag itself.

			state
				The state contains data specific to this component that may change over time. The state is user-defined, and it should be a plain JavaScript object.
				If you don’t use it in render(), it shouldn’t be in the state. For example, you can put timer IDs directly on the instance.
				See State and Lifecycle for more information about the state.
				Never mutate this.state directly, as calling setState() afterwards may replace the mutation you made. Treat this.state as if it were immutable.
		
		
	JSX:
		- Fundamentally, JSX just provides syntactic sugar for the React.createElement(component, props, ...children) function. The JSX code:
			<MyButton color="blue" shadowSize={2}>
			  Click Me
			</MyButton>
			
			compiles to: React.createElement(MyButton, {color: 'blue', shadowSize: 2}, 'Click Me')
			
			- Capitalized types indicate that the JSX tag is referring to a React component. 
				These tags get compiled into a direct reference to the named variable, so if you use the JSX <Foo /> expression, Foo must be in scope.
				lowercase types (like div, span) get passed as strings to React.createElement:
					React.createElement(Foo, props, ...children)
					React.createElement("div", props, ...children)
			
			User-Defined Components Must Be Capitalized
				When an element type starts with a lowercase letter, it refers to a built-in component like <div> or <span> and results in a string 'div' or 'span' passed to React.createElement. Types that start with a capital letter like <Foo /> compile to React.createElement(Foo) and correspond to a component defined or imported in your JavaScript file.		
			
			- React Must Be in Scope since JSX compiles into calls to React.createElement, the React library must also always be in scope from your JSX code.
			
			- Children:
				- Booleans, Null, and Undefined Are Ignored
				- can be string or expression
				
	Ref attribute: works only on DOM elements and custom elements that are classes
		- the "ref" attribute makes it possible to store the DOM element/React component (only if it is a class, not a function!) in our component
			<CustomTextInput ref={(input) => { this.textInput = input; }} />	- CustomTextInput extends from React.Component
		- does not work on functional components because they don’t have instances
			function MyFunctionalComponent() {
			  return <input />;
			}
		- It's like angular's @ViewChild - we make a dom/react component available from the template inside render() on the component class as field
			- if using the Callback refs variant (using a callback), refs can be lifted up to parent components.
			<CustomTextInput inputRef={el => this.inputElement = el} />
		
		- There are a few good use cases for refs:
			Managing focus, text selection, or media playback.
			Triggering imperative animations.
			Integrating with third-party DOM libraries.
			
		React will call the ref callback with the DOM element when the component mounts, and call it with null when it unmounts. ref callbacks are invoked before componentDidMount or componentDidUpdate lifecycle hooks.
			
		- Exposing DOM Refs to Parent Components: this works both for classes and for functional components.
		
			function CustomTextInput(props) {
			  return (
				<div>
				  <input ref={props.inputRef} />
				</div>
			  );
			}
			class Parent extends React.Component {
			  render() {
				return (
				  <CustomTextInput inputRef={el => this.inputElement = el} />
				);
			  }
			}
			
			
			function CustomTextInput(props) {
			  return (
				<div>
				  <input ref={props.inputRef} />
				</div>
			  );
			}
			function Parent(props) {
			  return (
				<div>
				  My input: <CustomTextInput inputRef={props.inputRef} />
				</div>
			  );
			}
			class Grandparent extends React.Component {
			  render() {
				return (
				  <Parent
					inputRef={el => this.inputElement = el}
				  />
				);
			  }
			}
			
	Forwarding Refs: 
		- Ref forwarding is a technique for passing a ref through a component to one of its descendants. This technique can be particularly useful with higher-order components (also known as HOCs).
		- By default Refs can only be assigned to the component they are specified to, or can be lifted up as props to any parent component
			
			function logProps(WrappedComponent) {
			  class LogProps extends React.Component {
				componentDidUpdate(prevProps) {
				  console.log('old props:', prevProps);
				  console.log('new props:', this.props);
				}

				render() {
				  return <WrappedComponent {...this.props} />;
				}
			  }

			  return LogProps;
			}
			The “logProps” HOC passes all props through to the component it wraps, so the rendered output will be the same.
			There is one caveat to the above example: refs will not get passed through. That’s because ref is not a prop. Like key, it’s handled differently by React. If you add a ref to a HOC, the ref will refer to the outermost container component, not the wrapped component.
			
			This means that refs intended for our FancyButton component will actually be attached to the LogProps component:
				class FancyButton extends React.Component {
				  focus() {
					// ...
				  }

				  // ...
				}

				// Rather than exporting FancyButton, we export LogProps.
				// It will render a FancyButton though.
				export default logProps(FancyButton);
			
				import FancyButton from './FancyButton';
				const ref = React.createRef();

				// The FancyButton component we imported is the LogProps HOC.
				// Even though the rendered output will be the same,
				// Our ref will point to LogProps instead of the inner FancyButton component!
				// This means we can't call e.g. ref.current.focus()
				<FancyButton
				  label="Click Me"
				  handleClick={handleClick}
				  ref={ref}
				/>;
		
		
		- Fortunately, we can explicitly forward refs to the inner FancyButton component using the React.forwardRef API. React.forwardRef accepts a render function that receives props and ref parameters and returns a React node. For example:
		
			function logProps(Component) {
			  class LogProps extends React.Component {
				componentDidUpdate(prevProps) {
				  console.log('old props:', prevProps);
				  console.log('new props:', this.props);
				}

				render() {
				  const {forwardedRef, ...rest} = this.props;

				  // Assign the custom prop "forwardedRef" as a ref
				  return <Component ref={forwardedRef} {...rest} />;
				}
			  }

			  // Note the second param "ref" provided by React.forwardRef.
			  // We can pass it along to LogProps as a regular prop, e.g. "forwardedRef"
			  // And it can then be attached to the Component.
			  function forwardRef(props, ref) {
				return <LogProps {...props} forwardedRef={ref} />;
			  }

			  // These next lines are not necessary,
			  // But they do give the component a better display name in DevTools,
			  // e.g. "ForwardRef(logProps(MyComponent))"
			  const name = Component.displayName || Component.name;
			  forwardRef.displayName = `logProps(${name})`;

			  return React.forwardRef(forwardRef);
			}
		
			
	Conditional rendering:
		This works because in JavaScript, true && expression always evaluates to expression, and false && expression always evaluates to false.
			return (
				<div>
				  <h1>Hello!</h1>
				  {unreadMessages.length > 0 &&
					<h2>
					  You have {unreadMessages.length} unread messages.
					</h2>
				  }
				</div>
			);
			
	State:
		
		1. Do Not Modify State Directly: use .setState
		
		2. State Updates May Be Asynchronous - use a second form of setState() that accepts a function rather than an object. That function will receive the previous state as the first argument, and the props at the time the update is applied as the second argument:
			// Correct
			this.setState((prevState, props) => ({
			  counter: prevState.counter + props.increment
			}));
			
		3. State Updates are Merged
		
		While this.props is set up by React itself and this.state has a special meaning, you are free to add additional fields to the class manually if you need to store something that is not used for the visual output.
		If you don’t use something in render(), it shouldn’t be in the state.
		
		
	Controlled Components
		- In HTML, form elements such as <input>, <textarea>, and <select> typically maintain their own state and update it based on user input. In React, mutable state is typically kept in the state property of components, and only updated with setState().
		We can combine the two by making the React state be the "single source of truth". Then the React component that renders a form also controls what happens in that form on subsequent user input. An input form element whose value is controlled by React in this way is called a “controlled component”.
		- A controlled input accepts its current value as a prop, as well as a callback to change that value. You could say it’s a more “React way” of approaching this (which doesn’t mean you should always use it).
		- This flow kind of ‘pushes’ the value changes to the form component
		- This means your data (state) and UI (inputs) are always in sync. The state gives the value to the input, and the input asks the Form to change the current value.
		- A form element becomes “controlled” if you set its value via a prop. That’s all.
		
		<input type="text" value={this.state.value} onChange={this.handleChange} />
		handleChange(event) {
			this.setState({value: event.target.value});

		}
		
	Uncontrolled Components
		- Controlled components are the recommended approach
		- In this case form data is handled by the DOM, not by React
		- To write an uncontrolled component, instead of writing an event handler for every state update, you can use a ref to get form values from the DOM.
		- you have to "pull" the value from the field when you need it
		
		<input
			  defaultValue="Bob"
			  type="text"
			  ref={(input) => this.input = input} />
			  
	Performance:	
		React builds and maintains an internal representation of the rendered UI. It includes the React elements you return from your components.
		This representation lets React avoid creating DOM nodes and accessing existing ones beyond necessity, as that can be slower than operations on JavaScript objects.
		Sometimes it is referred to as a “virtual DOM”, but it works the same way on React Native.

		When a component’s props or state change, React decides whether an actual DOM update is necessary by comparing the newly returned element with the previously rendered one. When they are not equal, React will update the DOM.
		In some cases, your component can speed all of this up by overriding the lifecycle function shouldComponentUpdate, which is triggered before the re-rendering process starts. The default implementation of this function returns true, leaving React to perform the update:
		shouldComponentUpdate(nextProps, nextState) {
		  return true;
		}
		
		Scenario:
			shouldComponentUpdate: tells whether React should rerender the component and call its "render()" function. (whenever we change the state, react will invoke the shouldComponentUpdate function)
			if shouldComponentUpdate returns false, we are done
			if shouldComponentUpdate returns true, react calls the render() method and checks whether the react element is equivalent to the one stored on the Virtual DOM
				- this is just a javascript comparison it should be relatively fast
			if they aren't equivalent react has to update the DOM, otherwise no DOM operation is performed
			

		React.PureComponent: shouldComponentUpdate just does a “shallow comparison” between all the fields of props and state to determine if the component should update
		
		pure function: they do not attempt to change their inputs, and always return the same result for the same inputs.
			function sum(a, b) {
			  return a + b;
			}
			
			
		The biggest benefit of immutability in React comes when you build simple pure components. Since immutable data can more easily determine if changes have been made, it also helps to determine when a component requires being re-rendered.
			
			
	Functional vs class components:
		- function components are simpler
		- class components can have state and lifecycle hooks
		
		
	Context:
		In some cases, you want to pass data through the component tree without having to pass the props down manually at every level. You can do this directly in React with the powerful “context” API.
		
		Why Not To Use Context:
			- most applications do not need it
			- If you want your application to be stable, don’t use context. It is an experimental API and it is likely to break in future releases of React.
			- If you aren’t familiar with state management libraries like Redux or MobX, don’t use context.
				- For many practical applications, these libraries and their React bindings are a good choice for managing state that is relevant to many components. 
				
		Example:
			class Button extends React.Component {
			  render() {
				return (
				  <button style={{background: this.context.color}}>
					{this.props.children}
				  </button>
				);
			  }
			}
			Button.contextTypes = {
			  color: PropTypes.string
			};
			
			class Message extends React.Component {
			  render() {
				return (
				  <div>
					{this.props.text} <Button>Delete</Button>
				  </div>
				);
			  }
			}

			class MessageList extends React.Component {
			  getChildContext() {
				return {color: "purple"};
			  }

			  render() {
				const children = this.props.messages.map((message) =>
				  <Message text={message.text} />
				);
				return <div>{children}</div>;
			  }
			}
			MessageList.childContextTypes = {
			  color: PropTypes.string
			};
			
				By adding childContextTypes and getChildContext to MessageList (the context provider), React passes the information down automatically and any component in the subtree (in this case, Button) can access it by defining contextTypes.

				If contextTypes is not defined, then context will be an empty object.
				
		Parent-Child Coupling: React Router V4 uses this context API
		
		Referencing Context in Lifecycle Methods:
			If contextTypes is defined within a component, the following lifecycle methods will receive an additional parameter, the context object:
				- constructor(props, context)
				- componentWillReceiveProps(nextProps, nextContext)
				- shouldComponentUpdate(nextProps, nextState, nextContext)
				- componentWillUpdate(nextProps, nextState, nextContext)

				
	Fragments: a common pattern for a component to return multiple elements
		- the react components (capitalized classes) do not get rendered into the DOM - so for example in case of <Column /> we will never see <Column /> DOM node.
		- however a component in its render() function can return only 1 element
			- another component, text, numbers
			- or an array of one of the above
		- fragments are good for returning multiple elements	

		class Columns extends React.Component {
		  render() {
			return (
			  <React.Fragment> 		or <>
				<td>Hello</td>
				<td>World</td>
			  </React.Fragment>		or </>
			);
		  }
		}
		
		class Table extends React.Component {
		  render() {
			return (
			  <table>
				<tr>
				  <Columns />
				</tr>
			  </table>
			);
		  }
		}
		
		Use <Fragment> when a key prop is required:

			import React, { Fragment } from 'react';

			function Glossary(props) {
			  return (
				<dl>
				  {props.items.map(item => (
					// Without the `key`, React will fire a key warning
					<Fragment key={item.id}>
					  <dt>{item.term}</dt>
					  <dd>{item.description}</dd>
					</Fragment>
				  ))}
				</dl>
			  );
			}
		Use <></> syntax everywhere else:

			function ListItem({ item }) {
			  return ( 
				<>
				  <dt>{item.term}</dt>
				  <dd>{item.description}</dd>>
				</>
			  );    
			}
		
		
	Portals: Portals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy of the parent component.

		ReactDOM.createPortal(child, container)
		
		render() {
		  // React mounts a new div and renders the children into it
		  return (
			<div>
			  {this.props.children}
			</div>
		  );
		}
		render() {
		  // React does *not* create a new div. It renders the children into `domNode`.
		  // `domNode` is any valid DOM node, regardless of its location in the DOM.
		  return ReactDOM.createPortal(
			this.props.children,
			domNode,
		  );
		}
		
		Event Bubbinlg Through Portals:
			Even though a portal can be anywhere in the DOM tree, it behaves like a normal React child in every other way. Features like context work exactly the same regardless of whether the child is a portal, as the portal still exists in the React tree regardless of position in the DOM tree.

			This includes event bubbling. An event fired from inside a portal will propagate to ancestors in the containing React tree, even if those elements are not ancestors in the DOM tree. Assuming the following HTML structure:
			

	Error Boundaries
		A JavaScript error in a part of the UI shouldn’t break the whole app. To solve this problem for React users, React 16 introduces a new concept of an “error boundary”.

		Error boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed.
		Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them.
		
		Error boundaries do not catch errors for:
			- Event handlers (learn more)
			- Asynchronous code (e.g. setTimeout or requestAnimationFrame callbacks)
			- Server side rendering
			- Errors thrown in the error boundary itself (rather than its children)
			
		A class component becomes an error boundary if it defines a new lifecycle method called "componentDidCatch(error, info)"
		
			componentDidCatch(error, info) {
				// Display fallback UI
				this.setState({ hasError: true });
				// You can also log the error to an error reporting service
				logErrorToMyService(error, info);
			}
			
		The componentDidCatch() method works like a JavaScript catch {} block, but for components. Only class components can be error boundaries. In practice, most of the time you’ll want to declare an error boundary component once and use it throughout your application.
		
		Where to Place Error Boundaries
			The granularity of error boundaries is up to you. 
			You may wrap top-level route components to display a “Something went wrong” message to the user, just like server-side frameworks often handle crashes. 
			You may also wrap individual widgets in an error boundary to protect them from crashing the rest of the application.
			
		New Behavior for Uncaught Errors
			This change has an important implication. As of React 16, errors that were not caught by any error boundary will result in unmounting of the whole React component tree.
			
		How About try/catch?
			try / catch is great but it only works for imperative code:
				try {
				  showButton();
				} catch (error) {
				  // ...
				}
			However, React components are declarative and specify what should be rendered:
				<Button />
				Error boundaries preserve the declarative nature of React, and behave as you would expect. For example, even if an error occurs in a componentDidUpdate hook caused by a setState somewhere deep in the tree, it will still correctly propagate to the closest error boundary.
			
		How About Event Handlers?
			Error boundaries do not catch errors inside event handlers.

			React doesn’t need error boundaries to recover from errors in event handlers. Unlike the render method and lifecycle hooks, the event handlers don’t happen during rendering. So if they throw, React still knows what to display on the screen.

			If you need to catch an error inside event handler, use the regular JavaScript try / catch statement:
				class MyComponent extends React.Component {
				  constructor(props) {
					super(props);
					this.state = { error: null };
				  }
				  
				  handleClick = () => {
					try {
					  // Do something that could throw
					} catch (error) {
					  this.setState({ error });
					}
				  }

				  render() {
					if (this.state.error) {
					  return <h1>Caught an error.</h1>
					}
					return <div onClick={this.handleClick}>Click Me</div>
				  }
				}
				
	Higher-Order Components	(HOC)
		A higher-order component (HOC) is an advanced technique in React for reusing component logic. HOCs are not part of the React API, per se. They are a pattern that emerges from React’s compositional nature.
		Concretely, a higher-order component is a function that takes a component and returns a new component.
			const EnhancedComponent = higherOrderComponent(WrappedComponent);
			
			The function receives a Component as its 1st parameter and that component becomes the child of the returned new, enhanced Component.
			
		Whereas a component transforms props into UI, a higher-order component transforms a component into another component.
		HOCs are common in third-party React libraries, such as Redux’s connect and Relay’s createFragmentContainer.
		
		Note that a HOC doesn’t modify the input component, nor does it use inheritance to copy its behavior. Rather, a HOC composes the original component by wrapping it in a container component. 
		A HOC is a pure function with zero side-effects.
		
			const CommentListWithSubscription = withSubscription(
			  CommentList,
			  (DataSource) => DataSource.getComments()
			);

			const BlogPostWithSubscription = withSubscription(
			  BlogPost,
			  (DataSource, props) => DataSource.getBlogPost(props.id)
			);
		
			// This function takes a component...
			function withSubscription(WrappedComponent, selectData) {
			  // ...and returns another component...
			  return class extends React.Component {
				constructor(props) {
				  super(props);
				  this.handleChange = this.handleChange.bind(this);
				  this.state = {
					data: selectData(DataSource, props)
				  };
				}

				componentDidMount() {
				  // ... that takes care of the subscription...
				  DataSource.addChangeListener(this.handleChange);
				}

				componentWillUnmount() {
				  DataSource.removeChangeListener(this.handleChange);
				}

				handleChange() {
				  this.setState({
					data: selectData(DataSource, this.props)
				  });
				}

				render() {
				  // ... and renders the wrapped component with the fresh data!
				  // Notice that we pass through any additional props
				  return <WrappedComponent data={this.state.data} {...this.props} />;
				}
			  };
			}
			
		Don’t Mutate the Original Component. Use Composition.
				function logProps(InputComponent) {
				  InputComponent.prototype.componentWillReceiveProps = function(nextProps) {
					console.log('Current props: ', this.props);
					console.log('Next props: ', nextProps);
				  };
				  // The fact that we're returning the original input is a hint that it has
				  // been mutated.
				  return InputComponent;
				}

				// EnhancedComponent will log whenever props are received
				const EnhancedComponent = logProps(InputComponent);
			
			Instead of mutation, HOCs should use composition, by wrapping the input component in a container component:

				function logProps(WrappedComponent) {
				  return class extends React.Component {
					componentWillReceiveProps(nextProps) {
					  console.log('Current props: ', this.props);
					  console.log('Next props: ', nextProps);
					}
					render() {
					  // Wraps the input component in a container, without mutating it. Good!
					  return <WrappedComponent {...this.props} />;
					}
				  }
				}
				
				This HOC has the same functionality as the mutating version while avoiding the potential for clashes. It works equally well with class and functional components. And because it’s a pure function, it’s composable with other HOCs, or even with itself.
				
		Convention: Pass Unrelated Props Through to the Wrapped Component
			render() {
			  // Filter out extra props that are specific to this HOC and shouldn't be
			  // passed through
			  const { extraProp, ...passThroughProps } = this.props;

			  // Inject props into the wrapped component. These are usually state values or
			  // instance methods.
			  const injectedProp = someStateOrInstanceMethod;

			  // Pass props to wrapped component
			  return (
				<WrappedComponent
				  injectedProp={injectedProp}
				  {...passThroughProps}
				/>
			  );
			}
			
		Convention: Maximizing Composability
			// React Redux's `connect`
			const ConnectedComment = connect(commentSelector, commentActions)(CommentList);
			
			What?! If you break it apart, it’s easier to see what’s going on.
				// connect is a function that returns another function
				const enhance = connect(commentListSelector, commentListActions);
				// The returned function is a HOC, which returns a component that is connected
				// to the Redux store
				const ConnectedComment = enhance(CommentList);
				
			// Instead of doing this...
			const EnhancedComponent = withRouter(connect(commentSelector)(WrappedComponent))

			// ... you can use a function composition utility
			// compose(f, g, h) is the same as (...args) => f(g(h(...args)))
			const enhance = compose(
			  // These are both single-argument HOCs
			  withRouter,
			  connect(commentSelector)
			)
			const EnhancedComponent = enhance(WrappedComponent)
			
		Convention: Wrap the Display Name for Easy Debugging
			The most common technique is to wrap the display name of the wrapped component. So if your higher-order component is named withSubscription, and the wrapped component’s display name is CommentList, use the display name WithSubscription(CommentList):

			function withSubscription(WrappedComponent) {
			  class WithSubscription extends React.Component {/* ... */}
			  WithSubscription.displayName = `WithSubscription(${getDisplayName(WrappedComponent)})`;
			  return WithSubscription;
			}

			function getDisplayName(WrappedComponent) {
			  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
			}
			
		Caveats
			Don’t Use HOCs Inside the render Method
				-Instead, apply HOCs outside the component definition so that the resulting component is created only once. Then, its identity will be consistent across renders. This is usually what you want, anyway.
				- In those rare cases where you need to apply a HOC dynamically, you can also do it inside a component’s lifecycle methods or its constructor.
			
				render() {
				  // A new version of EnhancedComponent is created on every render
				  // EnhancedComponent1 !== EnhancedComponent2
				  const EnhancedComponent = enhance(MyComponent);
				  // That causes the entire subtree to unmount/remount each time!
				  return <EnhancedComponent />;
				}
				The problem here isn’t just about performance — remounting a component causes the state of that component and all of its children to be lost.
				
			Static Methods Must Be Copied Over
				function enhance(WrappedComponent) {
				  class Enhance extends React.Component {/*...*/}
				  // Must know exactly which method(s) to copy :(
				  Enhance.staticMethod = WrappedComponent.staticMethod;
				  return Enhance;
				}
				
				However, this requires you to know exactly which methods need to be copied. You can use hoist-non-react-statics to automatically copy all non-React static methods.
				
					import hoistNonReactStatic from 'hoist-non-react-statics';
					function enhance(WrappedComponent) {
					  class Enhance extends React.Component {/*...*/}
					  hoistNonReactStatic(Enhance, WrappedComponent);
					  return Enhance;
					}
					
			Refs Aren’t Passed Through


	Render props: More concretely, a render prop is a function prop that a component uses to know what to render.

		- In fact, any prop that is a function that a component uses to know what to render is technically a “render prop”.
		- One interesting thing to note about render props is that you can implement most higher-order components (HOC) using a regular component with a render prop. 

		Example:
			class MouseTracker extends React.Component {
			  render() {
				return (
				  <div>
					<h1>Move the mouse around!</h1>
					<Mouse render={mouse => (
					  <Cat mouse={mouse} />
					)}/>
				  </div>
				);
			  }
			}
			class Mouse extends React.Component {
			  constructor(props) {
				super(props);
				this.handleMouseMove = this.handleMouseMove.bind(this);
				this.state = { x: 0, y: 0 };
			  }

			  handleMouseMove(event) {
				this.setState({
				  x: event.clientX,
				  y: event.clientY
				});
			  }

			  render() {
				return (
				  <div style={{ height: '100%' }} onMouseMove={this.handleMouseMove}>

					{/*
					  Instead of providing a static representation of what <Mouse> renders,
					  use the `render` prop to dynamically determine what to render.
					*/}
					{this.props.render(this.state)}
				  </div>
				);
			  }
			}
		
		HOC example:
			// If you really want a HOC for some reason, you can easily
			// create one using a regular component with a render prop!
			function withMouse(Component) {
			  return class extends React.Component {
				render() {
				  return (
					<Mouse render={mouse => (
					  <Component {...this.props} mouse={mouse} />
					)}/>
				  );
				}
			  }
			}
			
		children as render prop:
			Although the examples above use render, we could just as easily use the children prop!
				<Mouse children={mouse => (
				  <p>The mouse position is {mouse.x}, {mouse.y}</p>
				)}/>
				
			And remember, the children prop doesn’t actually need to be named in the list of “attributes” in your JSX element. Instead, you can put it directly inside the element!
				<Mouse>
				  {mouse => (
					<p>The mouse position is {mouse.x}, {mouse.y}</p>
				  )}
				</Mouse>
				
		Caveats! Be careful when using Render Props with React.PureComponent
			class Mouse extends React.PureComponent {
			  // Same implementation as above...
			}
			class MouseTracker extends React.Component {
			  render() {
				return (
				  <div>
					<h1>Move the mouse around!</h1>

					{/*
					  This is bad! The value of the `render` prop will
					  be different on each render.
					*/}
					<Mouse render={mouse => (
					  <Cat mouse={mouse} />
					)}/>
				  </div>
				);
			  }
			}
			
			To get around this problem, you can sometimes define the prop as an instance method, like so:

				class MouseTracker extends React.Component {
				  constructor(props) {
					super(props);

					// This binding ensures that `this.renderTheCat` always refers
					// to the *same* function when we use it in render.
					this.renderTheCat = this.renderTheCat.bind(this);
				  }

				  renderTheCat(mouse) {
					return <Cat mouse={mouse} />;
				  }

				  render() {
					return (
					  <div>
						<h1>Move the mouse around!</h1>
						<Mouse render={this.renderTheCat} />
					  </div>
					);
				  }
				}
				In cases where you cannot bind the instance method ahead of time in the constructor (e.g. because you need to close over the component’s props and/or state) <Mouse> should extend React.Component instead.
			

	Code splitting: to produce smaller bundles:
		Before:
			import { add } from './math';
			console.log(add(16, 26));
		After:
			import("./math").then(math => {
			  console.log(math.add(16, 26));
			});
			
		Create React App has this configured automatically with webpack (because this syntax in not yet in the ECMAScript standard)
			
		Libraries: 
			React Loadable: React Loadable wraps dynamic imports in a nice, React-friendly API for introducing code splitting into your app at a given component.
		
		Route-based code splitting: Here’s an example of how to setup route-based code splitting into your app using libraries like React Router and React Loadable.
			import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';
			import Loadable from 'react-loadable';

			const Loading = () => <div>Loading...</div>;

			const Home = Loadable({
			  loader: () => import('./routes/Home'),
			  loading: Loading,
			});

			const About = Loadable({
			  loader: () => import('./routes/About'),
			  loading: Loading,
			});

			const App = () => (
			  <Router>
				<Switch>
				  <Route exact path="/" component={Home}/>
				  <Route path="/about" component={About}/>
				</Switch>
			  </Router>
			);
			
			
	React elements vs HTML elements
		React JSX				HTML
		camelCasing				lowercasing
		className				class
		htmlForm				for
		

React Router
	Currently, a link's pathname must be absolute
	
	Most important components:
		<BrowserRouter>
		<Route> - to create placeholders where the router injects the specified component into
			What does the <Route> render?
				1. component: a React component. When a route with a component prop matches, the route will return a new element whose type is the provided React component (created using React.createElement).
				2. render: a function that returns a React element [5]. It will be called when the path matches. This is similar to component, but is useful for inline rendering and passing extra props to the element.
				3. children: a function that returns a React element. Unlike the prior two props, this will always be rendered, regardless of whether the route’s path matches the current location.
				
				<Route path='/page' component={Page} />
				
				const extraProps = { color: 'red' }
				<Route path='/page' render={(props) => (
				  <Page {...props} data={extraProps}/>
				)}/>
				
				<Route path='/page' children={(props) => (
				  props.match
					? <Page {...props}/>
					: <EmptyPage {...props}/>
				)}/>
		<Link> - to create links
		<Switch> - renders only the 1st <Route /> that matches the url
			- by default each <Route /> gets rendered
				<Route path="/about" component={About}/>
				<Route path="/:user" component={User}/>
				<Route component={NoMatch}/>
				- If the URL is /about, then <About>, <User>, and <NoMatch> will all render because they all match the path. This is by design, allowing us to compose <Route>s into our apps in many ways, like sidebars and breadcrumbs, bootstrap tabs, etc.
		<Redirect> - to redirect the user to the specified component. This changes the browser history along with the browser url as well.
		
		
		<Route path="/cats/:id" component={CatPage} />
			The <Route> injects routing props to its child component (the one it renders. In this case it is CatPage)
				- match
				- location
				- history - can be used to programatically change the url. This initiates a navigation
					- this.props.history.push('url');
			
			- The CatPage will have a props called "match" which "params" property will contain the url parameters:
				props.match.params.id
				To access this from the mapStateToProps function: ownProps.match.params.id
			All properties of match:
				- isExact
				- params
				- path
				- url
				
		404 pages:
			- <Route component={NotFound} /> - this renders the NotFound component no matter what the url is
			- place this Route to be the last
			- wrap all the routes with the <Switch> component

	Connected React Router: 
		- a Redux binding for React Router v4
		- the Redux Chrome browser extension will display history related to route changes and we can go back in time
	
	
Redux

	Overview:
		Redux manages the state of an app using a single store. To modify the state, an action is dispatched to the store and a reducer updates the store based on the type and other values of the action. 
		In order to use the new state, the store can be subscribed to. Subscribing requires a callback function which is called whenever the store updates.
		
	What makes redux fast:
		- I have to create a new instance for the state at each dispatch though
		- I can keep using previous references to arrays, complex objects if they did not change! - this makes it fast
			- React PureComponents do a shallow comparison on props passed to them
			- react-redux's connect() function implements shouldComponentUpdate and does a shallow reference comparison
		- Though on each state change all of the mapStateToProps() functions get executed again, but the reference of the props stay the same => shouldComponentUpdate() returns false => and no render() is invoked
			- For complex calculations in mapStateToProps reselect can be used which uses caching
		
	Data flow in React: dispatch(action) -> reducer -> new state -> re-render

	Redux is a predictable state container for JavaScript apps.
	
	- The whole state of your app is stored in an object tree inside a single store.
	- The only way to change the state tree is to emit an action, an object describing what happened.
	- To specify how the actions transform the state tree, you write pure reducers.
	
	Glossary:
	
		State:
			- State (also called the state tree) is a broad term, but in the Redux API it usually refers to the single state value that is managed by the store and returned by getState(). It represents the entire state of a Redux application, which is often a deeply nested object. TRhe state is readonly. The only way to change the state tree is to dispatch an action.
			
		Action: 
			- An action is a plain object that represents an intention to change the state. Actions are the only way to get data into the store. Any data, whether from UI events, network callbacks, or other sources such as WebSockets needs to eventually be dispatched as actions.
			- Actions must have a type field that indicates the type of action being performed. Types can be defined as constants and imported from another module. It's better to use strings for type than Symbols because strings are serializable.
			
		Reducer:
			type Reducer<S, A> = (state: S, action: A) => S
			- A reducer (also called a reducing function) is a function that accepts an accumulation and a value and returns a new accumulation. They are used to reduce a collection of values down to a single value.
			- In Redux, the accumulated value is the state object, and the values being accumulated are actions. Reducers calculate a new state given the previous state and an action. They must be pure functions—functions that return the exact same output for given inputs. They should also be free of side-effects. This is what enables exciting features like hot reloading and time travel.
			- They must be synchronous
			- No side effects (no going to the server, debounce, setTimeout, etc.)
			- Do not modify the values passed to them - they are immutable
			- A useful convention is to always name the reducers after the state-key they manage. This way combineReducers will produce a state with the exact same as the reducers have.
			
		Dispatching function:
			type BaseDispatch = (a: Action) => Action
			type Dispatch = (a: Action | AsyncAction) => any
			A dispatching function (or simply dispatch function) is a function that accepts an action or an async action; it then may or may not dispatch one or more actions to the store.

			We must distinguish between dispatching functions in general and the base dispatch function provided by the store instance without any middleware.

			The base dispatch function always synchronously sends an action to the store's reducer, along with the previous state returned by the store, to calculate a new state. 
			It expects actions to be plain objects ready to be consumed by the reducer.

			Middleware wraps the base dispatch function. It allows the dispatch function to handle async actions, or even Observables in addition to actions. 
			Middleware may transform, delay, ignore, dispatch a new action, or otherwise interpret actions or async actions before passing them to the next middleware. 
			See below for more information.
	
		Action Creator
			type ActionCreator = (...args: any) => Action | AsyncAction
			An action creator is, quite simply, a function that creates an action. Do not confuse the two terms—again, an action is a payload of information, and an action creator is a factory that creates an action.

			Calling an action creator only produces an action, but does not dispatch it. You need to call the store's dispatch function to actually cause the mutation. Sometimes we say bound action creators to mean functions that call an action creator and immediately dispatch its result to a specific store instance.

			If an action creator needs to read the current state, perform an API call, or cause a side effect, like a routing transition, it should return an async action instead of an action.
			
		Async Action
			type AsyncAction = any
			An async action is a value that is sent to a dispatching function, but is not yet ready for consumption by the reducer. It will be transformed by middleware into an action (or a series of actions) before being sent to the base dispatch() function. Async actions may have different types, depending on the middleware you use. They are often asynchronous primitives, like a Promise or a thunk, which are not passed to the reducer immediately, but trigger action dispatches once an operation has completed.
			
		Middleware
			type MiddlewareAPI = { dispatch: Dispatch, getState: () => State }
			type Middleware = (api: MiddlewareAPI) => (next: Dispatch) => Dispatch
			A middleware is a higher-order function that composes a dispatch function to return a new dispatch function. It often turns async actions into actions.
				A higher-order function is a function that takes one or more functions as parameters and returns a function as its result.

			Middleware is composable using function composition. It is useful for logging actions, performing side effects like routing, or turning an asynchronous API call into a series of synchronous actions.
			
			Middleware enhances the store by enabling you to interact with dispatched actions before they reach the store. 
			To do this, the store's dispatch function is modified to run the middleware functions before the original dispatch function is called which ultimately sends the action to the reducers.
			
			Middleware provides a way to interact with actions that have been dispatched to the store before they reach the store's reducer.
				Middleware is used by composing the functions together and passing that function to your createStore call. 
				The composed middleware function is used to replace the store's default dispatch method with one that dispatches the action to each middleware function in a chain, 
				with the last middleware function dispatching the action to the store.
			
		Store
			type Store = {
			  dispatch: Dispatch
			  getState: () => State
			  subscribe: (listener: () => void) => () => void
			  replaceReducer: (reducer: Reducer) => void
			}
			A store is an object that holds the application's state tree.
			There should only be a single store in a Redux app, as the composition happens on the reducer level.

			dispatch(action) is the base dispatch function described above.
			getState() returns the current state of the store.
			subscribe(listener) registers a function to be called on state changes.
			replaceReducer(nextReducer) can be used to implement hot reloading and code splitting. Most likely you won't use it.
		
		Store creator
			type StoreCreator = (reducer: Reducer, preloadedState: ?State) => Store
			A store creator is a function that creates a Redux store. Like with dispatching function, we must distinguish the base store creator, createStore(reducer, preloadedState) exported from the Redux package, from store creators that are returned from the store enhancers.
			
		Store enhancer
			type StoreEnhancer = (next: StoreCreator) => StoreCreator
			A store enhancer is a higher-order function that composes a store creator to return a new, enhanced store creator. This is similar to middleware in that it allows you to alter the store interface in a composable way.

			Store enhancers are much the same concept as higher-order components in React, which are also occasionally called "component enhancers".
	
	
	Reducer: a pure function with (state, action) => state signature.
		The shape of the state is up to you: it can be a primitive, an array, an object, or even an Immutable.js data structure. The only important part is that you should not mutate the state object, but return a new object if the state changes.

	Example:		
		// Create a Redux store holding the state of your app.
		// Its API is { subscribe, dispatch, getState }.
		let store = createStore(counter)

		// You can use subscribe() to update the UI in response to state changes.
		// Normally you'd use a view binding library (e.g. React Redux) rather than subscribe() directly.
		// However it can also be handy to persist the current state in the localStorage.

		store.subscribe(() =>
		  console.log(store.getState())
		)

		// The only way to mutate the internal state is to dispatch an action.
		// The actions can be serialized, logged or stored and later replayed.
		store.dispatch({ type: 'INCREMENT' })
		// 1
		store.dispatch({ type: 'INCREMENT' })
		// 2
		store.dispatch({ type: 'DECREMENT' })
		
	Instead of mutating the state directly, you specify the mutations you want to happen with plain objects called actions. Then you write a special function called a reducer to decide how every action transforms the entire application's state.
	
	If you're coming from Flux, there is a single important difference you need to understand. Redux doesn't have a Dispatcher or support many stores. Instead, there is just a single store with a single root reducing function. As your app grows, instead of adding stores, you split the root reducer into smaller reducers independently operating on the different parts of the state tree. This is exactly like how there is just one root component in a React app, but it is composed out of many small components.
	
	Finally, to tie state and actions together, we write a function called a reducer. It would be hard to write such a function for a big app, so we write smaller functions managing parts of the state:
		function visibilityFilter(state = 'SHOW_ALL', action) {
		  if (action.type === 'SET_VISIBILITY_FILTER') {
			return action.filter
		  } else {
			return state
		  }
		}

		function todos(state = [], action) {
		  switch (action.type) {
			case 'ADD_TODO':
			  return state.concat([{ text: action.text, completed: false }])
			case 'TOGGLE_TODO':
			  return state.map(
				(todo, index) =>
				  action.index === index
					? { text: todo.text, completed: !todo.completed }
					: todo
			  )
			default:
			  return state
		  }
		}
	And we write another reducer that manages the complete state of our app by calling those two reducers for the corresponding state keys:
		function todoApp(state = {}, action) {
		  return {
			todos: todos(state.todos, action),
			visibilityFilter: visibilityFilter(state.visibilityFilter, action)
		  }
		}
		
	Three Principles:
		1. Single source of truth: The state of your whole application is stored in an object tree within a single store.
		2. State is read-only: The only way to change the state is to emit an action, an object describing what happened.
			This ensures that neither the views nor the network callbacks will ever write directly to the state. Instead, they express an intent to transform the state. Because all changes are centralized and happen one by one in a strict order, there are no subtle race conditions to watch out for. As actions are just plain objects, they can be logged, serialized, stored, and later replayed for debugging or testing purposes.
		3. Changes are made with pure functions: To specify how the state tree is transformed by actions, you write pure reducers.
			Reducers are just pure functions that take the previous state and an action, and return the next state. Remember to return new state objects, instead of mutating the previous state. You can start with a single reducer, and as your app grows, split it off into smaller reducers that manage specific parts of the state tree. Because reducers are just functions, you can control the order in which they are called, pass additional data, or even make reusable reducers for common tasks such as pagination.
			
			import { combineReducers, createStore } from 'redux'
			const reducer = combineReducers({ visibilityFilter, todos })
			const store = createStore(reducer)

		
	API:
		combineReducers(reducers)
			- As your app grows more complex, you'll want to split your reducing function into separate functions, each managing independent parts of the state.
			- The combineReducers helper function turns an object whose values are different reducing functions into a single reducing function you can pass to createStore.
			- The resulting reducer calls every child reducer delegating them parts of the state tree, and gathers their results into a single state object. The state produced by combineReducers() namespaces the states of each reducer under their keys as passed to combineReducers()
			
			All combineReducers() does is generate a function that calls your reducers with the slices of state selected according to their keys, and combining their results into a single object again.
			
		compose(...functions)
			Composes functions from right to left.
			
		Store
			A store holds the whole state tree of your application.
			The only way to change the state inside it is to dispatch an action on it.

			A store is not a class. It's just an object with a few methods on it.
			To create it, pass your root reducing function to createStore.
			
			Methods:
				- getState(): Returns the current state tree of your application.
				- dispatch(action): Dispatches an action. This is the only way to trigger a state change. The store's reducing function will be called with the current getState() result and the given action synchronously. Its return value will be considered the next state.
				- subscribe(listener): Adds a change listener. It will be called any time an action is dispatched, and some part of the state tree may potentially have changed.
				- replaceReducer(nextReducer): Replaces the reducer currently used by the store to calculate the state. It is advanced API, you might need this if your app implements code splitting.
		
		createStore(reducer, [preloadedState], [enhancer]):
			Creates a Redux store that holds the complete state tree of your app.
			There should only be a single store in your app.
			
			reducer (Function): A reducing function that returns the next state tree, given the current state tree and an action to handle.

			[preloadedState] (any): The initial state. You may optionally specify it to hydrate the state from the server in universal apps, or to restore a previously serialized user session. If you produced reducer with combineReducers, this must be a plain object with the same shape as the keys passed to it. Otherwise, you are free to pass anything that your reducer can understand.

			[enhancer] (Function): The store enhancer. You may optionally specify it to enhance the store with third-party capabilities such as middleware, time travel, persistence, etc. The only store enhancer that ships with Redux is applyMiddleware().
	
		applyMiddleware
			Middleware is the suggested way to extend Redux with custom functionality. Middleware lets you wrap the store's dispatch method for fun and profit. The key feature of middleware is that it is composable. Multiple middleware can be combined together, where each middleware requires no knowledge of what comes before or after it in the chain.

			The most common use case for middleware is to support asynchronous actions without much boilerplate code or a dependency on a library like Rx. It does so by letting you dispatch async actions in addition to normal actions.
			
			So basically with middleware the dispatch method (that accepts action objects by default) can be extended via composition.
			
		bindActionCreators(actionCreators, dispatch)
			Turns an object whose values are action creators, into an object with the same keys, but with every action creator wrapped into a dispatch call so they may be invoked directly.
			Normally you should just call dispatch directly on your Store instance. If you use Redux with React, react-redux will provide you with the dispatch function so you can call it directly, too.
			The only use case for bindActionCreators is when you want to pass some action creators down to a component that isn't aware of Redux, and you don't want to pass dispatch or the Redux store to it.
			
	Data Flow:
		1. You call store.dispatch(action)
			An action is a plain object describing what happened.
			You can call store.dispatch(action) from anywhere in your app, including components and XHR callbacks, or even at scheduled intervals.
		2. The Redux store calls the reducer function you gave it - the root reducer by default, or enhanced one
			The store will pass two arguments to the reducer: the current state tree and the action.
			Note that a reducer is a pure function. It only computes the next state.
			It shouldn't perform any side effects like API calls or router transitions. These should happen before an action is dispatched.
		3. The root reducer may combine the output of multiple reducers into a single state tree.
		4. The Redux store saves the complete state tree returned by the root reducer.
			This new tree is now the next state of your app! Every listener registered with store.subscribe(listener) will now be invoked; listeners may call store.getState() to get the current state
			Now, the UI can be updated to reflect the new state. If you use bindings like React Redux, this is the point at which component.setState(newState) is called.


React Redux:

	React bindings for Redux embrace the idea of separating presentational and container components. 
	The current suggested best practice is to categorize your components as "presentational" or "container" components, and extract a connected container component wherever it makes sense:
	
	Presentational components:
		- Are concerned with how things look.
		- May contain both presentational and container components** inside, and usually have some DOM markup and styles of their own.
		- Have no dependencies on the rest of the app, such as Flux actions or stores.
		- Don’t specify how the data is loaded or mutated.
		- Receive data and callbacks exclusively via props.
		- Are written as functional components unless they need state, lifecycle hooks, or performance optimizations.
		- Examples: Page, Sidebar, Story, UserInfo, List.
		
	Container components:
		- Are concerned with how things work.
		- May contain both presentational and container components** inside but usually don’t have any DOM markup of their own except for some wrapping divs, and never have any styles.
		- Provide the data and behavior to presentational or other container components.
		- Call Flux actions and provide these as callbacks to the presentational components.
		- Are often stateful, as they tend to serve as data sources.
		- Are usually generated using higher-order components such as connect() from React Redux, createContainer() from Relay, or Container.create() from Flux Utils, rather than written by hand.
		- Examples: UserPage, FollowersSidebar, StoryContainer, FollowedUserList.
		
	When to Introduce Containers?
		When you notice that some components don’t use the props they receive but merely forward them down and you have to rewire all those intermediate components any time the children need more data, it’s a good time to introduce some container components. 
		This way you can get the data and the behavior props to the leaf components without burdening the unrelated components in the middle of the tree.
		
	Components:
		- Stateful and Stateless. Some components use React setState() method and some don’t. While container components tend to be stateful and presentational components tend to be stateless, this is not a hard rule. Presentational components can be stateful, and containers can be stateless too.
		- Classes and Functions. Since React 0.14, components can be declared both as classes and as functions. Functional components are simpler to define but they lack certain features currently available only to class components. Some of these restrictions may go away in the future but they exist today. Because functional components are easier to understand, I suggest you to use them unless you need state, lifecycle hooks, or performance optimizations, which are only available to the class components at this time.
		- Pure and Impure. People say that a component is pure if it is guaranteed to return the same result given the same props and state. Pure components can be defined both as classes and functions, and can be both stateful and stateless. Another important aspect of pure components is that they don’t rely on deep mutations in props or state, so their rendering performance can be optimized by a shallow comparison in their shouldComponentUpdate() hook. Currently only classes can define shouldComponentUpdate() but that may change in the future.
		- Pure and logical: 
			- logical components tends to have state their own state management (React state) and may take place in React lifecycle
			- pure components solely rely only on props, stateless, pure functions, don't take place in React lifecycle
		
		
							Presentational Components				Container Components
	Purpose					How things look (markup, styles)		How things work (data fetching, state updates)
	Aware of Redux			No										Yes
	To read data			Read data from props					Subscribe to Redux state
	To change data			Invoke callbacks from props				Dispatch Redux actions
	Are written				By hand									Usually generated by React Redux
	
	Container components: use React Redux's "connect()" function
		Technically, a container component is just a React component that uses store.subscribe() to read a part of the Redux state tree and supply props to a presentational component it renders.
	
		You could write a container component by hand using store.subscribe(), but we suggest instead generating container components with the React Redux library's connect() function, which provides many useful optimizations to prevent unnecessary re-renders.
		
	Separation of container and presentational components are not required by redux but it is recommended because it decouples the rendering from redux so later it is easier to move to different frameworks other then redux
		while keeping the presentational components exactly the same.
		
		
	connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options]):
			- implements shouldComponentUpdate() for performance
			- if mapDispatchToProps is not provided, or it is any falsy value like "null", the "dispatch" function gets mapped to the connected component's props. It can directly be invoked then.
			- subscribes to store changes in the componentDidMount(), unsubscribes in componentWillUnmount(), and opts-in to context API to be able to access the store provided by <Provider>
				does not subscribe is mapStateToProps is a falsy value
			- mapStateToProps gets invoked anytime the redux state changes (if the 2nd parameter is specified then also gets invoked anytime the ownProps on the connected component changes)
			- mapDispatchToProps gets invoked only after the component gets mounted (or if the 2nd parameter is specified then also gets invoked anytime the ownProps on the connected component changes)
			- it calculates the props that need to get passed to the presentational component by merging the objects returned from mapStateToProps, mapDispatchToProps and its own props
			- passes all additional props to the enhanced Component, not just the ones mapped in mapStateToProps and mapDispatchToProps
				- so this works like a charm: withRouter(connect(null, null)(MyComponent)) --> MyComponent will receive the "history" and "match" objects as props
		
		mapStateToProps(state, [ownProps]): stateProps: that tells how to transform the current Redux store state into the props you want to pass to a presentational component you are wrapping
			- If your mapStateToProps function is declared as taking two parameters, it will be called with the store state as the first parameter and the props passed to the connected component as the second parameter, and will also be re-invoked whenever the connected component receives new props as determined by shallow equality comparisons
			- If mapStateToProps is null, it tells connect() there is no need to subscribe to the store
					- connect(null)
			
			mapStateToProps is a function that will be called when our component mounts, updates, or our store state is changed
				- Use componentWillReceiveProps if you want to handle the update in the props: for example to set the component's internal state object to make it possible to have some interaction with forms
				
					Example:
						- There's only one problem. Earlier, we set up our mapStateToProps function to contain a default, empty cat object, as well as default, empty catHobbies and checkBoxHobbies collections. These default objects would get passed to props, should the component render before our application's state gets populated with the cat and hobby collections from our API.
						- When the actions that retrieve that data from the API are finished being handled by the reducers, and the new versions of state are pushed out to the components, the mapStateToProps function runs again, and the component re-renders with new props.
						- But wait! The constructor function will only be invoked once, not again and again every time application state changes and mapStateToProps get re-invoked. So, how will we insure that our CatPage component's internal state, which gets its cat, catHobbies and checkBoxHobbies properties from the component's props, gets updated when those props change?
						- For this, we will use the component lifecycle method componentWillReceiveProps.
						- The componentWillReceiveProps function will be invoked every time a component's props are updated by a re-invocation of the mapStateToProps function. This is the perfect place to update the CatPage's state whenever props get updated.
		
		mapDispatchToProps(dispatch, [ownProps]): dispatchProps: In addition to reading the state, container components can dispatch actions.
			- If an object is passed, each function inside it is assumed to be a Redux action creator. An object with the same function names, but with every action creator wrapped into a dispatch call so they may be invoked directly, will be merged into the component’s props.
			- If a function is passed, it will be given dispatch as the first parameter. It’s up to you to return an object that somehow uses dispatch to bind action creators in your own way. (Tip: you may use the bindActionCreators() helper from Redux.)
			- If your mapDispatchToProps function is declared as taking two parameters, it will be called with dispatch as the first parameter and the props passed to the connected component as the second parameter, and will be re-invoked whenever the connected component receives new props
			- if connect() receives any falsy value as mapDispatchToProps (undefined, null, false, 0) then the dispatch itself gets passed to the presentational component
			
		mergeProps(stateProps, dispatchProps, ownProps): props
			If specified, it is passed the result of mapStateToProps(), mapDispatchToProps(), and the parent props. 
			The plain object you return from it will be passed as props to the wrapped component. 
			You may specify this function to select a slice of the state based on props, or to bind action creators to a particular variable from props. 
			If you omit it, Object.assign({}, ownProps, stateProps, dispatchProps) is used by default.
			
			
	Passing the Store		
		The option we recommend is to use a special React Redux component called <Provider> to magically make the store available to all container components in the application without passing it explicitly. You only need to use it once when you render the root component:
		
		ReactDOM.render(
		  <Provider store={store}>
			<App />
		  </Provider>,
		  document.getElementById('root')
		)
		
		<Provider> uses the Context API but it is best to use the mapStateToProps, mapDispatchToProps functions on connect().
		
		connect()(PresentationalComponent) - this is a special case:
			- connect does not subscribe to store changes, and dispatch itself is passed as a prop to PresentationalComponent
			- could have been also written as: connect(null), connect(null, null)
		
	Reselect:
		Reselect is a memoized selector function, composed of selectors, that returns something you want in your component’s props.
		Memoisation is an optimization technique and it means storing the results of expensive function calls and returning the cached result when the same inputs occur again.
		
		In Redux, whenever an action is called anywhere in the application, all mounted & connected components call their mapStateToProps function. 
		This means every single (state --> props) mapping would be recalculated.
		This is why Reselect is awesome. It will just return the memoized result if nothing has changed.
		
		1. Selectors can compute derived data, allowing Redux to store the minimal possible state.
		2. Selectors are efficient. A selector is not recomputed unless one of its arguments change.
		3. Selectors are composable. They can be used as input to other selectors.
		
		
		API
			createSelector(...inputSelectors | [inputSelectors], resultFunc)
				Takes one or more selectors, or an array of selectors, computes their values and passes them as arguments to resultFunc.
	
	
	Async actions:
	
		Usually, for any API request you'll want to dispatch at least 3 different kinds of actions:
			- An action informing the reducers that the request began.
			- An action informing the reducers that the request finished successfully.
			- An action informing the reducers that the request failed.
			
			{ type: 'FETCH_POSTS_REQUEST' }
			{ type: 'FETCH_POSTS_FAILURE', error: 'Oops' }
			{ type: 'FETCH_POSTS_SUCCESS', response: { ... } }
			
			Multiple types leave less room for a mistake, but this is not an issue if you generate action creators and reducers with a helper library like redux-actions.
		
		Redux Thunk: Thunk Middleware
		
			A thunk is a function that wraps an expression to delay its evaluation.
			A thunk is a function returned from other function.
			By using this specific middleware, an action creator can return a function instead of an action object. This way, the action creator becomes a thunk.
		
			Redux Thunk middleware allows you to write action creators that return a function instead of an action. 
			The thunk can be used to delay the dispatch of an action, or to dispatch only if a certain condition is met. 
			The inner function receives the store methods dispatch and getState as parameters.
			The thunk middleware does not use what we return from the thunk --> 
				- As a convention we can always return a promise that represents the corresponding async operation
				- The return value of the thunk becomes the return value of dispatching the thunk (mapDispatchToProps is needed to wrap the thunk action creator with dispatching to the store)
			
				let nextNotificationId = 0
				export function showNotificationWithTimeout(text) {
				  return function (dispatch, getState) {
					// Unlike in a regular action creator, we can exit early in a thunk
					// Redux doesn’t care about its return value (or lack of it)
					if (!getState().areNotificationsEnabled) {
					  return
					}

					const id = nextNotificationId++
					dispatch(showNotification(id, text))

					setTimeout(() => {
					  dispatch(hideNotification(id))
					}, 5000)
				  }
				}
				
			Finally, how do we use the synchronous action creators we defined earlier together with network requests? The standard way to do it with Redux is to use the Redux Thunk middleware.
			
		Thunk middleware isn't the only way to orchestrate asynchronous actions in Redux:

			- You can use redux-promise or redux-promise-middleware to dispatch Promises instead of functions.
			- You can use redux-observable to dispatch Observables.
			- You can use the redux-saga middleware to build more complex asynchronous actions.
			- You can use the redux-pack middleware to dispatch promise-based asynchronous actions.
			- You can even write a custom middleware to describe calls to your API, like the real world example does.
			
		
		Middleware in general: 
			Important: if invoking the original store.dispatch(action) function from any middleware instead of the next(action):
				- it re-executes the whole middleware pipeline on that action, including the current middleware
				- this is useful for async middlewares
				- when applying the middlewares, the "applyMiddleware" from Redux reverses the provided middleware array. So the lets one in the arrays gets application 1st.
					This results in like building a shell from inside to outside:
					[1st MW]		[2ndMW]			[3rdMW]		[original dispath]
						|				|				|				|
					applied 3rd		applied 2nd		applied 1st	 dispatch to store				((1st_MW)((2nd_MW)((3rd_MW)store)))
		
			In Express, KOA, Asp.Net Core: middleware is some code you can put between the framework receiving a request, and the framework generating a response.
			In Redux it provides a third-party extension point between dispatching an action, and the moment it reaches the reducer.
			
			Naive apply middleware implementation:
				function applyMiddleware(store, middlewares) {
				  middlewares = middlewares.slice()
				  middlewares.reverse()
				  let dispatch = store.dispatch
				  middlewares.forEach(middleware =>
					dispatch = middleware(store)(dispatch)
				  )
				  return Object.assign({}, store, { dispatch })
				}
				
			The implementation of applyMiddleware() that ships with Redux is similar, but different in three important aspects:
				1. It only exposes a subset of the store API to the middleware: dispatch(action) and getState().
				2. It does a bit of trickery to make sure that if you call store.dispatch(action) from your middleware instead of next(action):
					The action will actually travel the whole middleware chain again, including the current middleware. 
					This is useful for asynchronous middleware, as we have seen previously. There is one caveat when calling dispatch during setup, described below.
				3. To ensure that you may only apply middleware once, it operates on createStore() rather than on store itself. Instead of (store, middlewares) => store, its signature is (...middlewares) => (createStore) => createStore.
				
			Stopping the Chain
				Sometimes an action doesn't need to reach the store's reducer because it doesn't update the store based on that action's type. 
				In those cases, the middleware function does not need to call the nextDispatch for that action. 
				
				function middleware(store) {
				  unsubscribeHistory = history.listen(location => {
					// a listener is attached to the history. When the
					// history changes locations, an UPDATE_LOCATION
					// action is dispatched to the store
					store.dispatch(updateLocation(location))
				  })

				  return next => action => {
					// the middleware only listens for TRANSITION actions
					// and the next middlewares do not care about this action, not even the reducers (in fact, they do not know about this action because it is React Router v4 specific) --> do not pass TRANSITION actions down the chain
					if (action.type !== TRANSITION) {
					  // pass it down the action to the chain to make possible for it to reach the root reducer
					  return next(action)
					}
					// when there is a TRANSITION action the middleware
					// calls a history function to update the location
					history[action.payload.method](action.payload.arg)
					// the middleware doesn't bother passing the TRANSITION
					// action down the middleware chain, since no reducer
					// will update the state of the store based on it
				  }
				}
				
			
			Good explanation about the signature: You may have noticed that middleware functions look a bit confusing. It's a function, that returns a function, that returns a function.
				const logger = store => dispatch => action => {
				  return dispatch(action)
				}
				
				Forget about its strange look. Think of it as a single function.
					function logger (store, dispatch, action) {  
					
				Having them as functions-that-return-functions makes for something interesting: it breaks the middleware into 3 steps that are applied separately.
					const logger = function (store) {
					  // This function runs on createStore().
					  // It returns a decorator for dispatch().
					  // You can get store.getState() here.
					  return function (dispatch) {
						// This function runs on createStore() too.
						// This returns a new dispatch() function to
						// replace the old one.
						return function (action) {
						  // This runs every dispatch().
						}
					  }
					}
					Most middleware will not need this, but the Redux docs has examples when this can be useful.
					
				- Middleware are Redux plugins you can attach to your store.
					createStore(reducer, {}, applyMiddleware(logger, thunk))
					
				- They give dispatch() more powers. (enhance it via higher-order functions)
					store.dispatch({ type: 'SAVE' })     	Normal
					store.dispatch(fetch('/data.json'))	  	Promises
					store.dispatch(() => {  })     F		unctions/thunks
					store.dispatch()               			...and more
					
				- You can use middleware to write side effects to actions.
					const middleware = store => dispatch => action => {
					  if (action.type === 'FETCH') {
						doSomethingDifferent()
					  }
					  dispatch(action)
					}
					
				
	Redux Observable
	
		Epic: a function that takes a stream of all actions dispatched and returns a stream of new actions to dispatch.
			"actions in, actions out" - other actions out
			It is a function which takes a stream of actions and returns a stream of actions.
			
			When defining the epics I'm just setting up the pipeline, the setup is executed exactly once during the application boot.
			Whenever an action gets dispatched, AFTER it went through the reducers it will reach my epic pipeline. 
			If the epic maps it to another action, then it will be dispatched again to the store, calling my reducers then my epics again.
			So the newly dispatched action 1st reaches the reducers and after that my epics. To escape this the epic pipeline just do not match it (ofType is not true, does not match to any action.type).
			
			An observable can be mapped to either a redux action (use .map() method) or to an array of redux actions (use .mergeMap() method).
			
		Workflow:
			1. calling store.dispatch(action)
			2. reducers receive the action		--> so the pipeline goes to the "handler", the last and original dispatch function gets invoked
			3. epics receive the action			--> only when "going back" in the pipeline (state has been updated by the reducers) receives the epic the action
				3.a) if the epic does not map it to another action then we are finished
				3.b) if the epic maps it to another action -use .map()- (or to an array of actions -use .mergeMap()-) 
					then the new action (action out) gets dispatched by the epicMiddleware under the hood via store.dispatch(action) --> and we go to 2.
					--> reducers receive the new action and after handling it (synchronously ofc) the epic gets invoked again
					
		action$.ofType(FETCH_USER)
			.mergeMap(action =>
			  ajax.getJSON(`/api/users/${action.payload}`)				using an inner observable: so if the ajax request fails it does not bring the whole epic pipeline down if catching the error
				.map(response => fetchUserFulfilled(response))
				.takeUntil(action$.ofType(FETCH_USER_CANCELLED))
				.catch(err => Observable.of(defaultUser))				catch the possible error, do not let them propagate to the outer observable resulting in briging the epic pipeline down
			);
			
		export const loginAsync = createEpic<AccountEpic>(actions$ =>
		  actions$.ofType(ActionTypes.Login).switchMap(action => {
			const { userName, password, mode } = action.payload;
			return Observable.concat(
			
			  // Observable maps to an action
			  Observable.of(setLoginResult(loading())),
			  
			  // Observable maps to an array of actions --> can be an empty array as well (with an empty array no redux actions gets dispatched after the Observable get completed)
			  Observable.from([setLoginResult(loading())]),
			  
			  // Observable maps to an empty array which means no actions need to be performed after completion
			  .mergeMap(() => []);
			  
			  // Observable maps to an action, using error handling
			  AccountApi.login({
				userName,
				password,
				loginMode: mode
			  })
				.map(([accountInfo, languageSettings]) =>
				  setCurrentUser(loaded(serverUserInfoToUser({ ...accountInfo, ...languageSettings })))
				)
				.catch((err: AjaxError) =>
				  Observable.of(setLoginResult(error({ errorCode: err.response.errorCodeCode })))
				)
			);
		  })
		);
				

ES6:
	computed property name: 
		this.setState({
		  [name]: value
		});
		It is equivalent to this ES5 code:
		var partialState = {};
		partialState[name] = value;
		this.setState(partialState);
		
		
	Data change with mutation
		var player = {score: 1, name: 'Jeff'};
		player.score = 2;
		// Now player is {score: 2, name: 'Jeff'}
		
	Data change without mutation
		var player = {score: 1, name: 'Jeff'};

		var newPlayer = Object.assign({}, player, {score: 2});
		// Now player is unchanged, but newPlayer is {score: 2, name: 'Jeff'}

		// Or if you are using object spread syntax proposal, you can write:
		var newPlayer = {...player, {score: 2}};
		
		
	Currying: these 2 are equivalent:
		function logger(store) {
		  return function wrapDispatchToAddLogging(next) {
			return function dispatchAndLog(action) {
			  console.log('dispatching', action)
			  let result = next(action)
			  console.log('next state', store.getState())
			  return result
			}
		  }
		}
		
		const logger = store => next => action => {
		  console.log('dispatching', action)
		  let result = next(action)
		  console.log('next state', store.getState())
		  return result
		}
		
		
TypeScript:
	import { ComponentClass, ReactChild } from "react";
		ComponentClass: 	e.g.: Component		- so this is a class and the callee instantiates it (props gets specified by the callee) - used in HOC patterns
		ReactChild: 		e.g.: <Component /> - so this is a component instance (props specified by the caller)
		
		export interface Button {
		  component: ComponentClass;
		  content: string | ReactChild;
		  key: string | number;
		  options?: object;
		}
		
		import classnames from "classnames";
		
		const button: Button =  {
			component: Button,
			content: (
			  <Icon icon="notification" size={<Medium />} className={classnames("Button", className, { "Button--primary": primary })} {...rest}>
				<span>Peter</span>
				{' '}
				<img src={...} />
			  </Icon>
			),
			key: "notifications",
			options: {
			  className: "Button--no_padding",
			  onClick: () => ({})
			}
		}



Goode examples:

	1.
		<div className="Header__right Layout__cell Layout__cell--tight Layout__cell--align-middle">
			{buttons.map(button => (
			  <button.component key={button.key} {...button.options}>
				{button.content}
			  </button.component>
			))}
		</div>
		vs
		<div className="Header__right Layout__cell Layout__cell--tight Layout__cell--align-middle">
            {buttons.map((button: ButtonInterface) => (
              React.createElement(button.component, { key: button.key, ...button.options }, button.content);
            ))}
        </div>

	2.
		export default class Button extends React.PureComponent<Props> {
		  render() {
			const { className, children, primary, ...rest } = this.props;
			return (
			  <button className={classnames("Button", className, { "Button--primary": primary })} {...rest}>		// notice how we pass all other parameters down to the react button representing a DOM button
				{children}
			  </button>
			);
		  }
		}
		
		usage:
		<Button key={index} {...button.options} className={"Button--primary"} onClick={this.handleClick}>
			{button.children}
		</Button>
		
	Epics:
		export const updateLoggingLevelAsync = createEpic<SecurityEpic>(actions$ =>
		  actions$
			.ofType(ActionTypes.UpdateLoggingLevel)
			.switchMap(action => SecurityApi.updateLoggingLevel(action.payload.loggingLevel))
			.map(() => setUpdateLoggingLevelOpState(OperationState.Default))
		);
		
		
		
		type AccountEpic = Epic<Action, AppState, any, ReduxAction>;

		export const whoAmIAsync = createEpic<AccountEpic>(actions$ =>
		  actions$.ofType(ActionTypes.WhoAmI).switchMap(() =>
			Observable.concat(
			  Observable.of(setCurrentUser(loading())),
			  AccountApi.whoAmI()
				.mergeMap(response => [
				  setServerConfig(response.serverConfig),
				  setCurrentUser(loaded(accountInfoToUser(response.accountInfo)))
				])
				.catch(() => Observable.of(setCurrentUser(error())))
			)
		  )
		);

		export const loginAsync = createEpic<AccountEpic>(actions$ =>
		  actions$.ofType(ActionTypes.Login).switchMap(action => {
			const { userName, password, mode } = action.payload;
			return Observable.concat(
			  Observable.of(setLoginResult(loading())),
			  AccountApi.login({
				userName,
				password,
				loginMode: mode
			  })
				.map(info => setCurrentUser(loaded(accountInfoToUser(info))))
				.catch((err: AjaxError) =>
				  Observable.of(setLoginResult(error({ errorCode: err.response.errorCodeCode })))
				)
			);
		  })
		);

		export const logoutAsync = createEpic<AccountEpic>(actions$ =>
		  actions$.ofType(ActionTypes.Logout).switchMap(() =>
			AccountApi.logout()
			  .map(() => setCurrentUser(loaded({ isLoggedIn: false })))
			  .catch(() => Observable.of(setCurrentUser(error())))
		  )
		);

		export const setCurrentUserAsync = createEpic<AccountEpic>(actions$ =>
		  actions$.ofType(ActionTypes.SetCurrentUser).map(() => setLoginResult(loaded({})))
		);

		export const loadBroadcastMessagesAsync = createEpic<AccountEpic>(actions$ =>
		  actions$.ofType(ActionTypes.LoadActiveBroadcastMessages).switchMap(() => {
			return BroadcastApi.listActiveBroadcastMessages()
			  .map(messages => setBroadcastMessages(loaded(messages.map(BroadcastMessage.fromServer))))
			  .catch((err: AjaxError) =>
				Observable.of(setBroadcastMessages(error({ errorCode: err.response.errorCodeCode })))
			  );
		  })
		);
		
	Lifecycle hooks:

		componentWillReceiveProps vs componentWillUpdate:

			componentWillReceiveProps is called before componentWillUpdate in React's update lifecycle. You are right that componentWillReceiveProps allows you to call setState. On the other hand componentWillUpdate is a callback to use when you need to respond to a state change.
			
			So the default workflow for the parent-child component relationship would be the following:
				- Parent passes new props to the child
				- Child handles new props in 'componentWillReceiveProps', calls setState if necessary
				- Child handles new state in 'componentWillUpdate' - but if your component is stateful, handling props in 'componentWillReceiveProps' will be enough.
			
			
		componentDidUpdate:
			componentDidUpdate(prevProps) {
				// only initiate webservice request if the filter in the props has changed!
				if(this.props.filter !== prevProps.filter) {
					fetchTodos(this.props.filter).then(todos => this.setState({todos}));
				}
			}
			
	Redux:
		useful npm packages:
			- redux-observable: to dispatch Observables
			- redux-promise: adds support for dispatching functions that return promises
			- redux-thunk: adds a middleware to support dispatching thunks (functions returned from other functions)
			- redux-logger: logging middleware
			- normalizr: normalize deeply nested api objects and returning nested entities with their IDs, gathered in dictionaries
			
			
			
Hooks:
	- Hooks are a new feature proposal that lets you use state and other React features (Lifecycle hooks) without writing a class.
	- Completely opt-in.
	- 100% backwards-compatible.
	- There are no plans to remove classes from React.
	- Hooks don’t replace your knowledge of React concepts.
		Instead, Hooks provide a more direct API to the React concepts you already know: props, state, context, refs, and lifecycle. As we will show later, Hooks also offer a new powerful way to combine them.
	- Hooks are functions that let you “hook into” React state and lifecycle features from function components.
	- Their names always start with use.
	- Hooks don’t work inside classes — they let you use React without classes.
	
	
	- State Hook
		- The only argument to useState is the initial state.
		- It retrns an array: the initial state and its updater function.
		- However, unlike this.setState in a class, updating a state variable always replaces it instead of merging it.
	- Effect Hook
		You’ve likely performed data fetching, subscriptions, or manually changing the DOM from React components before. 
		We call these operations “side effects” (or “effects” for short) because they can affect other components and can’t be done during rendering.
		The Effect Hook, useEffect, adds the ability to perform side effects from a function component. 
		It serves the same purpose as componentDidMount, componentDidUpdate, and componentWillUnmount in React classes, but unified into a single API. 
		Data fetching, setting up a subscription, and manually changing the DOM in React components are all examples of side effects.
		You can think of useEffect Hook as componentDidMount, componentDidUpdate, and componentWillUnmount combined
		
		Effects Without Cleanup
			Sometimes, we want to run some additional code after React has updated the DOM. Network requests, manual DOM mutations, and logging are common examples of effects that don’t require a cleanup. 
			We say that because we can run them and immediately forget about them. Let’s compare how classes and Hooks let us express such side effects.
			What does useEffect do? By using this Hook, you tell React that your component needs to do something after render. React will remember the function you passed (we’ll refer to it as our “effect”), 
				and call it later after performing the DOM updates.
			Why is useEffect called inside a component? Placing useEffect inside the component lets us access the count state variable (or any props) right from the effect. 
				We don’t need a special API to read it — it’s already in the function scope. Hooks embrace JavaScript closures and avoid introducing React-specific APIs where JavaScript already provides a solution.
			Does useEffect run after every render? Yes! By default, it runs both after the first render and after every update. (We will later talk about how to customize this.) 
				Instead of thinking in terms of “mounting” and “updating”, you might find it easier to think that effects happen “after render”. 
				React guarantees the DOM has been updated by the time it runs the effects.
			Experienced JavaScript developers might notice that the function passed to useEffect is going to be different on every render. This is intentional. 
				In fact, this is what lets us read the count value from inside the effect without worrying about it getting stale. Every time we re-render, we schedule a different effect, replacing the previous one. 
				In a way, this makes the effects behave more like a part of the render result — each effect “belongs” to a particular render.
			Unlike componentDidMount or componentDidUpdate, effects scheduled with useEffect don’t block the browser from updating the screen. 
				This makes your app feel more responsive. The majority of effects don’t need to happen synchronously. 
				In the uncommon cases where they do (such as measuring the layout), there is a separate useLayoutEffect Hook with an API identical to useEffect.
				
		Effects with Cleanup
			Earlier, we looked at how to express side effects that don’t require any cleanup. However, some effects do. 
				For example, we might want to set up a subscription to some external data source. In that case, it is important to clean up so that we don’t introduce a memory leak! 
				Let’s compare how we can do it with classes and with Hooks.
			If your effect returns a function, React will run it when it is time to clean up
			When exactly does React clean up an effect? React performs the cleanup when the component unmounts. 
				However, as we learned earlier, effects run for every render and not just once. 
				This is why React also cleans up effects from the previous render before running the effects next time. 
		
		We’ve learned that useEffect lets us express different kinds of side effects after a component renders. Some effects might require cleanup so they return a function
		Tip: Use Multiple Effects to Separate Concerns
		Hooks lets us split the code based on what it is doing rather than a lifecycle method name. React will apply every effect used by the component, in the order they were specified.
		
		Explanation: Why Effects Run on Each Update
			If you’re used to classes, you might be wondering why the effect cleanup phase happens after every re-render, and not just once during unmounting.
			We introduced an example FriendStatus component that displays whether a friend is online or not. Our class reads friend.id from this.props, subscribes to the friend status after the component mounts, and unsubscribes during unmounting.
			But what happens if the friend prop changes while the component is on the screen? Our component would continue displaying the online status of a different friend. This is a bug. 
			We would also cause a memory leak or crash when unmounting since the unsubscribe call would use the wrong friend ID.
			In a class component, we would need to add componentDidUpdate to handle this case.
				 componentDidMount() {
					ChatAPI.subscribeToFriendStatus(
					  this.props.friend.id,
					  this.handleStatusChange
					);
				  }

				  componentDidUpdate(prevProps) {
					// Unsubscribe from the previous friend.id
					ChatAPI.unsubscribeFromFriendStatus(
					  prevProps.friend.id,
					  this.handleStatusChange
					);
					// Subscribe to the next friend.id
					ChatAPI.subscribeToFriendStatus(
					  this.props.friend.id,
					  this.handleStatusChange
					);
				  }

				  componentWillUnmount() {
					ChatAPI.unsubscribeFromFriendStatus(
					  this.props.friend.id,
					  this.handleStatusChange
					);
				  }
			Forgetting to handle componentDidUpdate properly is a common source of bugs in React applications.
			Now consider the version of this component that uses Hooks:
				function FriendStatus(props) {
				  // ...
				  useEffect(() => {
					ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
					return () => {
					  ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
					};
				  });
			It doesn’t suffer from this bug. (But we also didn’t make any changes to it.)
			There is no special code for handling updates because useEffect handles them by default. It cleans up the previous effects before applying the next effects.
				// Mount with { friend: { id: 100 } } props
				ChatAPI.subscribeToFriendStatus(100, handleStatusChange);     // Run first effect

				// Update with { friend: { id: 200 } } props
				ChatAPI.unsubscribeFromFriendStatus(100, handleStatusChange); // Clean up previous effect
				ChatAPI.subscribeToFriendStatus(200, handleStatusChange);     // Run next effect

				// Update with { friend: { id: 300 } } props
				ChatAPI.unsubscribeFromFriendStatus(200, handleStatusChange); // Clean up previous effect
				ChatAPI.subscribeToFriendStatus(300, handleStatusChange);     // Run next effect

				// Unmount
				ChatAPI.unsubscribeFromFriendStatus(300, handleStatusChange); // Clean up last effect
			This behavior ensures consistency by default and prevents bugs that are common in class components due to missing update logic.
			
			Tip: Optimizing Performance by Skipping Effects
				In some cases, cleaning up or applying the effect after every render might create a performance problem. 
				In class components, we can solve this by writing an extra comparison with prevProps or prevState inside componentDidUpdate
					componentDidUpdate(prevProps, prevState) {
					  if (prevState.count !== this.state.count) {
						document.title = `You clicked ${this.state.count} times`;
					  }
					}
				This requirement is common enough that it is built into the useEffect Hook API. You can tell React to skip applying an effect if certain values haven’t changed between re-renders. 
					To do so, pass an array as an optional second argument to useEffect:
						useEffect(() => {
						  document.title = `You clicked ${count} times`;
						}, [count]); // Only re-run the effect if count changes
				In the example above, we pass [count] as the second argument. What does this mean? If the count is 5, and then our component re-renders with count still equal to 5, 
					React will compare [5] from the previous render and [5] from the next render. Because all items in the array are the same (5 === 5), React would skip the effect. That’s our optimization.
				When we render with count updated to 6, React will compare the items in the [5] array from the previous render to items in the [6] array from the next render. 
					This time, React will re-apply the effect because 5 !== 6. If there are multiple items in the array, React will re-run the effect even if just one of them is different.
				This also works for effects that have a cleanup phase:
					useEffect(() => {
					  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
					  return () => {
						ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
					  };
					}, [props.friend.id]); // Only re-subscribe if props.friend.id changes
					
				If you use this optimization, make sure the array includes any values from the outer scope that change over time and that are used by the effect.
					Otherwise, your code will reference stale values from previous renders.
				If you want to run an effect and clean it up only once (on mount and unmount), you can pass an empty array ([]) as a second argument. 
					This tells React that your effect doesn’t depend on any values from props or state, so it never needs to re-run. 
					While passing [] is closer to the familiar componentDidMount and componentWillUnmount mental model, we suggest not making it a habit because it often leads to bugs, as discussed above. 
					Don’t forget that React defers running useEffect until after the browser has painted, so doing extra work is less of a problem.
					
	- useReducer hook:
		Reducers are very convenient to test in isolation, and scale to express complex update logic. You can further break them apart into smaller reducers if necessary. However, you might also enjoy the benefits of using React local state, or might not want to install another library.
		So what if we could write a useReducer Hook that lets us manage the local state of our component with a reducer? A simplified version of it might look like this:
			
			
				
	Rules of Hooks
		Hooks are JavaScript functions, but they impose two additional rules:
			- Only call Hooks at the top level. 
				Don’t call Hooks inside loops, conditions, or nested functions.
				By following this rule, you ensure that Hooks are called in the same order each time a component renders. 
				That’s what allows React to correctly preserve the state of Hooks between multiple useState and useEffect calls.
			- Only call Hooks from React function components. 
				Don’t call Hooks from regular JavaScript functions. (There is just one other valid place to call Hooks — your own custom Hooks.)
				Instead you can:
					- Call Hooks from React function components.
					- Call Hooks from custom Hooks
					
		So how does React know which state corresponds to which useState call? The answer is that React relies on the order in which Hooks are called.
			// ------------
			// First render
			// ------------
			useState('Mary')           // 1. Initialize the name state variable with 'Mary'
			useEffect(persistForm)     // 2. Add an effect for persisting the form
			useState('Poppins')        // 3. Initialize the surname state variable with 'Poppins'
			useEffect(updateTitle)     // 4. Add an effect for updating the title

			// -------------
			// Second render
			// -------------
			useState('Mary')           // 1. Read the name state variable (argument is ignored)
			useEffect(persistForm)     // 2. Replace the effect for persisting the form
			useState('Poppins')        // 3. Read the surname state variable (argument is ignored)
			useEffect(updateTitle)     // 4. Replace the effect for updating the title
			
		As long as the order of the Hook calls is the same between renders, React can associate some local state with each of them. But what happens if we put a Hook call (for example, the persistForm effect) inside a condition?
			  // 🔴 We're breaking the first rule by using a Hook in a condition
			  if (name !== '') {
				useEffect(function persistForm() {
				  localStorage.setItem('formData', name);
				});
			  }
		This is why Hooks must be called on the top level of our components. If we want to run an effect conditionally, we can put that condition inside our Hook:
			useEffect(function persistForm() {
				// 👍 We're not breaking the first rule anymore
				if (name !== '') {
				  localStorage.setItem('formData', name);
				}
			});
		Note that you don’t need to worry about this problem if you use the provided lint rule.

			
	Custom Hooks
		Sometimes, we want to reuse some stateful logic between components. 
		Traditionally, there were two popular solutions to this problem: higher-order components and render props. 
		Custom Hooks let you do this, but without adding more components to your tree.
		
		Custom Hooks are more of a convention than a feature. If a function’s name starts with ”use” and it calls other Hooks, we say it is a custom Hook. 
		The useSomething naming convention is how our linter plugin is able to find bugs in the code using Hooks.
		
		Finally, we’re ready to learn about writing custom Hooks! Custom Hooks let you combine Hooks provided by React into your own abstractions, and reuse common stateful logic between different components.
		
		Building your own Hooks lets you extract component logic into reusable functions.
		Traditionally in React, we’ve had two popular ways to share stateful logic between components: render props and higher-order components. 
			We will now look at how Hooks solve many of the same problems without forcing you to add more components to the tree.
		A custom Hook is a JavaScript function whose name starts with ”use” and that may call other Hooks. For example, useFriendStatus below is our first custom Hook:
			import { useState, useEffect } from 'react';

			function useFriendStatus(friendID) {
			  const [isOnline, setIsOnline] = useState(null);

			  function handleStatusChange(status) {
				setIsOnline(status.isOnline);
			  }

			  useEffect(() => {
				ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);
				return () => {
				  ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);
				};
			  });

			  return isOnline;
			}
		Unlike a React component, a custom Hook doesn’t need to have a specific signature. We can decide what it takes as arguments, and what, if anything, it should return. 
			In other words, it’s just like a normal function. Its name should always start with use so that you can tell at a glance that the rules of Hooks apply to it.
		Using the hook:
			function FriendStatus(props) {
			  const isOnline = useFriendStatus(props.friend.id);

			  if (isOnline === null) {
				return 'Loading...';
			  }
			  return isOnline ? 'Online' : 'Offline';
			}
		Custom Hooks are a convention that naturally follows from the design of Hooks, rather than a React feature.
		Do I have to name my custom Hooks starting with “use”? Please do. This convention is very important. 
			Without it, we wouldn’t be able to automatically check for violations of rules of Hooks because we couldn’t tell if a certain function contains calls to Hooks inside of it.
		Do two components using the same Hook share state? No. Custom Hooks are a mechanism to reuse stateful logic (such as setting up a subscription and remembering the current value), 
			but every time you use a custom Hook, all state and effects inside of it are fully isolated.
		How does a custom Hook get isolated state? Each call to a Hook gets isolated state. Because we call useFriendStatus directly, from React’s point of view our component just calls useState and useEffect. 
			And as we learned earlier, we can call useState and useEffect many times in one component, and they will be completely independent.
			
		Tip: Pass Information Between Hooks
			Since Hooks are functions, we can pass information between them.
				const friendList = [
				  { id: 1, name: 'Phoebe' },
				  { id: 2, name: 'Rachel' },
				  { id: 3, name: 'Ross' },
				];

				function ChatRecipientPicker() {
				  const [recipientID, setRecipientID] = useState(1);
				  const isRecipientOnline = useFriendStatus(recipientID);

				  return (
					<>
					  <Circle color={isRecipientOnline ? 'green' : 'red'} />
					  <select
						value={recipientID}
						onChange={e => setRecipientID(Number(e.target.value))}
					  >
						{friendList.map(friend => (
						  <option key={friend.id} value={friend.id}>
							{friend.name}
						  </option>
						))}
					  </select>
					</>
				  );
				}

	The state of these components is completely independent. Hooks are a way to reuse stateful logic, not state itself. 
	In fact, each call to a Hook has a completely isolated state — so you can even use the same custom Hook twice in one component.
	
	Hook types:
		Basic Hooks
			useState
			useEffect
			useContext
		Additional Hooks
			useReducer
			useCallback
			useMemo
			useRef
			useImperativeMethods
			useMutationEffect
			useLayoutEffect
			
		- useState
			If the new state is computed using the previous state, you can pass a function to setState. The function will receive the previous value, and return an updated value. 
			function Counter({initialCount}) {
			  const [count, setCount] = useState(initialCount);
			  return (
				<>
				  Count: {count}
				  <button onClick={() => setCount(0)}>Reset</button>
				  <button onClick={() => setCount(prevCount => prevCount + 1)}>+</button>
				  <button onClick={() => setCount(prevCount => prevCount - 1)}>-</button>
				</>
			  );
			}
			Note:
				Unlike the setState method found in class components, useState does not automatically merge update objects. You can replicate this behavior by combining the function updater form with object spread syntax:

				setState(prevState => {
				  // Object.assign would also work
				  return {...prevState, ...updatedValues};
				});
				Another option is useReducer, which is more suited for managing state objects that contain multiple sub-values.
				
		- useEffect:
			Accepts a function that contains imperative, possibly effectful code.
			Mutations, subscriptions, timers, logging, and other side effects are not allowed inside the main body of a function component (referred to as React’s render phase). 
				Doing so will lead to confusing bugs and inconsistencies in the UI.
			Instead, use useEffect. The function passed to useEffect will run after the render is committed to the screen. Think of effects as an escape hatch from React’s purely functional world into the imperative world.
			By default, effects run after every completed render, but you can choose to fire it only when certain values have changed.
			
			Cleaning up an effect
				Often, effects create resources that need to be cleaned up before the component leaves the screen, such as a subscription or timer ID. To do this, the function passed to useEffect may return a clean-up function. 
				The clean-up function runs before the component is removed from the UI to prevent memory leaks. Additionally, if a component renders multiple times (as they typically do), the previous effect is cleaned up before executing the next effect.
			
			Timing of effects
				Unlike componentDidMount and componentDidUpdate, the function passed to useEffect fires after layout and paint, during a deferred event. 
					This makes it suitable for the many common side effects, like setting up subscriptions and event handlers, because most types of work shouldn’t block the browser from updating the screen.
					
				However, not all effects can be deferred. For example, a DOM mutation that is visible to the user must fire synchronously before the next paint so that the user does not perceive a visual inconsistency. 
					For these types of effects, React provides two additional Hooks: 
						- useMutationEffect and 
						- useLayoutEffect
					These Hooks have the same signature as useEffect, and only differ in when they are fired.
				Although useEffect is deferred until after the browser has painted, it’s guaranteed to fire before any new renders. React will always flush a previous render’s effects before starting a new update.
				
			Conditionally firing an effect
				The default behavior for effects is to fire the effect after every completed render. That way an effect is always recreated if one of its inputs changes.
				However, this may be overkill in some cases, like the subscription example from the previous section. We don’t need to create a new subscription on every update, only if the source props has changed.
				To implement this, pass a second argument to useEffect that is the array of values that the effect depends on. Our updated example now looks like this:
					useEffect(
					  () => {
						const subscription = props.source.subscribe();
						return () => {
						  subscription.unsubscribe();
						};
					  },
					  [props.source],
					);
					
				Now the subscription will only be recreated when props.source changes.
				Passing in an empty array [] of inputs tells React that your effect doesn’t depend on any values from the component, so that effect would run only on mount and unmount, never on updates.
				
		- useContext
			lets you subscribe to React context without introducing nesting
				const context = useContext(Context);
			Accepts a context object (the value returned from React.createContext) and returns the current context value, as given by the nearest context provider for the given context.
			When the provider updates, this Hook will trigger a rerender with the latest context value.
		
		- useReducer		
			lets you manage local state of complex components with a reducer
			const [state, dispatch] = useReducer(reducer, initialState);
			An alternative to useState. Accepts a reducer of type (state, action) => newState, and returns the current state paired with a dispatch method. (If you’re familiar with Redux, you already know how this works.)
				const initialState = {count: 0};
				
				function reducer(state, action) {
				  switch (action.type) {
					case 'reset':
					  return initialState;
					case 'increment':
					  return {count: state.count + 1};
					case 'decrement':
					  return {count: state.count - 1};
				  }
				}

				function Counter({initialCount}) {
				  const [state, dispatch] = useReducer(reducer, initialState);
				  return (
					<>
					  Count: {state.count}
					  <button onClick={() => dispatch({type: 'reset'})}>
						Reset
					  </button>
					  <button onClick={() => dispatch({type: 'increment'})}>+</button>
					  <button onClick={() => dispatch({type: 'decrement'})}>-</button>
					</>
				  );
				}
				
			Lazy initialization
				useReducer accepts an optional third argument, initialAction. If provided, the initial action is applied during the initial render. This is useful for computing an initial state that includes values passed via props:
					const initialState = {count: 0};

					function reducer(state, action) {
					  switch (action.type) {
						case 'reset':
						  return {count: action.payload};
						case 'increment':
						  return {count: state.count + 1};
						case 'decrement':
						  return {count: state.count - 1};
					  }
					}

					function Counter({initialCount}) {
					  const [state, dispatch] = useReducer(
						reducer,
						initialState,
						{type: 'reset', payload: initialCount},
					  );

					  return (
						<>
						  Count: {state.count}
						  <button
							onClick={() => dispatch({type: 'reset', payload: initialCount})}>
							Reset
						  </button>
						  <button onClick={() => dispatch({type: 'increment'})}>+</button>
						  <button onClick={() => dispatch({type: 'decrement'})}>-</button>
						</>
					  );
					}
					
			useReducer is usually preferable to useState when you have complex state logic that involves multiple sub-values. 
			It also lets you optimize performance for components that trigger deep updates because you can pass dispatch down instead of callbacks.
			
		- useCallback
			const memoizedCallback = useCallback(
			  () => {
				doSomething(a, b);
			  },
			  [a, b],
			);
			
			Returns a memoized callback.
			Pass an inline callback and an array of inputs. useCallback will return a memoized version of the callback that only changes if one of the inputs has changed. 
			This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders (e.g. shouldComponentUpdate).
			
			useCallback(fn, inputs) is equivalent to useMemo(() => fn, inputs).
			
		- useMemo
			const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
			Returns a memoized value.
			Pass a “create” function and an array of inputs. useMemo will only recompute the memoized value when one of the inputs has changed. This optimization helps to avoid expensive calculations on every render.
			If no array is provided, a new value will be computed whenever a new function instance is passed as the first argument. (With an inline function, on every render.)
			
		- useRef
			const refContainer = useRef(initialValue);
			useRef returns a mutable ref object whose .current property is initialized to the passed argument (initialValue). The returned object will persist for the full lifetime of the component.
			A common use case is to access a child imperatively:
				function TextInputWithFocusButton() {
				  const inputEl = useRef(null);
				  const onButtonClick = () => {
					// `current` points to the mounted text input element
					inputEl.current.focus();
				  };
				  return (
					<>
					  <input ref={inputEl} type="text" />
					  <button onClick={onButtonClick}>Focus the input</button>
					</>
				  );
				}
				
		- useImperativeMethods
			useImperativeMethods(ref, createInstance, [inputs])
			useImperativeMethods customizes the instance value that is exposed to parent components when using ref. As always, imperative code using refs should be avoided in most cases. useImperativeMethods should be used with forwardRef:
			
			function FancyInput(props, ref) {
			  const inputRef = useRef();
			  useImperativeMethods(ref, () => ({
				focus: () => {
				  inputRef.current.focus();
				}
			  }));
			  return <input ref={inputRef} ... />;
			}
			FancyInput = forwardRef(FancyInput);
			
			In this example, a parent component that renders <FancyInput ref={fancyInputRef} /> would be able to call fancyInputRef.current.focus().8
			
		- useMutationEffect
			The signature is identical to useEffect, but it fires synchronously during the same phase that React performs its DOM mutations, before sibling components have been updated. Use this to perform custom DOM mutations.
			Prefer the standard useEffect when possible to avoid blocking visual updates.
		
		- useLayoutEffect
			The signature is identical to useEffect, but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. 
			Updates scheduled inside useLayoutEffect will be flushed synchronously, before the browser has a chance to paint.
			Prefer the standard useEffect when possible to avoid blocking visual updates.
			
			Tip: If you’re migrating code from a class component, useLayoutEffect fires in the same phase as componentDidMount and componentDidUpdate, so if you’re unsure of which effect Hook to use, it’s probably the least risky.