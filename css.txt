Grid layout:
	grid:
	
		grid-template-columns: 1fr 20px 10% 2fr;			/*4 explicit columns*/		- fr = fragment
		grid-template-rows: 100px 40px;						/*2 explicit rows*/
		grid-gap: 15px;				// space between columns and rows
		grid-auto-flow: column;		/*default is row. New grid items will be put in the next column instead of the next row*/
		
		grid-auto-columns: 1fr;		/*implicit columns will have the same width, trying to fill all the available spaces*/
		grid-auto-rows: 50px;		/*implicit rows become 50px high*/
		
		grid-template-columns: 200px auto 200px;	/*center column will be the same wide as its content*/
		grid-template-columns: 200px 1fr 200px;		/*center column will take up all the remaining space*/
		grid-template-columns: 2fr repeat(3, 1ft);	// 4 columns, the 1st grows twice as the other 3
		grid-template-columns: minmax(200px, 300px) 300px minmax(50px, auto);	// three columns: 1st is 200px min and 300px max, 2nd is 300px, 3rd is 50px min and maximum the same wide as its content
		
		
		
		grid-template-columns: 1fr				// 1 column and it takes all the space available
		grid-auto-rows: minmax(50px, auto);		// rows became auto high (can grow to any amount based on the content) and no shorter than 50px
		
		
		
		width: 95%;
		max-width: 1000px;
		grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));		// becomes a 3 column layout. On mobile each column stacking on top of eacah other.
		
		grid-template-columns: repeat(auto-fill, 150px);				// auto fill as many 150px wide columns as possible (somewhat responsive design) - a lot of free spaces arise with this when resizing the browser.
		grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));	// auto fill as many 150px wide columns as possible and always fill the whole row. Puts empty tracks if there is not enough columns to fill the whole window.
		grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));	// auto fill as many 150px wide columns as possible and always fill the whole row. Collapses empty tracks. Always takes up all of the window's width.
		
		
	grid lines start from 1.
	
		1		2		3		4
		1------------------------
		|		|		|		|
		|		|		|		|
		2------------------------
		|		|		|		|
		|		|		|		|
		3------------------------
		
		
		header {
			grid-column-start: 1;
			grid-column-end: 3;
			
			grid-row-start: 2;
			grid-row-end: 5;
		}
		
		// use negative values to have the element fill up almost the same grid lines (no matter how many columns/rows there are), or have the element stick to the same grid line
		// negative values start from "-1" and goes in backwards order (column start is on the right, row is at the bottom)
		aside {
			grid-column-start: 1;
			grid-column-end: -1;		/*negative number means aside will span to the last column*/ --> -1 is the 1st column from the right. The rest goes like -2, -3, ...
			grid-column: 1 / -1			// shorthand: start / end
			
			grid-row-start: -3;
			grid-row-end: -1;			/*negative number means aside will span to the last column*/
			grid-row: -3 / -1			// shorthand: start / end	 --> -1 is the 1st row from the bottom. The rest goes like -2, -3, ...
		}
		
		
	Grid areas
		
		.container {
			display: grid;
			grid-template-columns: 2fr 1fr;							// 2 explicit columns
			grid-template-rows: 100px minmax(200px, 1fr) 100px;		// 3 explicit rows
			grid-gap: 10px;
			grid-template-areas:	// each string is a row, and each comma separated word becomes a column
				"header header" 	// header takes all 2 columns in the 1st row
				"main aside"		// main takes the 1st column and aside the 2nd in the 2nd row
				"footer";			// footer takes the 1st column in the 3rd row
				
				". header" 			// header takes the 2nd column, 1st one is empty (period)
				"main aside"		// main spans 2 rows: the 2nd and 3rd in the 1st column. Aside is in the 2nd row's 2nd column.
				"main footer";		// main is in the 1st, footer takes the 2nd column
		}
		
		header {
			grid-area: header;		// this is the name of the area. The <header> element itself becomes a grid area named "header". This name can be referenced in the grid's "grid-template-areas" property
		}
		main {
			grid-area: main;
		}
		aside {
			grid-area: aside;
		}
		footer {
			grid-area: footer;
		}
		
		
SVG:

	Optimization: image sprites
					<svg...>
						<symbol id="mail" viewbow="...">
							<!-- actual svg code goes here -->
							<path ... />
						</symbol>
					</svg>
					
					Usage: 	1. Include the one above in the html page
							2. <svg>
									<use xlink:href="#mail" />
							   </svg>
							   
							 
SCSS

	$btn {			// placeholder style --> when @extend-ing, it won't get into the compiled css as a .btn class
		color: red;
		
		&:after {
			clear: both;
			content: '';
			display: $my-display;		// $my-display: variable
		}
	}
	
	.btn-common {
		background: blue;
	}
	
	.btn {
		&-callout {		// &: parent selector
			@extend $btn;
		}
		&-info {
			@extend $btn;
			@extend .btn-common;
			
			&:hover {
			}
		}
		
		a {
		}
	}
	
	
	@mixin center {
		margin: 0 auto;
		width: 90%;
	}
	
	.apples {
		@include center;		// include the mixin here
	}
	
	
	Comments:
		/* ... */ 	- will appear in the compiled css
		// ...		- will be excluded in the compiled css
	
	
	
	Partials:
	
		- separate files
		- if filename starts with an underscore, then it is a partial (like _mixins.scss) --> sass compiler will ignore it and not create an _mixins.css files
		- @import 'partials/variables', 'partials/mixins'
		
	
	Functions:
		- does not output any css
		- example:
			@function divide($a, $b: $max-width) {		// $b has a default value --> not necessary to be specified
				@return ($a / $b);
			}
			
			to invoke it:
			.test {
				line-height: divide(32px, 16px);
			}
			
			@function px-to-pc($target, $context: $max-width) {
				@return ($target / $context) * 100%;
			}
			@function per-line($numberOfItems) {
				$g-pct: px-to-pc($gutter) * 2;
				$g-total: $numberOfItems * $g-pct;
				@return (100% / $numberOfItems) - $g-total;
			}
			@media (min-width: $break-s) {
				flex: 1 per-line(2);	// 2nd argument is the flex-bases itself!
			}
			@media (min-width: $break-l) {
				flex-bases: per-line(3);
			}
			
	
	Mixins:
		@mixin roundy($dim, $border: null) {
			header: $dim;
			width: $dim;
			border: $border;	// this rule gets skipped from the generated css if the caller $border does not specify $border (e.g. it is null)
		}
		
		@include roundy ($border: 4px solid white, $dim: 150px);	// named parameters: order can be swapped just like in C#
		
		
	@if:
	
		@mixin media-query($break) {
			$value: map-get($breakpoints, $break);
			$sm: map-get($breakpoints, 'sm');	// map-get function: gets the value in the $breakpoints map which has the key 'sm' associated with
		
			@if $value < $sm {
				@media (max-width: $value) {
					@content;
				}
			}
			//@else if $break == 'md' {
			//	@media (max-width: $break-md) {
			//		@content;
			//	}
			//}
			@else {
				@media (min-width: $value) {
					@content;
				}
			}
		}
		@include media-query('xs') {
			color: orange;
			@include center(90%);
		}
		
	
	Map: key-value pairs
	
		$breakpoints: (
			'xs': 575px,
			'sm': 576px,
			'md': 768px,
			'lg': 992px
		);
		
		
		
		$themes: (
			'ent': #ffffff,
			'soc': #000000,
			'games': #00ff00,
		);
		@each $theme, $color in $themes {
			.icn-#{$theme} {
				color: $color;
			}
		}
		
		@mixin themes($map) {
			@each $map-key, $map-value in $map {
				&-#{$map-key} {			// referencing the parent select (.icn in this example)
					color: $map-value;
				}
			}
		}
		.icn {
			@include themes($themes);		// will output classes like .icn-ent, .icn-soc, .icn-games
		}
		
		
	For loop:
	
		@for $i from 1 through 10 {
			.box-#{$i} {
				background-color: adjust-hue(tomato, $i * 20);
			}
		}
		
	
	While loop:
	
		$i: 6;
		@while $i > 0 {
		  .item-#{$i} { width: 2em * $i; }
		  $i: $i - 2;
		}
		
		
	Each loops: used to iterate through lists

		$teachers: ('peter', 'zsofi', 'noni', 'dori', 'flori', 'niki');
		
		@each $teacher in $teachers {
			.teacher-#{$teacher} {
				background-image: url('img/#{$teacher}.jpg');
			}
		}
		
		
	Errors and warnings
	
		@mixin mq($break) {
			$value: map-get($breakpoints, $break);
			
			@if $value == null {
				@error '`#{break}` is not a valid breakpoint.';		// stops the compiler
				@warn '`#{break}` is not a valid breakpoint.';		// outputs the message but does not stop the compiler
			}
		}