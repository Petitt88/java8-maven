**********Java***********

ClassLoaders:

There are three types of built-in Class Loaders in Java:
1. Bootstrap Class Loader – It loads JDK internal classes, typically loads rt.jar and other core classes for example java.lang.* package classes
2. Extensions Class Loader – It loads classes from the JDK extensions directory, usually $JAVA_HOME/lib/ext directory.
3. System Class Loader – It loads classes from the current classpath that can be set while invoking a program using -cp or -classpath command line options.

We use a custom classloader when we need to extend how the JVM loads the classes. By default it loads from the -classpath (from the folder of the project).
But in some cases we may want to load a class from a database or from a remote resource (through http!).

The flow of "loadClass()" is as follows:

1. Verify class name.
2. Check to see if the class requested has already been loaded.
3. Check to see if the class is a "system" class.
4. Attempt to fetch the class from the parent class loader
5. Attempt to fetch the class from this class loader's repository.
6. Define the class for the VM.
7. Resolve the class.
8. Return the class to the caller.

Always load the classes once. It's also important to keep a cache because the loadClass() method is called recursively when a class is
being resolved, and you will need to return the cached result rather than chase it down for another copy.

Classpath: contains folders (like src/main/java) and jar files. A java class is found like this:
 - if a jar contains it, it is loaded from there
 - if not, the JVM concatenates the folder path from the classpath with the "import ..." statement located in the class file. 
   The resulting path must pont to the .class file.




**********Maven**********

a plugin is a collection of goals with a general common purpose

mvn archetype:generate - plugin:goal: execute the "generate" goal of the "archetype plugin"

mvn package - Rather than a goal, this is a phase
A phase is a step in the build lifecycle, which is an ordered sequence of phases. A phase consists of plugin goals.
When a phase is given, Maven will execute every phase in the sequence up to and including the one defined. Every goal in these cases is executed.
For example, if we execute the compile phase, the phases that actually get executed are:

validate
generate-sources
process-sources
generate-resources
process-resources
compile

Lifecycles:
 - clean: cleans up artifacts created by prior builds
 - build: (and its default phases are:)	validate: validate the project is correct and all necessary information is available
										compile: compile the source code of the project
										test: test the compiled source code using a suitable unit testing framework. These tests should not require the code be packaged or deployed
										package: take the compiled code and package it in its distributable format, such as a JAR.
										integration-test: process and deploy the package if necessary into an environment where integration tests can be run
										verify: run any checks to verify the package is valid and meets quality criteria
										install: install the package into the local repository, for use as a dependency in other projects locally
										deploy: done in an integration or release environment, copies the final package to the remote repository for sharing with other developers and projects.
- site: generates site documentation for this project

An interesting thing to note is that phases and goals may be executed in sequence:
	mvn clean dependency:copy-dependencies package - This command will clean the project, copy dependencies, and package the project (executing all phases up to package, of course).

A Build Lifecycle is Made Up of Phases
A Build Phase is Made Up of Plugin Goals


To install an external jar into a project-repository:
mvn install:install-file -DlocalRepositoryPath=repo -DcreateChecksum=true -Dpackaging=jar -Dfile="lib/overall-lib-0.0.1.jar" -DgroupId=overall-lib -DartifactId=overall-lib -Dversion="0.0.1" -e

When creating a maven multi-project app (parent's packaging is "pom") it is very important to always build the parent pom.
That will build all of the modules individually and resolve the dependencies (ensuring the correct order of the build of projects).
As soon as a modules starts depending on another, that module cannot be built from its pom. The parent pom will be the only one that can build it from that point on.


Maven plugins (build and reporting) are configured by specifying a <configuration> element where the child elements of the <configuration> element 
are mapped to fields, or setters, inside your Mojo (remember that a plug-in consists of one or more Mojos where a Mojo maps to a goal). 
Say, for example, we had a Mojo that performed a query against a particular URL, with a specified timeout and list of options.
https://maven.apache.org/guides/mini/guide-configuring-plugins.html


How do you know Jackson 2 is on the classpath? 
Either run `mvn dependency:tree` or ./gradlew dependencies and you'll get a detailed tree of dependencies which shows Jackson 2.x. 
You can also see that it comes from spring-boot-starter-web.



**********Tomcat**********

tomcat-users.xml:
<role rolename="admin-gui"/>
<role rolename="manager-gui"/>
<user username="admin" password="admin" roles="admin-gui,manager-gui"/>




**********Servlet**********

Request, Response objects - created per access
Servlet itself: not per access, shared accross different threads (1 thread / user)
HttpSession: 1 session object / user, machine - user specific
ServletContext - shared accross users (application-level) - 1 instance per application

GenericService	- init(ServletConfig) - for the very 1st request only
	|
HTTPServlet		- servlet() - at every request
	|
MyServlet		- doGet, doPost (at every request)


Filter interface:

void init(FilterConfig paramFilterConfig) – When container initializes the Filter, this is the method that gets invoked. This method is called only once in the lifecycle of filter and we should initialize any resources in this method. FilterConfig is used by container to provide init parameters and servlet context object to the Filter. We can throw ServletException in this method.
doFilter(ServletRequest paramServletRequest, ServletResponse paramServletResponse, FilterChain paramFilterChain) – This is the method invoked every time by container when it has to apply filter to a resource. Container provides request and response object references to filter as argument. FilterChain is used to invoke the next filter in the chain. This is a great example of Chain of Responsibility Pattern.
void destroy() – When container offloads the Filter instance, it invokes the destroy() method. This is the method where we can close any resources opened by filter. This method is called only once in the lifetime of filter.

I can listen to events:
- ServletContextListener
- ServletContextAttributeListener
- HttpSessionListener
- HttpSessionAttributeListener




**********JSP***********

7.1 What Are Custom Tags?
	Custom tags, also known as tag extensions, are JSP elements that allow custom logic and output provided by other Java components to be inserted into JSP pages. 
	The logic provided through a custom tag is implemented by a Java object known as a tag handler. When OC4J encounters a custom tag in a JSP during translation, it generates code to obtain and 
	interact with the tag handler. Custom tags are included in a JSP page using XML syntax. Tags may or may not contain a body. Tags can also contain XML attributes that match properties in the corresponding tag handler.

With the advent of JSP 2.0, you now have two options for creating custom tags:

Tag handlers
	Tags that require the creation of tag handler classes come in two types: Classic and simple.
	Classic tag handlers have been available since JSP 1.1. Classic tags are considered somewhat cumbersome to write, in part because of the complexity of the Java interfaces used to implement each tag's corresponding tag handler class. They are also dependent on Java expressions for dynamic attribute values. However, these tag handlers are the only option if Java scriplets or expressions must be used in the tag body
	Simple tag handlers are new in JSP 2.0, and offer a much simpler lifecycle and interface than classic tag handlers. Tag bodies accept JSP expression language (EL) expressions, allowing completely script-free tag development.

Tag files
	Also new in JSP 2.0, tag files are revolutionary in that they allow tag libraries to be implemented completely in JSP or XML syntax, without the need to create and compile tag handler classes. Instead, tag files are translated into simple tag handlers by the OC4J JSP container and then compiled. Because of their ease of implementation, tag files offer an attractive alternative to writing tag handlers.

A tag file is a source file that contains a fragment of JSP code that is reusable as a custom tag. Tag files allow you to create custom tags using JSP syntax. 
Just as a JSP page gets translated into a servlet class and then compiled, a tag file gets translated into a tag handler and then compiled.


<%@ include file="header.html" %>
Static: adds the content from the value of the file attribute to the current page at translation time. 
The directive was originally intended for static layout templates, like HTML headers.

<jsp:include page="header.jsp" />
Dynamic: adds the content from the value of the page attribute to the current page at request time. 
Was intended more for dynamic content coming from JSPs.

In the latter case we can specify parameters as well:
<jsp:include page="navMenu.jsp" >
    <jsp:param name="param1" value="menu" />
</jsp:include>
${param.param1} (preferable) or request.getParameter("param1")




********Streams*********

The parallel streams use the default ForkJoinPool which by default has one less threads as you have processors, as returned by Runtime.getRuntime().availableProcessors() (so parallel streams use all your processors because they also use the main thread):
For applications that require separate or custom pools, a ForkJoinPool may be constructed with a given target parallelism level; by default, equal to the number of available processors.

Streams should be used with high caution when processing intensive computation tasks. In particular, by default, all streams will use the same ForkJoinPool, configured to use as many threads as there are cores in the computer on which the program is running.
If evaluation of one parallel stream results in a very long running task, this may be split into as many long running sub-tasks that will be distributed to each thread in the pool. From there, no other parallel stream can be processed because all threads will be occupied. So, for computation intensive stream evaluation, one should always use a specific ForkJoinPool in order not to block other streams.

List<SomeClass> list = // A list of objects
Stream<SomeClass> stream = list.parallelStream().map(this::veryLongProcessing);
Callable<List<Integer>> task = () -> stream.collect(toList());
ForkJoinPool forkJoinPool = new ForkJoinPool(4);
List<SomeClass> newList = forkJoinPool.submit(task).get();




********Java generics*********
At runtime java forgets its generic information for instance variables. But it retains that information for subclasses!

List<String> x = new ArrayList<>(); - type information gets lost!
	List<String> x = new ArrayList<>();
	Class<? extends List> clazz = x.getClass();
	ParameterizedType type = (ParameterizedType) clazz.getGenericSuperclass();
	String name = type.getTypeName();
	System.out.println(name);	// prints out java.util.AbstractList<E>...

List<String> x = new ArrayList<String>() {}; - type information is retained due to we create a generic anonymous subclass of List<String> with no overrides!
	List<String> x = new ArrayList<String>() {};
	Class<? extends List> clazz = x.getClass();
	ParameterizedType type = (ParameterizedType) clazz.getGenericSuperclass();
	String name = type.getTypeName();
	System.out.println(name);	// prints out String!
	
	This is called the "Type token pattern" - the Spring implementation is ParameterizedTypeReference<T>




**********TODO**********

1. read more JSP resources:
	- apache tiles	- check

2. JAX-RS, JAX-WS (both with and without Maven) - check

3. JDBC, JPA, Hibernate, EclipseLink examples - check

4. Spring - check

5. Unit test, jUnit, Mockito