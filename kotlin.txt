https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/index.html

stdlib interesting mappings

	let - fun <T, R> T.let(block: (T) -> R): R
		Calls the specified function block with this value as its argument and returns its result.
		val car: Car = Person("Peter").let { Car(it.name) }
		val car: Car = this.repository.findPerson(1)?.let { Car(it.name) } ?: Car("Not found")
		
	run - fun <T, R> T.run(block: T.() -> R): R
		Calls the specified function block with this value as its receiver and returns its result.
		val car: Car = Person("Peter").run { Car(this.name) }
		
		
	with - fun <T, R> with(receiver: T, block: T.() -> R): R
		Calls the specified function block with the given receiver as its receiver and returns its result.
		val car: Car = with(Person("Peter")) { Car(this.name) }
		
	run - fun <R> run(block: () -> R): R
		Calls the specified function block and returns its result.
		val car: Car = run { Car("Peter") }


	also - fun <T> T.also(block: (T) -> Unit): T
		Calls the specified function block with this value as its argument and returns this value.
		val person: Person = Person("Peter").also { println(it.name) }
		
		val persons = mutableListOf<Person>(Person("Peter")).also {
			it.add(Person("Nora"))
			it.add(Person("Niki"))
		}
		
	apply - fun <T> T.apply(block: T.() -> Unit): T
		Calls the specified function block with this value as its receiver and returns this value.
		val person: Person = Person("Peter").apply { println(name) }
		
		val persons = mutableListOf<Person>(Person("Peter")).apply { 
			add(Person("Nora"))
			this.add(Person("Niki"))
		}
		
stdlib enums

	fun test() {
		val season: Seasons = enumValueOf<Seasons>("WINTER")
		val values: Array<Seasons> = enumValues<Seasons>()
	}

	enum class Seasons {
		WINTER,
		SUMMER,
		AUTUMN,
		SPRING
	}
	
	
Tuples
	Pair, Triple
	

Arrays, Collections

	val arr = Array(10) { Person(it) }
	val arr = arrayOf(1, 2, 3)
	val a = listOf(1, 2, 3)
	val a = mutableListOf(1, 2, 3)
	val a = ArrayList<Int>()
	val a = arrayListOf(1, 2)
	
	val a = setOf(1, 2, 3)
	val a = mutableSetOf(1, 2, 3)
	val a = HashSet<Int>()
	val a = hashSetOf(1, 2)
	
	val a = mapOf(1 to "1", 2 to "2")
	val a = mutableMapOf(Pair(1, "1"), Pair(2, "2"))
	val a = hashMapOf<Int, String>()
	val a = HashMap<Int, String>()
	
	// for lazy collections
	val a = sequenceOf(1, 2, 3)
	
	// for synchronized blocks
	synchronized - fun <R> synchronized(lock: Any, block: () -> R): R
		executes the given function block while holding the monitor of the given object lock.
		synchronized(this) {
			...
		}
	
	// try-with-resources block
	use - fun <T : AutoCloseable?, R> T.use(block: (T) -> R): R
	Executes the given block function on this resource and then closes it down correctly whether an exception is thrown or not.
		File("my.txt").inputStream().bufferedReader().use {
			it.lines().forEach { }
		}
		File("my.txt").bufferedReader().use {
			it.lines().forEach { }
		}
		
	Note that the read-only types are covariant. That means, you can take a List<Rectangle> and assign it to List<Shape> assuming Rectangle inherits from Shape. This wouldn't be allowed with the mutable collection types because it would allow for failures at runtime.
	
	val items = listOf(1, 2, 3, 4)
	items.first() == 1
	items.last() == 4
	items.filter { it % 2 == 0 }   // returns [2, 4]

	val rwList = mutableListOf(1, 2, 3)
	rwList.requireNoNulls()        // returns [1, 2, 3]
	if (rwList.none { it > 6 }) println("No items above 6")  // prints "No items above 6"
	val item = rwList.firstOrNull()
	
	// groupBy example
	class InfoFromDatabase(val catId: Long, val catName: String, val coupId: Long, val couponName: String)
	class CoupInfo(val coupId: Long, val coupName: String)
	class GroupedInfo(val catId: Long, val catName: String, val coupons: Iterable<CoupInfo>)

	val infos = listOf(1L, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)
			.map { InfoFromDatabase(catId = it % 3, catName = "CatName${it % 3}", coupId = it, couponName = "CoupoName$it") }

	val res = infos.groupBy { it.catId }
			.mapKeys {
				object {
					val catId = it.key
					val catName = it.value[0].catName
				}
			}
			.mapValues { entry ->
				entry.value.map {
					object {
						val coupId = it.coupId
						val coupName = it.couponName
					}
				}
			}
			.map { GroupedInfo(it.key.catId, it.key.catName, it.value.map { c -> CoupInfo(c.coupId, c.coupName) }) }

	val resDifferently = infos.groupBy { it.catId }
			.map { GroupedInfo(it.key, it.value[0].catName, it.value.map { c -> CoupInfo(c.coupId, c.couponName) }) }
			
			
Returns and Jumps

	val s = person.name ?: return
	
	Break and Continue Labels	
		loop@ for (i in 1..100) {
			for (j in 1..100) {
				if (...) break@loop
			}
		}

	Return at Labels: returning normally from a lambda exists the entire function to the caller. However, returning from an anonymous function returns only from that function!
		fun foo() {
			ints.forEach {
				if (it == 0) return  // nonlocal return from inside lambda directly to the caller of foo()
				print(it)
			}
		}
		
		fun foo() {
			ints.forEach lit@ {
				if (it == 0) return@lit
				print(it)
			}
		}
		
		fun foo() {
			ints.forEach {
				if (it == 0) return@forEach
				print(it)
			}
		}
		
		fun foo() {
			ints.forEach(fun(value: Int) {
				if (value == 0) return  // local return to the caller of the anonymous fun, i.e. the forEach loop
				print(value)
			})
		}
		
		
Control Flow: if, when, for, while
	If Expression
		// Traditional usage 
		var max = a 
		if (a < b) max = b
		
		// As expression 
		val max = if (a > b) a else b
		
	When Expression
		when (x) {
			0, 1 -> print("x == 0 or x == 1")
			else -> print("otherwise")
		}
		when (x) {
			in 1..10 -> print("x is in the range")
			in validNumbers -> print("x is valid")
			!in 10..20 -> print("x is outside the range")
			else -> print("none of the above")
		}
		when {
			x.isOdd() -> print("x is odd")
			x.isEven() -> print("x is even")
			else -> print("x is funny")
		}
		
	For Loops
		for (item in collection) print(item)
		
		As mentioned before, for iterates through anything that provides an iterator, i.e.
			has a member- or extension-function iterator(), whose return type
				has a member- or extension-function next(), and
				has a member- or extension-function hasNext() that returns Boolean.
			All of these three functions need to be marked as operator.
			
		for (i in array.indices) {
			print(array[i])
		}
		for ((index, value) in array.withIndex()) {
			println("the element at $index is $value")
		}
		
	While Loops
		while (x > 0) {
			x--
		}
		do {
			val y = retrieveData()
		} while (y != null) // y is visible here!
		
		
Classes and Inheritance
	Constructors
	
		Primary constructors
			A class in Kotlin can have a primary constructor and one or more secondary constructors. The primary constructor is part of the class header: it goes after the class name (and optional type parameters).
			class Person internal constructor(firstName: String) {
			}
			class Person(firstName: String) {
			}
			
			The primary constructor cannot contain any code. Initialization code can be placed in initializer blocks, which are prefixed with the init keyword:

				class Customer(name: String) {
					init {
						logger.info("Customer initialized with value ${name}")
					}
				}
				
			Note that parameters of the primary constructor can be used in the initializer blocks. They can also be used in property initializers declared in the class body:

				class Customer(name: String) {
					val customerKey = name.toUpperCase()
				}
				
			In fact, for declaring properties and initializing them from the primary constructor, Kotlin has a concise syntax:
				class Person(val firstName: String, val lastName: String, var age: Int) {
					// ...
				}
			
			If the constructor has annotations or visibility modifiers, the constructor keyword is required, and the modifiers go before it:
				class Customer public @Inject constructor(name: String) { ... }
				
		Secondary Constructors
		
			The class can also declare secondary constructors, which are prefixed with constructor:
			class Person {
				constructor(parent: Person) {
					parent.children.add(this)
				}
			}
			
			If the class has a primary constructor, each secondary constructor needs to delegate to the primary constructor, either directly or indirectly through another secondary constructor(s). Delegation to another constructor of the same class is done using the this keyword:
				class Person(val name: String) {
					constructor(name: String, parent: Person) : this(name) {
						parent.children.add(this)
					}
				}
				
	Inheritance
		All classes in Kotlin have a common superclass Any, that is a default super for a class with no supertypes declared
		
		open class Base(p: Int)
		class Derived(p: Int) : Base(p)
		
		If the class has no primary constructor, then each secondary constructor has to initialize the base type using the super keyword, or to delegate to another constructor which does that. 
			class MyView : View {
				constructor(ctx: Context) : super(ctx)
				constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)
			}
			
		Overriding methods:
			open class Base {
				open fun v() {}
				fun nv() {}
			}
			class Derived() : Base() {
				override fun v() {}
			}
			
			A member marked override is itself open, i.e. it may be overridden in subclasses. If you want to prohibit re-overriding, use final:
				open class AnotherDerived() : Base() {
					final override fun v() {}
				}
				
		Overriding Properties
			open class Foo {
				open val x: Int get() { ... }
			}
			class Bar1 : Foo() {
				override val x: Int = ...
			}
			You can also override a val property with a var property, but not vice versa. This is allowed because a val property essentially declares a getter method, and overriding it as a var additionally declares a setter method in the derived class.
			
			interface Foo {
				val count: Int
			}
			class Bar1(override val count: Int) : Foo
			class Bar2 : Foo {
				override var count: Int = 0
			}
			
		Abstract Classes
			We can override a non-abstract open member with an abstract one
			open class Base {
				open fun f() {}
			}
			abstract class Derived : Base() {
				override abstract fun f()
			}
			
	Class delegation: works only on interfaces

		The Delegation pattern has proven to be a good alternative to implementation inheritance, and Kotlin supports it natively requiring zero boilerplate code. 
		A class Derived can inherit from an interface Base and delegate all of its public methods to a specified object.
	
		More importantly, overrides work: the compiler will use your override implementations instead of those in the delegate object.
			The default functions of the interface can also be overridden!

Object Expressions and Declarations

	Object expressions
		To create an object of an anonymous class that inherits from some type (or types), we write:
		
		window.addMouseListener(object : MouseAdapter() {
			override fun mouseClicked(e: MouseEvent) {
				// ...
			}

			override fun mouseEntered(e: MouseEvent) {
				// ...
			}
		})
		
		open class A(x: Int) {
			public open val y: Int = x
		}

		interface B {...}

		val ab: A = object : A(1), B {
			override val y = 15
		}
		
	Object declarations
		Singleton is a very useful pattern, and Kotlin (after Scala) makes it easy to declare singletons:
		object DataProviderManager {
			fun registerDataProvider(provider: DataProvider) {
				// ...
			}

			val allDataProviders: Collection<DataProvider>
				get() = // ...
		}
		DataProviderManager.registerDataProvider(...)
		object DefaultListener : MouseAdapter() {
			override fun mouseClicked(e: MouseEvent) {
				// ...
			}

			override fun mouseEntered(e: MouseEvent) {
				// ...
			}
		}
		
	Semantic difference between object expressions and declarations
		There is one important semantic difference between object expressions and object declarations:

		- object expressions are executed (and initialized) immediately, where they are used;
		- object declarations are initialized lazily, when accessed for the first time;
		- a companion object is initialized when the corresponding class is loaded (resolved), matching the semantics of a Java static initializer.


Interfaces

	Interfaces in Kotlin are very similar to Java 8. They can contain declarations of abstract methods, as well as method implementations. 
	What makes them different from abstract classes is that interfaces cannot store state. They can have properties but these need to be abstract or to provide accessor implementations.

		interface MyInterface {
			fun bar()
			fun foo() {
			  // optional body
			}
		}
		class Child : MyInterface {
			override fun bar() {
				// body
			}
		}
	
	Properties in Interfaces
		interface MyInterface {
			val prop: Int // abstract

			val propertyWithImplementation: String
				get() = "foo"

			fun foo() {
				print(prop)
			}
		}

		class Child : MyInterface {
			override val prop: Int = 29
		}


Properties and Fields

	The initializer, getter and setter are optional. Property type is optional if it can be inferred from the initializer (or from the getter return type, as shown below).
		var allByDefault: Int? // error: explicit initializer required, default getter and setter implied
		var initialized = 1 // has type Int, default getter and setter
		
	The full syntax of a read-only property declaration differs from a mutable one in two ways: it starts with val instead of var and does not allow a setter:
		val simple: Int? // has type Int, default getter, must be initialized in constructor
		val inferredType = 1 // has type Int and a default getter
		
	We can write custom accessors, very much like ordinary functions, right inside a property declaration. Here's an example of a custom getter:
		val isEmpty: Boolean
			get() = this.size == 0
			
		var stringRepresentation: String
			get() = this.toString()
			set(value) {
				setDataFromString(value) // parses the string and assigns values to other properties
			}
			
		If you need to change the visibility of an accessor or to annotate it, but don't need to change the default implementation, you can define the accessor without defining its body:

			var setterVisibility: String = "abc"
				private set // the setter is private and has the default implementation

			var setterWithAnnotation: Any? = null
				@Inject set // annotate the setter with Inject
				
	Backing Fields
		Classes in Kotlin cannot have fields. However, sometimes it is necessary to have a backing field when using custom accessors.
		For these purposes, Kotlin provides an automatic backing field which can be accessed using the field identifier.
		
		var identityProp: Int = 0
			get() = field
			set(value) {
				field = value
			}
			
	Compile-Time Constants

		Properties the value of which is known at compile time can be marked as compile time constants using the const modifier. Such properties need to fulfil the following requirements:
			- Top-level or member of an object
			- Initialized with a value of type String or a primitive type
			- No custom getter
			
		Such properties can be used in annotations:
			const val SUBSYSTEM_DEPRECATED: String = "This subsystem is deprecated"
			@Deprecated(SUBSYSTEM_DEPRECATED) fun foo() { ... }
		
	Backing Properties

		If you want to do something that does not fit into this "implicit backing field" scheme, you can always fall back to having a backing property:
		private var _table: Map<String, Int>? = null
		public val table: Map<String, Int>
			get() {
				if (_table == null) {
					_table = HashMap() // Type parameters are inferred
				}
				return _table ?: throw AssertionError("Set to null by another thread")
			}
			
	Late-Initialized Properties and Variables
		Normally, properties declared as having a non-null type must be initialized in the constructor. 
		However, fairly often this is not convenient. For example, properties can be initialized through dependency injection, or in the setup method of a unit test. 
		In this case, you cannot supply a non-null initializer in the constructor, but you still want to avoid null checks when referencing the property inside the body of a class.

		To handle this case, you can mark the property with the lateinit modifier:
			lateinit var subject: TestSubject
			
		Checking whether a lateinit var is initialized (since 1.2)
			if (foo::bar.isInitialized) {
				println(foo.bar)
			}


Type casts, smart casts

	// x is automatically cast to string on the right-hand side of `&&`
    if (x is String && x.length > 0) {
        print(x.length) // x is automatically cast to String
    }
	
	if (x !is String) return
    print(x.length) // x is automatically cast to String
	
	
	Such smart casts work for when-expressions and while-loops as well:
		when (x) {
			is Int -> print(x + 1)
			is String -> print(x.length + 1)
			is IntArray -> print(x.sum())
		}
	
	Note that smart casts do not work when the compiler cannot guarantee that the variable cannot change between the check and the usage. More specifically, smart casts are applicable according to the following rules:
		val local variables - always;
		val properties - if the property is private or internal or the check is performed in the same module where the property is declared. Smart casts aren't applicable to open properties or properties that have custom getters;
		var local variables - if the variable is not modified between the check and the usage and is not captured in a lambda that modifies it;
		var properties - never (because the variable can be modified at any time by other code).
		
	"Unsafe" cast operator: "as"
		Usually, the cast operator throws an exception if the cast is not possible. Thus, we call it unsafe. The unsafe cast in Kotlin is done by the infix operator as (see operator precedence):
		val x: String = y as String
		
		Note that null cannot be cast to String as this type is not nullable, i.e. if y is null, the code above throws an exception. In order to match Java cast semantics we have to have nullable type at cast right hand side, like:
			val x: String? = y as String?
			
	"Safe" (nullable) cast operator: "as?"
		To avoid an exception being thrown, one can use a safe cast operator as? that returns null on failure:
		val x: String? = y as? String
			Note that despite the fact that the right-hand side of as? is a non-null type String the result of the cast is nullable.
			
			
Ranges
	Range expressions are formed with rangeTo functions that have the operator form .. which is complemented by in and !in. Range is defined for any comparable type, but for integral primitive types it has an optimized implementation. Here are some examples of using ranges:
	
	val range = 1.rangeTo(10)	// this is equivalent to using the ".." operator: 1..10
	if (i in 1..10) { // equivalent of 1 <= i && i <= 1
		println(i)
	}
	
	outer@ for (i in 1..5) {
		for (j in 10 downTo 1) {
			if (j == 4) break@outer	// break out from the outer@ label
		}
	}
	
	for (i in 1..4) print(i) // prints "1234"
	for (i in 4..1) print(i) // prints nothing
		for (i in 4 downTo 1) print(i) // prints "4321"
	for (i in 1..4 step 2) print(i) // prints "13"
	for (i in 4 downTo 1 step 2) print(i) // prints "42"
	
	To create a range which does not include its end element, you can use the until function:
		for (i in 1 until 10) { // i in [1, 10), 10 is excluded
			 println(i)
		}
	for(i in (10 downTo 1).reversed()) {
		...
	}
		
	How it works
		Ranges implement a common interface in the library: ClosedRange<T>.
		ClosedRange<T> denotes a closed interval in the mathematical sense, defined for comparable types. It has two endpoints: start and endInclusive, which are included in the range. The main operation is contains, usually used in the form of in/!in operators.

	
Delegated properties

	val lazyValue: String by lazy {
		println("computed!")
		"Hello"
	}
	
	var name: String by Delegates.observable("<no name>") {
        prop, old, new ->
        println("$old -> $new")
    }
	
	class User(val map: Map<String, Any?>) {
		val name: String by map
		val age: Int     by map
	}
	
	
	class Delegate {
		operator fun getValue(thisRef: Any?, property: KProperty<*>): String {
			return "$thisRef, thank you for delegating '${property.name}' to me!"
		}
	 
		operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {
			println("$value has been assigned to '${property.name} in $thisRef.'")
		}
	}
	class Example {
		var p: String by Delegate()
	}


:: - reflection and method reference at the same time.

	list.forEach(::println) 	- method reference: it is bound to its receiver
	myClass::fun1				- method reference, bound function to its receiver (to the MyClass instance)
	this::fun1					- method reference, bound function to its receiver
	
	IntroAndLang::class.java 	- reflection
	MyClass::myProp				- reflection
	MyClass::fun1				- reflection, but can be an unbound function reference as well, depending on the type of the left handside's variable
	
	
Lambda

	Lambdas can be passed down to functions as parameters with the :: method reference syntax:
	
		class MyClass(lazyInitializer: () -> Int) {

			// passing down the lambda
			val lazyProp: Int by lazy(lazyInitializer)
			// passing down a method reference
			val lazyProp2: Int by lazy(this::createInt)

			fun createInt() = 2

			fun test(message: Int, message2: String) {
				println(this::test)
			}
		}
		
	Interesting: lambda vs local function
	
		class Wrapper {
			fun test() {
				val lamb = { s: String ->
					// this is Wrapper
				}
				lamb("par")

				val lamb2: (s: String) -> Unit = { s ->  }
				lamb2("named_par")

				val func = fun String.(s: String) {
					// this is the string receiver!
				}
				func("receiver", "par")
				"receiver".func("par")
				
				val functionalInterface = Function<String, Int> { param -> 3 }
				functionalInterface.apply("Java functional interface implementation example. Casting needed.")
			}
		}
		
	Passing "toBeSynchronized" as a method reference to the "lock" top-level function:
		fun toBeSynchronized() = sharedResource.operation()
		val result = lock(lock, ::toBeSynchronized)
		
		Another, often more convenient way is to pass a lambda expression:
		val result = lock(lock, { sharedResource.operation() })
		val result = lock (lock) {
			sharedResource.operation()
		}
		
	We can explicitly return a value from the lambda using the qualified return syntax. Otherwise, the value of the last expression is implicitly returned. Therefore, the two following snippets are equivalent:
	ints.filter { it > 0 } // this literal is of type '(it: Int) -> Boolean'
	
	ints.filter {
		val shouldFilter = it > 0 
		// return "shouldFilter" as the value of this lambda
		shouldFilter
	}

	ints.filter {
		val shouldFilter = it > 0 
		// return "shouldFilter" as the value of this lambda
		return@filter shouldFilter
	}
		
Anonymous Functions

	One thing missing from the lambda expression syntax presented above is the ability to specify the return type of the function. In most cases, this is unnecessary because the return type can be inferred automatically. However, if you do need to specify it explicitly, you can use an alternative syntax: an anonymous function.

	fun(x: Int, y: Int): Int = x + y
	fun(x: Int, y: Int): Int {
		return x + y
	}
	ints.filter(fun(item) = item > 0)		
	
	The return type inference for anonymous functions works just like for normal functions: the return type is inferred automatically for anonymous functions with an expression body and has to be specified explicitly (or is assumed to be Unit) for anonymous functions with a block body.

	Note that anonymous function parameters are always passed inside the parentheses. The shorthand syntax allowing to leave the function outside the parentheses works only for lambda expressions.
	
	One other difference between lambda expressions and anonymous functions is the behavior of non-local returns. A return statement without a label always returns from the function declared with the fun keyword. This means that a return inside a lambda expression will return from the enclosing function, whereas a return inside an anonymous function will return from the anonymous function itself.
			fun test(message: Int, message2: String) {

				synchronized(this, fun() {
					// return from this anonymous method
					return
				})
				
				synchronized(this) {
					// returns from the "test" function itself
					return
				}
			}
			
			
Function Literals with Receiver

	Kotlin provides the ability to call a function literal with a specified receiver object. Inside the body of the function literal, you can call methods on that receiver object without any additional qualifiers. This is similar to extension functions, which allow you to access members of the receiver object inside the body of the function. One of the most important examples of their usage is Type-safe Groovy-style builders.

	The type of such a function literal is a function type with receiver:
		sum : Int.(other: Int) -> Int			
		// inside the body of this function "this" is the receiver the "sum" method is invoked on
		val sum = fun Int.(other: Int): Int = this + other
		1.sum(2)	// "this" is the 1 on the left handside
		
	
	A non-literal value of a function-with-receiver type can also be assigned or passed as an argument where an ordinary function is expected that has an additional first parameter of the receiver type, and vice versa. For example, the types String.(Int) -> Boolean and (String, Int) -> Boolean are compatible:

		val represents: String.(Int) -> Boolean = { other -> toIntOrNull() == other }
		println("123".represents(123)) // true
		
	Lambda expressions can be used as function literals with receiver when the receiver type can be inferred from context.
		
		class HTML {
			fun body() { ... }
		}

		fun html(init: HTML.() -> Unit): HTML {
			val html = HTML()  // create the receiver object
			html.init()        // pass the receiver object to the lambda
			return html
		}


		html {       // lambda with receiver begins here
			body()   // calling a method on the receiver object (a HTML instance)
		}

		
Inline functions

	Note that if an inline function has no inlinable function parameters and no reified type parameters, the compiler will issue a warning, since inlining such functions is very unlikely to be beneficial (you can suppress the warning if you are sure the inlining is needed using the annotation @Suppress("NOTHING_TO_INLINE")).
	
	noinline: In case you want only some of the lambdas passed to an inline function to be inlined, you can mark some of your function parameters with the noinline modifier:
		inline fun foo(inlined: () -> Unit, noinline notInlined: () -> Unit) {
			// ...
		}
		
	Non-local returns

		In Kotlin, we can only use a normal, unqualified return to exit a named function or an anonymous function. This means that to exit a lambda, we have to use a label, and a bare return is forbidden inside a lambda, because a lambda can not make the enclosing function return:

		fun foo() {
			ordinaryFunction {
				return // ERROR: can not make `foo` return here
			}
		}
		But if the function the lambda is passed to is inlined, the return can be inlined as well, so it is allowed:

		fun foo() {
			inlineFunction {
				return // OK: the lambda is inlined
			}
		}
		Such returns (located in a lambda, but exiting the enclosing function) are called non-local returns. We are used to this sort of construct in loops, which inline functions often enclose:

		fun hasZeros(ints: List<Int>): Boolean {
			ints.forEach {
				if (it == 0) return true // returns from hasZeros
			}
			return false
		}
		
	crossinline:
		Note that some inline functions may call the lambdas passed to them as parameters not directly from the function body, but from another execution context, such as a local object or a nested function. In such cases, non-local control flow is also not allowed in the lambdas. To indicate that, the lambda parameter needs to be marked with the crossinline modifier:

		inline fun f(crossinline body: () -> Unit) {
			val f = object: Runnable {
				override fun run() = body()
			}
			// ...
		}
		
	reified:
	
		What we actually want is simply pass a type to this function, i.e. call it like this:

		treeNode.findParentOfType<MyTreeNode>()
			To enable this, inline functions support reified type parameters, so we can write something like this:

			inline fun <reified T> TreeNode.findParentOfType(): T? {
				var p = parent
				while (p != null && p !is T) {
					p = p.parent
				}
				return p as T?
			}
	
		Though reflection may not be needed in many cases, we can still use it with a reified type parameter:

			inline fun <reified T> membersOf() = T::class.members

			fun main(s: Array<String>) {
				println(membersOf<StringBuilder>().joinToString("\n"))
			}
	
	inline properties (since 1.1)

		The inline modifier can be used on accessors of properties that don't have a backing field. You can annotate individual property accessors:

		val foo: Foo
			inline get() = Foo()

		var bar: Bar
			get() = ...
			inline set(v) { ... }
		You can also annotate an entire property, which marks both of its accessors as inline:

		inline var bar: Bar
			get() = ...
			set(v) { ... }
			

Coroutines:
	https://github.com/Kotlin/kotlinx.coroutines
	Suspending functions can only be invoked from another suspending functions or from coroutine blocks - so we have to be in coroutine-context. Coroutine contexts are created by coroutine builders.
	
	Basically, coroutines are computations that can be suspended without blocking a thread.
	
	Blocking vs Suspending
		- Coroutine suspension is almost free, on the other hand. No context switch or any other involvement of the OS is required.
		- Another difference is that coroutines can not be suspended at random instructions, but rather only at so called suspension points, which are calls to specially marked functions.
			we can get into coroutine context by coroutine builders
			suspending functions can only be invoked from coroutine builders or from other suspending functions
			
		Such functions are called suspending functions, because calls to them may suspend a coroutine (the library can decide to proceed without suspension, if the result for the call in question is already available). 
		
		Suspending functions can take parameters and return values in the same manner as regular functions, but they can only be called from coroutines and other suspending functions.
		In fact, to start a coroutine, there must be at least one suspending function, and it is usually anonymous (i.e. it is a suspending lambda). Let's look at an example, a simplified async() function (from the kotlinx.coroutines library):
			fun <T> async(block: suspend () -> T)
			
			Here, async() is a regular function (not a suspending function), but the block parameter has a function type with the suspend modifier: suspend () -> T. So, when we pass a lambda to async(), it is a suspending lambda, and we can call a suspending function from it:
				async {
					doSomething(foo)
					...
				}
				
			- Note that suspending functions await() and doSomething() can not be called from a regular function like 
			- Also note that suspending functions can be virtual, and when overriding them, the suspend modifier has to be specified.
			- Extension functions (and lambdas) can also be marked suspend, just like regular ones. This enables creation of DSLs and other APIs that users can extend. 
	
	The inner workings of coroutines
		Coroutines are completely implemented through a compilation technique (no support from the VM or OS side is required), and suspension works through code transformation. Basically, every suspending function (optimizations may apply, but we'll not go into this here) is transformed to a state machine where states correspond to suspending calls. Right before a suspension, the next state is stored in a field of a compiler-generated class along with relevant local variables, etc. Upon resumption of that coroutine, local variables are restored and the state machine proceeds from the state right after suspension.
	
	
	fun main(args: Array<String>) = runBlocking<Unit> {
		val jobs = arrayListOf<Job>()
		jobs += launch(Unconfined) { // not confined -- will work with main thread
			println("      'Unconfined': I'm working in thread ${Thread.currentThread().name}")
		}
		jobs += launch(coroutineContext) { // context of the parent, runBlocking coroutine
			println("'coroutineContext': I'm working in thread ${Thread.currentThread().name}")
		}
		jobs += launch(CommonPool) { // will get dispatched to ForkJoinPool.commonPool (or equivalent)
			println("      'CommonPool': I'm working in thread ${Thread.currentThread().name}")
		}
		jobs += launch(newSingleThreadContext("MyOwnThread")) { // will get its own new thread
			println("          'newSTC': I'm working in thread ${Thread.currentThread().name}")
		}
		jobs.forEach { it.join() }
	}
	
	un main(args: Array<String>) = runBlocking<Unit> {
		val jobs = arrayListOf<Job>()
		jobs += launch(Unconfined) { // not confined -- will work with main thread
			println("      'Unconfined': I'm working in thread ${Thread.currentThread().name}")	-- main thread
			delay(500)
			println("      'Unconfined': After delay in thread ${Thread.currentThread().name}")	-- not main thread, ForkJoinPool.commonPool
		}
		jobs += launch(coroutineContext) { // context of the parent, runBlocking coroutine
			println("'coroutineContext': I'm working in thread ${Thread.currentThread().name}")	-- main thread
			delay(1000)
			println("'coroutineContext': After delay in thread ${Thread.currentThread().name}")	-- main thread
		}
		jobs.forEach { it.join() }
	}
	
	Builders:
		runBlocking
			fun <T> runBlocking(
				context: CoroutineContext = EmptyCoroutineContext, 
				block: suspend CoroutineScope.() -> T
			): T (source)
			Runs new coroutine and blocks current thread interruptibly until its completion. This function should not be used from coroutine. It is designed to bridge regular blocking code to libraries that are written in suspending style, to be used in main functions and in tests.
			
		launch
		
			fun launch(
				context: CoroutineContext = DefaultDispatcher, 
				start: CoroutineStart = CoroutineStart.DEFAULT, 
				block: suspend CoroutineScope.() -> Unit
			): Job (source)
			Launches new coroutine without blocking current thread and returns a reference to the coroutine as a Job. The coroutine is cancelled when the resulting job is cancelled.
			
		async
			fun <T> async(
				context: CoroutineContext = DefaultDispatcher, 
				start: CoroutineStart = CoroutineStart.DEFAULT, 
				block: suspend CoroutineScope.() -> T
			): Deferred<T> (source)
			Creates new coroutine and returns its future result as an implementation of Deferred.

			The running coroutine is cancelled when the resulting object is cancelled.
			
		future
			for Java 8 CompletableFuture
			https://github.com/Kotlin/kotlinx.coroutines/blob/master/integration/kotlinx-coroutines-jdk8/README.md
			
			val image: CompletableFuture<Image> = future {
				val future1 = loadImageAsync(name1) // start loading first image
				val future2 = loadImageAsync(name2) // start loading second image
				combineImages(future1.await(), future2.await()) // wait for both, combine, and return result
			}
			
		Reactive stream builders: https://github.com/Kotlin/kotlinx.coroutines/blob/master/reactive/README.md
			mono			- for Reactor
			flux
			
			rxCompletable	- for RxJava
			rxMaybe
			rxSingle
			rxObservable
			rxFlowable
			
			publish 		- for reactive streams
			
		Generators: these are shipped within kotlin-stdlib because they are related to sequences.
			buildIterator:
			buildSequence: to implement C# yield return with IEnumerable<T>
			
				val lazySeq = buildSequence {
					yield(0)
					print("START ")
					for (i in 1..5) {
						yield(i)
						print("STEP ")
					}
					print("ALMOST END")
					yieldAll(16..10)
					print("END")
				}

				for (i in lazySeq.take(10)) {

				}
			
	Scheduling:
	
		Unconfined
			A coroutine dispatcher that is not confined to any specific thread. It executes initial continuation of the coroutine right here in the current call-frame and let the coroutine resume in whatever thread that is used by the corresponding suspending function, without mandating any specific threading policy.

			Note, that if you need your coroutine to be confined to a particular thread or a thread-pool after resumption, but still want to execute it in the current call-frame until its first suspension, then you can use an optional CoroutineStart parameter in coroutine builders like launch and async setting it to the the value of CoroutineStart.UNDISPATCHED.
			
		CommonPool
			Represents common pool of shared threads as coroutine dispatcher for compute-intensive tasks. It uses java.util.concurrent.ForkJoinPool when available, which implements efficient work-stealing algorithm for its queues, so every coroutine resumption is dispatched as a separate task even when it already executes inside the pool. When available, it wraps ForkJoinPool.commonPool and provides a similar shared pool where not.
			
		newSingleThreadContext
			Creates new coroutine execution context with the a single thread and built-in yield and delay support. NOTE: The resulting ThreadPoolDispatcher owns native resources (its thread).Resources are reclaimed by ThreadPoolDispatcher.close.
			
		kotlinx.coroutines.experimental.javafx.JavaFx as UI -- for JavaFx
			 launch(UI) { // launch coroutine in UI context
				for (i in 10 downTo 1) { // countdown from 10 to 1 
					hello.text = "Countdown $i ..." // update text
					delay(500) // wait half a second
				}
				hello.text = "Done!"
			}
			
		
Iterator

	In C# the IEnumerable (or Enumerable<T>) interface is common between arrays and collections (List, HashSet, Dictionary)
		foreach: can be used on any array, collection objects that implement the IEnumerable<T> generic interface.
		
	In Java there is NO common interface between arrays and collections (List, Set, Map).
	
	Kotlin is like Java in this case.	
		for: can be used on any object that has an "iterator operator": public operator fun iterator(): Iterator<T> - T comes from the enclosing class (Array is a class in kotlin)
		
		
Generics
	out: can be return parameter or property getter (reading)
	in: can be in (normal) parameter or property setter (writing)

	In Kotlin, there is a way to explain this sort of thing to the compiler. This is called declaration-site variance: we can annotate the type parameter T of Source to make sure that it is only returned (produced) from members of Source<T>, and never consumed. To do this we provide the out modifier:
	abstract class Source<out T> {
		abstract fun nextT(): T
	}
	In "clever words" they say that the class C is covariant in the parameter T, or that T is a covariant type parameter. You can think of C as being a producer of T's, and NOT a consumer of T's.
	The out modifier is called a variance annotation, and since it is provided at the type parameter declaration site, we talk about declaration-site variance. This is in contrast with Java's use-site variance where wildcards in the type usages make the types covariant.
	
	In addition to out, Kotlin provides a complementary variance annotation: in. It makes a type parameter contravariant: it can only be consumed and never produced. A good example of a contravariant class is Comparable:
	abstract class Comparable<in T> {
		abstract fun compareTo(other: T): Int
	}
	
	Type projections
	
		fun copy(from: Array<out Any>, to: Array<Any>) {
		 // ...
		}
		fun fill(dest: Array<in String>, value: String) {
			// ...
		}

	Star-projections
		Kotlin provides so called star-projection syntax for this:
			For Foo<out T>, where T is a covariant type parameter with the upper bound TUpper, Foo<*> is equivalent to Foo<out TUpper>. It means that when the T is unknown you can safely read values of TUpper from Foo<*>.
			For Foo<in T>, where T is a contravariant type parameter, Foo<*> is equivalent to Foo<in Nothing>. It means there is nothing you can write to Foo<*> in a safe way when T is unknown.
			For Foo<T>, where T is an invariant type parameter with the upper bound TUpper, Foo<*> is equivalent to Foo<out TUpper> for reading values and to Foo<in Nothing> for writing values.
			
		If a generic type has several type parameters each of them can be projected independently. For example, if the type is 
		declared as interface Function<in T, out U> we can imagine the following star-projections:
			Function<*, String> means Function<in Nothing, String>;
			Function<Int, *> means Function<Int, out Any?>;
			Function<*, *> means Function<in Nothing, out Any?>.
			
	Upper bounds
		fun <T : Comparable<T>> sort(list: List<T>) {
			// ...
		}
		
		The default upper bound (if none specified) is Any?. Only one upper bound can be specified inside the angle brackets. If the same type parameter needs more than one upper bound, we need a separate where-clause:
			fun <T> cloneWhenGreater(list: List<T>, threshold: T): List<T>
				where T : Comparable<T>,
					  T : Cloneable {
			  return list.filter { it > threshold }.map { it.clone() }
			}
	
Nested classes
	class Outer {
		private val bar: Int = 1
		class Nested {
			fun foo() = 2
		}
	}
	val demo = Outer.Nested().foo() // == 2
	
	A class may be marked as inner to be able to access members of outer class. Inner classes carry a reference to an object of an outer class:
		class Outer {
			private val bar: Int = 1
			inner class Inner {
				fun foo() = bar
			}
		}
		val demo = Outer().Inner().foo() // == 1
		
	Anonymous inner classes
		window.addMouseListener(object: MouseAdapter() {
			override fun mouseClicked(e: MouseEvent) {
				// ...
			}
																													
			override fun mouseEntered(e: MouseEvent) {
				// ...
			}
		})

	If the object is an instance of a functional Java interface (i.e. a Java interface with a single abstract method), you can create it using a lambda expression prefixed with the type of the interface:
		val listener = ActionListener { println("clicked") }
		
	Nested classes can be declared even in funtions!
		private fun Transaction.couponCategories(compInfos: List<CompanyInfo>) {
			if (compInfos.isEmpty()) return

			class CategoryMini(val title: String,
							   val description: String,
							   val image: ByteArray,
							   val companyId: Long
			)
			...
		}
		

Anonymous classes, objects:
	Objects:
		val errorObject = object {
			val message = errorMessage
		}
		
	Classes:
		val thread = object : Thread() {
			override fun run() {
				super.run()
			}
		}
		thread.isDaemon = true
		thread.run()

		
		val anon = object : ObjectMapper() {
			fun myFunc(): Unit {}
		}
		anon.myFunc()
		
		
		interface SuperCar {
			fun startEngine(): Unit;
		}
		val mySupi = object : SuperCar {
			override fun startEngine() {
				TODO("not implemented")
			}
		}
		mySupi.startEngine()
		
		
This
	In a member of a class, this refers to the current object of that class.
	In an extension function or a function literal with receiver this denotes the receiver parameter that is passed on the left-hand side of a dot.
	
	Qualified this
		To access this from an outer scope (a class, or extension function, or labeled function literal with receiver) we write this@label where @label is a label on the scope this is meant to be from:
		class A { // implicit label @A
			inner class B { // implicit label @B
				fun Int.foo() { // implicit label @foo
					val a = this@A // A's this
					val b = this@B // B's this

					val c = this // foo()'s receiver, an Int
					val c1 = this@foo // foo()'s receiver, an Int

					val funLit = lambda@ fun String.() {
						val d = this // funLit's receiver
					}


					val funLit2 = { s: String ->
						// foo()'s receiver, since enclosing lambda expression
						// doesn't have any receiver
						val d1 = this
					}
				}
			}
		}
		
		
Equality

	There are 2 types:
		Referential equality (two references point to the same object); - identity
		Structural equality (a check for equals()).						- equality
		
	Referential equality
		Referential equality is checked by the === operation (and its negated counterpart !==). a === b evaluates to true if and only if a and b point to the same object.
	Structural equality
		Structural equality is checked by the == operation (and its negated counterpart !=). By convention, an expression like a == b is translated to:

		a?.equals(b) ?: (b === null)
		
		
Operator overloading

	To implement an operator, we provide a member function or an extension function with a fixed name, for the corresponding type, i.e. left-hand side type for binary operations and argument type for unary ones. Functions that overload operators need to be marked with the operator modifier.
	
	data class Counter(val dayIndex: Int) {
		operator fun plus(increment: Int): Counter {
			return Counter(dayIndex + increment)
		}
	}
	
		Expression							Translated to
		a == b								a?.equals(b) ?: (b === null)
		a != b								!(a?.equals(b) ?: (b === null))
		

Null Safety
	Kotlin's type system is aimed to eliminate NullPointerException's from our code. The only possible causes of NPE's may be:
		An explicit call to throw NullPointerException();
		Usage of the !! operator that is described below;
		External Java code has caused it;
		There's some data inconsistency with regard to initialization (an uninitialized this available in a constructor is used somewhere).
		
			var a: String = "abc"
			a = null // compilation error
			
			var b: String? = "abc"
			b = null // ok
			
	Checking for null conditions
		val l = if (b != null) b.length else -1
	Safe Calls
		val l = b?.length ?: -1: 
		If the expression to the left of "?:" is not null, the elvis operator returns it, otherwise it returns the expression to the right. Note that the right-hand side expression is evaluated only if the left-hand side is null.
		
	Note that, since throw and return are expressions in Kotlin, they can also be used on the right hand side of the elvis operator. This can be very handy, for example, for checking function arguments:
		fun foo(node: Node): String? {
			val parent = node.getParent() ?: return null
			val name = node.getName() ?: throw IllegalArgumentException("name expected")
			// ...
		}		
		
		To perform a certain operation only for non-null values, you can use the safe call operator together with let:
			val listWithNulls: List<String?> = listOf("A", null)
			for (item in listWithNulls) {
				 item?.let { println(it) } // prints A and ignores null
			}
	
	The !! Operator

		The third option is for NPE-lovers. We can write b!!, and this will return a non-null value of b (e.g., a String in our example) or throw an NPE if b is null:
		val l = b!!.length
		
	Safe Casts
		Regular casts may result into a ClassCastException if the object is not of the target type. Another option is to use safe casts that return null if the attempt was not successful:
		val aInt: Int? = a as? Int
		Collections of Nullable Type

	If you have a collection of elements of a nullable type and want to filter non-null elements, you can do so by using filterNotNull:
		val nullableList: List<Int?> = listOf(1, 2, null, 4)
		val intList: List<Int> = nullableList.filterNotNull()
		
		
Exceptions

	Checked Exceptions
		Kotlin does not have checked exceptions. 

	Try is an expression:
		val a: Int? = try { parseInt(input) } catch (e: NumberFormatException) { null }
		
	The Nothing type
		throw is an expression in Kotlin, so you can use it, for example, as part of an Elvis expression:
			val s = person.name ?: throw IllegalArgumentException("Name required")

		The type of the throw expression is the special type Nothing. The type has no values and is used to mark code locations that can never be reached. In your own code, you can use Nothing to mark a function that never returns:
			fun fail(message: String): Nothing {
				throw IllegalArgumentException(message)
			}
			
			When you call this function, the compiler will know that the execution doesn't continue beyond the call:

			val s = person.name ?: fail("Name required")
			println(s)     // 's' is known to be initialized at this point
			
			
Annotations

	annotation class Fancy
	
	Additional attributes of the annotation can be specified by annotating the annotation class with meta-annotations:
		@Target specifies the possible kinds of elements which can be annotated with the annotation (classes, functions, properties, expressions etc.);
		@Retention specifies whether the annotation is stored in the compiled class files and whether it's visible through reflection at runtime (by default, both are true);
		@Repeatable allows using the same annotation on a single element multiple times;
		@MustBeDocumented specifies that the annotation is part of the public API and should be included in the class or method signature shown in the generated API documentation.
		
	Constructors
		Annotations may have constructors that take parameters.
		
			annotation class Special(val why: String)
			@Special("example") class Foo {}
			
	Lambdas

		Annotations can also be used on lambdas. They will be applied to the invoke() method into which the body of the lambda is generated.
		
		annotation class Suspendable
		val f = @Suspendable { Fiber.sleep(10) }
		
	Annotation Use-site Targets
		class Example(@field:Ann val foo,    // annotate Java field
              @get:Ann val bar,      // annotate Java getter
              @param:Ann val quux)   // annotate Java constructor parameter
			  
		 The full list of supported use-site targets is:

			file: to annotate the entire file
			property (annotations with this target are not visible to Java);
			field;
			get (property getter);
			set (property setter);
			receiver (receiver parameter of an extension function or property);
			param (constructor parameter);
			setparam (property setter parameter);
			delegate (the field storing the delegate instance for a delegated property).
			
		Java Annotations

			Java annotations are 100% compatible with Kotlin
			
			
Reflection
	Class References: val c = MyClass::class
		The reference is a value of type KClass.
		Note that a Kotlin class reference is not the same as a Java class reference. To obtain a Java class reference, use the .java property on a KClass instance.
	
	Bound Class References (since 1.1)
		You can get the reference to a class of a specific object with the same ::class syntax by using the object as a receiver:
		val widget: Widget = ...
		assert(widget is GoodWidget) { "Bad widget: ${widget::class.qualifiedName}" }
		
	Function References
	
		fun isOdd(x: Int) = x % 2 != 0
			We can easily call it directly (isOdd(5)), but we can also pass it as a value, e.g. to another function. To do this, we use the :: operator:
			val numbers = listOf(1, 2, 3)
			println(numbers.filter(::isOdd)) // prints [1, 3]
			Here ::isOdd is a value of function type (Int) -> Boolean.
			
			
		If on a class:
			Haha::testHaha	 	- returns KFunction, or an unbound method reference ((Haha) -> Unit) depending on the left handside's type
			Haha()::testHaha	- returns method reference - (() -> Unit)
		
			var func: () -> Unit = ::test
			func = Haha()::testHaha
				fun testHaha() {
				}
				class Haha {
					fun test() {
					}
				}

		Select from overloded functions: declare the type of the function:
			val predicate: (String) -> Boolean = ::isOdd   // refers to isOdd(x: String)
				
	Example: Function Composition
	
		fun <A, B, C> compose(f: (B) -> C, g: (A) -> B): (A) -> C {
			return { x -> f(g(x)) }
		}
		
		It returns a composition of two functions passed to it: compose(f, g) = f(g(*)). Now, you can apply it to callable references:
		
		fun length(s: String) = s.length
		val oddLength = compose(::isOdd, ::length)
		val strings = listOf("a", "ab", "abc")

		println(strings.filter(oddLength)) // Prints "[a, abc]"
		
	Property References
		To access properties as first-class objects in Kotlin, we can also use the :: operator:
			val x = 1		// The expression ::x evaluates to a property object of type KProperty<Int>

			fun main(args: Array<String>) {
				println(::x.get()) // prints "1"
				println(::x.name)  // prints "x"
			}
			
			var y = 1		// For a mutable property, e.g. var y = 1, ::y returns a value of type KMutableProperty<Int>, which has a set() method

			fun main(args: Array<String>) {
				::y.set(2)
				println(y) // prints "2"
			}
			
		To access a property that is a member of a class, we qualify it:
			class A(val p: Int)
			fun main(args: Array<String>) {
				val prop = A::p
				println(prop.get(A(1))) // prints "1"
			}
			
	Constructor References
		Constructors are referenced by using the :: operator and adding the class name:
	
			class Foo
			fun function(factory: () -> Foo) {
				val x: Foo = factory()
			}
			function(::Foo)
			
	Bound Function and Property References (since 1.1) - method reference
		You can refer to an instance method of a particular object:
		
			val numberRegex = "\\d+".toRegex()
			println(numberRegex.matches("29")) // prints "true"
		 
			val isNumber = numberRegex::matches		// Instead of calling the method matches directly we are storing a reference to it. Such reference is bound to its receiver. 
			println(isNumber("29")) // prints "true"
			
			
		Compare the types of bound and the corresponding unbound references. Bound callable reference has its receiver "attached" to it, so the type of the receiver is no longer a parameter:
		
			var boundFunc: () -> Unit = Wrapper()::test // bound function - to its receiver
			var unboundFunc: (Wrapper) -> Unit = Wrapper::test  // unbound function - need to pass in a receiver
			var method: KFunction<*> = Wrapper::test    // method for reflection
			
				// surprisingly the "method" can be invoked just like a method
				method(Wrapper())
				method.invoke(Wrapper())
				
				boundFunc.invoke()
				unboundFunc.invoke(Wrapper())
			
			val isNumber: (CharSequence) -> Boolean = numberRegex::matches
			val matches: (Regex, CharSequence) -> Boolean = Regex::matches
			
		Property reference can be bound as well:

			val prop = "abc"::length
			println(prop.get())   // prints "3"
			
		Since Kotlin 1.2, explicitly specifying this as the receiver is not necessary: this::foo and ::foo are equivalent.
		
		
Type aliases

	Type aliases provide alternative names for existing types. If the type name is too long you can introduce a different shorter name and use the new one instead.
	
		typealias NodeSet = Set<Network.Node>
		typealias FileTable<K> = MutableMap<K, MutableList<File>>
		
	You can provide different aliases for function types:
		typealias MyHandler = (Int, String, Any) -> Unit
		typealias Predicate<T> = (T) -> Boolean
		
	You can have new names for inner and nested classes:
		class A {
			inner class Inner
		}
		class B {
			inner class Inner
		}
		typealias AInner = A.Inner
		typealias BInner = B.Inner
	
	
	Type aliases do not introduce new types. They are equivalent to the corresponding underlying types. When you add typealias Predicate<T> and use Predicate<Int> in your code, the Kotlin compiler always expand it to (Int) -> Boolean. Thus you can pass a variable of your type whenever a general function type is required and vice versa:
		typealias Predicate<T> = (T) -> Boolean
		fun foo(p: Predicate<Int>) = p(42)

		fun main(args: Array<String>) {
			val f: (Int) -> Boolean = { it > 0 }
			println(foo(f)) // prints "true"

			val p: Predicate<Int> = { it > 0 }
			println(listOf(1, -2).filter(p)) // prints "[1]"
		}		

Java interop

	Platform types:
		T! - this means it can be either T or T?
		Types of Java declarations are treated specially in Kotlin and called platform types. Null-checks are relaxed for such types, so that safety guarantees for them are the same as in Java
		
		a java "Integer" becomes a platform type in kotlin: Int! (because Integer in java can be either int or a null)
		however a java "int" becomes a kotlin type: Int (because "int" in java cannot be null)


If, try-catch expressions
		
	When expression
		when replaces the switch operator of C-like languages. In the simplest form it looks like this
		
		when (x) {
			in 1..10 -> print("x is in the range")
			in validNumbers -> print("x is valid")
			!in 10..20 -> print("x is outside the range")
			else -> print("none of the above")
		}
		when (x) {
			0, 1 -> print("x == 0 or x == 1")
			else -> print("otherwise")
		}
		fun hasPrefix(x: Any) = when(x) {
			is String -> x.startsWith("prefix")
			else -> false
		}
		when {
			x.isOdd() -> print("x is odd")
			x.isEven() -> print("x is even")
			else -> print("x is funny")
		}
	
	Try-catch
		try is an expression, i.e. it may have a return value:
		val a: Int? = try { parseInt(input) } catch (e: NumberFormatException) { null }
		The returned value of a try-expression is either the last expression in the try block or the last expression in the catch block (or blocks). Contents of the finally block do not affect the result of the expression.
	

Spring

	Leveraging Kotlin nullable information in Spring annotations

		Originally based on a community contribution from Raman Gupta, Spring now takes advantage of Kotlin null-safety support to determine if an HTTP parameter is required without having to define explicitly the required 
		attribute. That means @RequestParam name: String? with be treated as not required and @RequestParam name: String as required. This is also supported on Spring Messaging @Header annotation.

		In a similar fashion, Spring bean injection with @Autowired or @Inject uses this information to know if a bean is required or not. 
			@Autowired lateinit var foo: Foo 	- implies that a bean of type Foo must be registered in the application context 
			@Autowired lateinit var foo: Foo?  	- while this won’t raise an error if such bean does not exist.
		
		Optional ctor dependencies can also be specified:
			@RestController
			@RequestMapping("/")
			class HomeController(private val superFormula: SuperFormula?) { ... }}