https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/index.html

stdlib interesting mappings

	let - fun <T, R> T.let(block: (T) -> R): R
		Calls the specified function block with this value as its argument and returns its result.
		val car: Car = Person("Peter").let { Car(it.name) }
		val car: Car = this.repository.findPerson(1)?.let { Car(it.name) } ?: Car("Not found")
		
	run - fun <T, R> T.run(block: T.() -> R): R
		Calls the specified function block with this value as its receiver and returns its result.
		val car: Car = Person("Peter").run { Car(this.name) }
		
		
	with - fun <T, R> with(receiver: T, block: T.() -> R): R
		Calls the specified function block with the given receiver as its receiver and returns its result.
		val car: Car = with(Person("Peter")) { Car(this.name) }
		
	run - fun <R> run(block: () -> R): R
		Calls the specified function block and returns its result.
		val car: Car = run { Car("Peter") }


	also - fun <T> T.also(block: (T) -> Unit): T
		Calls the specified function block with this value as its argument and returns this value.
		val person: Person = Person("Peter").also { println(it.name) }
		
		val persons = mutableListOf<Person>(Person("Peter")).also {
			it.add(Person("Nora"))
			it.add(Person("Niki"))
		}
		
	apply - fun <T> T.apply(block: T.() -> Unit): T
		Calls the specified function block with this value as its receiver and returns this value.
		val person: Person = Person("Peter").apply { println(name) }
		
		val persons = mutableListOf<Person>(Person("Peter")).apply { 
			add(Person("Nora"))
			this.add(Person("Niki"))
		}
		
stdlib enums

	fun test() {
		val season: Seasons = enumValueOf<Seasons>("WINTER")
		val values: Array<Seasons> = enumValues<Seasons>()
	}

	enum class Seasons {
		WINTER,
		SUMMER,
		AUTUMN,
		SPRING
	}
	
	
Tuples
	Pair, Triple
	

Arrays, Collections

	val arr = Array(10) { Person(it) }
	val arr = arrayOf(1, 2, 3)
	val a = listOf(1, 2, 3)
	val a = mutableListOf(1, 2, 3)
	val a = ArrayList<Int>()
	val a = arrayListOf(1, 2)
	
	val a = setOf(1, 2, 3)
	val a = mutableSetOf(1, 2, 3)
	val a = HashSet<Int>()
	val a = hashSetOf(1, 2)
	
	val a = mapOf(1 to "1", 2 to "2")
	val a = mutableMapOf(Pair(1, "1"), Pair(2, "2"))
	val a = hashMapOf<Int, String>()
	val a = HashMap<Int, String>()
	
	// for lazy collections
	val a = sequenceOf(1, 2, 3)
	
	// for synchronized blocks
	synchronized - fun <R> synchronized(lock: Any, block: () -> R): R
		executes the given function block while holding the monitor of the given object lock.
		synchronized(this) {
			...
		}
	
	// try-with-resources block
	use - fun <T : AutoCloseable?, R> T.use(block: (T) -> R): R
	Executes the given block function on this resource and then closes it down correctly whether an exception is thrown or not.
		File("my.txt").inputStream().bufferedReader().use {
			it.lines().forEach { }
		}
		File("my.txt").bufferedReader().use {
			it.lines().forEach { }
		}
		
	Note that the read-only types are covariant. That means, you can take a List<Rectangle> and assign it to List<Shape> assuming Rectangle inherits from Shape. This wouldn't be allowed with the mutable collection types because it would allow for failures at runtime.
	
	val items = listOf(1, 2, 3, 4)
	items.first() == 1
	items.last() == 4
	items.filter { it % 2 == 0 }   // returns [2, 4]

	val rwList = mutableListOf(1, 2, 3)
	rwList.requireNoNulls()        // returns [1, 2, 3]
	if (rwList.none { it > 6 }) println("No items above 6")  // prints "No items above 6"
	val item = rwList.firstOrNull()
	

Type casts, smart casts

	// x is automatically cast to string on the right-hand side of `&&`
    if (x is String && x.length > 0) {
        print(x.length) // x is automatically cast to String
    }
	
	if (x !is String) return
    print(x.length) // x is automatically cast to String
	
	
	Such smart casts work for when-expressions and while-loops as well:
		when (x) {
			is Int -> print(x + 1)
			is String -> print(x.length + 1)
			is IntArray -> print(x.sum())
		}
	
	Note that smart casts do not work when the compiler cannot guarantee that the variable cannot change between the check and the usage. More specifically, smart casts are applicable according to the following rules:
		val local variables - always;
		val properties - if the property is private or internal or the check is performed in the same module where the property is declared. Smart casts aren't applicable to open properties or properties that have custom getters;
		var local variables - if the variable is not modified between the check and the usage and is not captured in a lambda that modifies it;
		var properties - never (because the variable can be modified at any time by other code).
		
	"Unsafe" cast operator: "as"
		Usually, the cast operator throws an exception if the cast is not possible. Thus, we call it unsafe. The unsafe cast in Kotlin is done by the infix operator as (see operator precedence):
		val x: String = y as String
		
		Note that null cannot be cast to String as this type is not nullable, i.e. if y is null, the code above throws an exception. In order to match Java cast semantics we have to have nullable type at cast right hand side, like:
			val x: String? = y as String?
			
	"Safe" (nullable) cast operator: "as?"
		To avoid an exception being thrown, one can use a safe cast operator as? that returns null on failure:
		val x: String? = y as? String
			Note that despite the fact that the right-hand side of as? is a non-null type String the result of the cast is nullable.
			
			
Ranges
	Range expressions are formed with rangeTo functions that have the operator form .. which is complemented by in and !in. Range is defined for any comparable type, but for integral primitive types it has an optimized implementation. Here are some examples of using ranges:
	
	val range = 1.rangeTo(10)	// this is equivalent to using the ".." operator: 1..to
	if (i in 1..10) { // equivalent of 1 <= i && i <= 1
		println(i)
	}
	
	outer@ for (i in 1..5) {
		for (j in 10 downTo 1) {
			if (j == 4) break@outer	// break out from the outer@ label
		}
	}
	
	for (i in 1..4) print(i) // prints "1234"
	for (i in 4..1) print(i) // prints nothing
		for (i in 4 downTo 1) print(i) // prints "4321"
	for (i in 1..4 step 2) print(i) // prints "13"
	for (i in 4 downTo 1 step 2) print(i) // prints "42"
	
	To create a range which does not include its end element, you can use the until function:
		for (i in 1 until 10) { // i in [1, 10), 10 is excluded
			 println(i)
		}
	for(i in (10 downTo 1).reversed()) {
		...
	}
		
	How it works
		Ranges implement a common interface in the library: ClosedRange<T>.
		ClosedRange<T> denotes a closed interval in the mathematical sense, defined for comparable types. It has two endpoints: start and endInclusive, which are included in the range. The main operation is contains, usually used in the form of in/!in operators.
	
		
		
Class delegation

	The Delegation pattern has proven to be a good alternative to implementation inheritance, and Kotlin supports it natively requiring zero boilerplate code. A class Derived can inherit from an interface Base and delegate all of its public methods to a specified object.
	
	More importantly, overrides work: the compiler will use your override implementations instead of those in the delegate object.

	
Delegated properties

	val lazyValue: String by lazy {
		println("computed!")
		"Hello"
	}
	
	var name: String by Delegates.observable("<no name>") {
        prop, old, new ->
        println("$old -> $new")
    }
	
	class User(val map: Map<String, Any?>) {
		val name: String by map
		val age: Int     by map
	}
	
	
	class Delegate {
		operator fun getValue(thisRef: Any?, property: KProperty<*>): String {
			return "$thisRef, thank you for delegating '${property.name}' to me!"
		}
	 
		operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {
			println("$value has been assigned to '${property.name} in $thisRef.'")
		}
	}
	class Example {
		var p: String by Delegate()
	}


:: - reflection and method reference at the same time.

	list.forEach(::println) 	- method reference
	myClass::fun1				- method reference
	this::fun1					- method reference
	
	IntroAndLang::class.java 	- reflection
	MyClass::myProp				- reflection
	MyClass::fun1				- reflection
	
	
Lambda

	Lambdas can be passed down to functions as parameters with the :: method reference syntax:
	
		class MyClass(lazyInitializer: () -> Int) {

			// passing down the lambda
			val lazyProp: Int by lazy(lazyInitializer)
			// passing down a method reference
			val lazyProp2: Int by lazy(this::createInt)

			fun createInt() = 2

			fun test(message: Int, message2: String) {
				println(this::test)
			}
		}
		
	Passing "toBeSynchronized" as a method reference to the "lock" top-level function:
		fun toBeSynchronized() = sharedResource.operation()
		val result = lock(lock, ::toBeSynchronized)
		
		Another, often more convenient way is to pass a lambda expression:
		val result = lock(lock, { sharedResource.operation() })
		val result = lock (lock) {
			sharedResource.operation()
		}
		
	We can explicitly return a value from the lambda using the qualified return syntax. Otherwise, the value of the last expression is implicitly returned. Therefore, the two following snippets are equivalent:
	ints.filter { it > 0 } // this literal is of type '(it: Int) -> Boolean'
	
	ints.filter {
		val shouldFilter = it > 0 
		// return "shouldFilter" as the value of this lambda
		shouldFilter
	}

	ints.filter {
		val shouldFilter = it > 0 
		// return "shouldFilter" as the value of this lambda
		return@filter shouldFilter
	}
		
Anonymous Functions

	One thing missing from the lambda expression syntax presented above is the ability to specify the return type of the function. In most cases, this is unnecessary because the return type can be inferred automatically. However, if you do need to specify it explicitly, you can use an alternative syntax: an anonymous function.

	fun(x: Int, y: Int): Int = x + y
	fun(x: Int, y: Int): Int {
		return x + y
	}
	ints.filter(fun(item) = item > 0)		
	
	The return type inference for anonymous functions works just like for normal functions: the return type is inferred automatically for anonymous functions with an expression body and has to be specified explicitly (or is assumed to be Unit) for anonymous functions with a block body.

	Note that anonymous function parameters are always passed inside the parentheses. The shorthand syntax allowing to leave the function outside the parentheses works only for lambda expressions.
	
	One other difference between lambda expressions and anonymous functions is the behavior of non-local returns. A return statement without a label always returns from the function declared with the fun keyword. This means that a return inside a lambda expression will return from the enclosing function, whereas a return inside an anonymous function will return from the anonymous function itself.
			fun test(message: Int, message2: String) {

				synchronized(this, fun() {
					// return from this anonymous method
					return
				})
				
				synchronized(this){
					// returns from the "test" function itself
					return
				}
			}
			
			
Function Literals with Receiver

	Kotlin provides the ability to call a function literal with a specified receiver object. Inside the body of the function literal, you can call methods on that receiver object without any additional qualifiers. This is similar to extension functions, which allow you to access members of the receiver object inside the body of the function. One of the most important examples of their usage is Type-safe Groovy-style builders.

	The type of such a function literal is a function type with receiver:
		sum : Int.(other: Int) -> Int			
		// inside the body of this function "this" is the receiver the "sum" method is invoked on
		val sum = fun Int.(other: Int): Int = this + other
		1.sum(2)	// "this" is the 1 on the left handside
		
	
	A non-literal value of a function-with-receiver type can also be assigned or passed as an argument where an ordinary function is expected that has an additional first parameter of the receiver type, and vice versa. For example, the types String.(Int) -> Boolean and (String, Int) -> Boolean are compatible:

		val represents: String.(Int) -> Boolean = { other -> toIntOrNull() == other }
		println("123".represents(123)) // true
		
	Lambda expressions can be used as function literals with receiver when the receiver type can be inferred from context.
		
		class HTML {
			fun body() { ... }
		}

		fun html(init: HTML.() -> Unit): HTML {
			val html = HTML()  // create the receiver object
			html.init()        // pass the receiver object to the lambda
			return html
		}


		html {       // lambda with receiver begins here
			body()   // calling a method on the receiver object (a HTML instance)
		}

		
Inline functions

	Note that if an inline function has no inlinable function parameters and no reified type parameters, the compiler will issue a warning, since inlining such functions is very unlikely to be beneficial (you can suppress the warning if you are sure the inlining is needed using the annotation @Suppress("NOTHING_TO_INLINE")).
	
	noinline: In case you want only some of the lambdas passed to an inline function to be inlined, you can mark some of your function parameters with the noinline modifier:
		inline fun foo(inlined: () -> Unit, noinline notInlined: () -> Unit) {
			// ...
		}
		
	Non-local returns

		In Kotlin, we can only use a normal, unqualified return to exit a named function or an anonymous function. This means that to exit a lambda, we have to use a label, and a bare return is forbidden inside a lambda, because a lambda can not make the enclosing function return:

		fun foo() {
			ordinaryFunction {
				return // ERROR: can not make `foo` return here
			}
		}
		But if the function the lambda is passed to is inlined, the return can be inlined as well, so it is allowed:

		fun foo() {
			inlineFunction {
				return // OK: the lambda is inlined
			}
		}
		Such returns (located in a lambda, but exiting the enclosing function) are called non-local returns. We are used to this sort of construct in loops, which inline functions often enclose:

		fun hasZeros(ints: List<Int>): Boolean {
			ints.forEach {
				if (it == 0) return true // returns from hasZeros
			}
			return false
		}
		
	crossinline:
		Note that some inline functions may call the lambdas passed to them as parameters not directly from the function body, but from another execution context, such as a local object or a nested function. In such cases, non-local control flow is also not allowed in the lambdas. To indicate that, the lambda parameter needs to be marked with the crossinline modifier:

		inline fun f(crossinline body: () -> Unit) {
			val f = object: Runnable {
				override fun run() = body()
			}
			// ...
		}
		
	reified:
	
		What we actually want is simply pass a type to this function, i.e. call it like this:

		treeNode.findParentOfType<MyTreeNode>()
			To enable this, inline functions support reified type parameters, so we can write something like this:

			inline fun <reified T> TreeNode.findParentOfType(): T? {
				var p = parent
				while (p != null && p !is T) {
					p = p.parent
				}
				return p as T?
			}
	
		Though reflection may not be needed in many cases, we can still use it with a reified type parameter:

			inline fun <reified T> membersOf() = T::class.members

			fun main(s: Array<String>) {
				println(membersOf<StringBuilder>().joinToString("\n"))
			}
	
	inline properties (since 1.1)

		The inline modifier can be used on accessors of properties that don't have a backing field. You can annotate individual property accessors:

		val foo: Foo
			inline get() = Foo()

		var bar: Bar
			get() = ...
			inline set(v) { ... }
		You can also annotate an entire property, which marks both of its accessors as inline:

		inline var bar: Bar
			get() = ...
			set(v) { ... }
			

Coroutines:
	https://github.com/Kotlin/kotlinx.coroutines
	Suspending functions can only be invoked from another suspending functions or from coroutine blocks - so we have to be in coroutine-context. Coroutine contexts are created by coroutine builders.
	
	Basically, coroutines are computations that can be suspended without blocking a thread.
	
	Blocking vs Suspending
		- Coroutine suspension is almost free, on the other hand. No context switch or any other involvement of the OS is required.
		- Another difference is that coroutines can not be suspended at random instructions, but rather only at so called suspension points, which are calls to specially marked functions.
			we can get into coroutine context by coroutine builders
			suspending functions can only be invoked from coroutine builders or from other suspending functions
			
		Such functions are called suspending functions, because calls to them may suspend a coroutine (the library can decide to proceed without suspension, if the result for the call in question is already available). 
		
		Suspending functions can take parameters and return values in the same manner as regular functions, but they can only be called from coroutines and other suspending functions.
		In fact, to start a coroutine, there must be at least one suspending function, and it is usually anonymous (i.e. it is a suspending lambda). Let's look at an example, a simplified async() function (from the kotlinx.coroutines library):
			fun <T> async(block: suspend () -> T)
			
			Here, async() is a regular function (not a suspending function), but the block parameter has a function type with the suspend modifier: suspend () -> T. So, when we pass a lambda to async(), it is a suspending lambda, and we can call a suspending function from it:
				async {
					doSomething(foo)
					...
				}
				
			- Note that suspending functions await() and doSomething() can not be called from a regular function like 
			- Also note that suspending functions can be virtual, and when overriding them, the suspend modifier has to be specified.
			- Extension functions (and lambdas) can also be marked suspend, just like regular ones. This enables creation of DSLs and other APIs that users can extend. 
	
	The inner workings of coroutines
		Coroutines are completely implemented through a compilation technique (no support from the VM or OS side is required), and suspension works through code transformation. Basically, every suspending function (optimizations may apply, but we'll not go into this here) is transformed to a state machine where states correspond to suspending calls. Right before a suspension, the next state is stored in a field of a compiler-generated class along with relevant local variables, etc. Upon resumption of that coroutine, local variables are restored and the state machine proceeds from the state right after suspension.
	
	
	fun main(args: Array<String>) = runBlocking<Unit> {
		val jobs = arrayListOf<Job>()
		jobs += launch(Unconfined) { // not confined -- will work with main thread
			println("      'Unconfined': I'm working in thread ${Thread.currentThread().name}")
		}
		jobs += launch(coroutineContext) { // context of the parent, runBlocking coroutine
			println("'coroutineContext': I'm working in thread ${Thread.currentThread().name}")
		}
		jobs += launch(CommonPool) { // will get dispatched to ForkJoinPool.commonPool (or equivalent)
			println("      'CommonPool': I'm working in thread ${Thread.currentThread().name}")
		}
		jobs += launch(newSingleThreadContext("MyOwnThread")) { // will get its own new thread
			println("          'newSTC': I'm working in thread ${Thread.currentThread().name}")
		}
		jobs.forEach { it.join() }
	}
	
	un main(args: Array<String>) = runBlocking<Unit> {
		val jobs = arrayListOf<Job>()
		jobs += launch(Unconfined) { // not confined -- will work with main thread
			println("      'Unconfined': I'm working in thread ${Thread.currentThread().name}")	-- main thread
			delay(500)
			println("      'Unconfined': After delay in thread ${Thread.currentThread().name}")	-- not main thread, ForkJoinPool.commonPool
		}
		jobs += launch(coroutineContext) { // context of the parent, runBlocking coroutine
			println("'coroutineContext': I'm working in thread ${Thread.currentThread().name}")	-- main thread
			delay(1000)
			println("'coroutineContext': After delay in thread ${Thread.currentThread().name}")	-- main thread
		}
		jobs.forEach { it.join() }
	}
	
	Builders:
		runBlocking
			fun <T> runBlocking(
				context: CoroutineContext = EmptyCoroutineContext, 
				block: suspend CoroutineScope.() -> T
			): T (source)
			Runs new coroutine and blocks current thread interruptibly until its completion. This function should not be used from coroutine. It is designed to bridge regular blocking code to libraries that are written in suspending style, to be used in main functions and in tests.
			
		launch
		
			fun launch(
				context: CoroutineContext = DefaultDispatcher, 
				start: CoroutineStart = CoroutineStart.DEFAULT, 
				block: suspend CoroutineScope.() -> Unit
			): Job (source)
			Launches new coroutine without blocking current thread and returns a reference to the coroutine as a Job. The coroutine is cancelled when the resulting job is cancelled.
			
		async
			fun <T> async(
				context: CoroutineContext = DefaultDispatcher, 
				start: CoroutineStart = CoroutineStart.DEFAULT, 
				block: suspend CoroutineScope.() -> T
			): Deferred<T> (source)
			Creates new coroutine and returns its future result as an implementation of Deferred.

			The running coroutine is cancelled when the resulting object is cancelled.
			
		future
			for Java 8 CompletableFuture
			https://github.com/Kotlin/kotlinx.coroutines/blob/master/integration/kotlinx-coroutines-jdk8/README.md
			
			val image: CompletableFuture<Image> = future {
				val future1 = loadImageAsync(name1) // start loading first image
				val future2 = loadImageAsync(name2) // start loading second image
				combineImages(future1.await(), future2.await()) // wait for both, combine, and return result
			}
			
		Reactive stream builders: https://github.com/Kotlin/kotlinx.coroutines/blob/master/reactive/README.md
			mono			- for Reactor
			flux
			
			rxCompletable	- for RxJava
			rxMaybe
			rxSingle
			rxObservable
			rxFlowable
			
			publish 		- for reactive streams
			
		Generators: these are shipped within kotlin-stdlib because they are related to sequences.
			buildIterator:
			buildSequence: to implement C# yield return with IEnumerable<T>
			
				val lazySeq = buildSequence {
					yield(0)
					print("START ")
					for (i in 1..5) {
						yield(i)
						print("STEP ")
					}
					print("ALMOST END")
					yieldAll(16..10)
					print("END")
				}

				for (i in lazySeq.take(10)) {

				}
			
	Scheduling:
	
		Unconfined
			A coroutine dispatcher that is not confined to any specific thread. It executes initial continuation of the coroutine right here in the current call-frame and let the coroutine resume in whatever thread that is used by the corresponding suspending function, without mandating any specific threading policy.

			Note, that if you need your coroutine to be confined to a particular thread or a thread-pool after resumption, but still want to execute it in the current call-frame until its first suspension, then you can use an optional CoroutineStart parameter in coroutine builders like launch and async setting it to the the value of CoroutineStart.UNDISPATCHED.
			
		CommonPool
			Represents common pool of shared threads as coroutine dispatcher for compute-intensive tasks. It uses java.util.concurrent.ForkJoinPool when available, which implements efficient work-stealing algorithm for its queues, so every coroutine resumption is dispatched as a separate task even when it already executes inside the pool. When available, it wraps ForkJoinPool.commonPool and provides a similar shared pool where not.
			
		newSingleThreadContext
			Creates new coroutine execution context with the a single thread and built-in yield and delay support. NOTE: The resulting ThreadPoolDispatcher owns native resources (its thread).Resources are reclaimed by ThreadPoolDispatcher.close.
			
		kotlinx.coroutines.experimental.javafx.JavaFx as UI -- for JavaFx
			 launch(UI) { // launch coroutine in UI context
				for (i in 10 downTo 1) { // countdown from 10 to 1 
					hello.text = "Countdown $i ..." // update text
					delay(500) // wait half a second
				}
				hello.text = "Done!"
			}
			
		
Iterator

	In C# the IEnumerable (or Enumerable<T>) interface is common between arrays and collections (List, HashSet, Dictionary)
		foreach: can be used on any array, collection objects that implement the IEnumerable<T> generic interface.
		
	In Java there is NO common interface between arrays and collections (List, Set, Map).
	
	Kotlin is like Java in this case.	
		for: can be used on any object that has an "iterator operator": public operator fun iterator(): Iterator<T> - T comes from the enclosing class (Array is a class in kotlin)

		
Spring

	Leveraging Kotlin nullable information in Spring annotations

		Originally based on a community contribution from Raman Gupta, Spring now takes advantage of Kotlin null-safety support to determine if an HTTP parameter is required without having to define explicitly the required 
		attribute. That means @RequestParam name: String? with be treated as not required and @RequestParam name: String as required. This is also supported on Spring Messaging @Header annotation.

		In a similar fashion, Spring bean injection with @Autowired or @Inject uses this information to know if a bean is required or not. 
			@Autowired lateinit var foo: Foo 	- implies that a bean of type Foo must be registered in the application context 
			@Autowired lateinit var foo: Foo?  	- while this won’t raise an error if such bean does not exist.
		
		Optional ctor dependencies can also be specified:
			@RestController
			@RequestMapping("/")
			class HomeController(private val superFormula: SuperFormula?) { ... }}