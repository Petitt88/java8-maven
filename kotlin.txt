https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/index.html

Scope functions: apply/with/run/also/let

	let - fun <T, R> T.let(block: (T) -> R): R
		Calls the specified function block with this value as its argument and returns its result.
		val car: Car = Person("Peter").let { Car(it.name) }
		val car: Car = this.repository.findPerson(1)?.let { Car(it.name) } ?: Car("Not found")
		
	run - fun <T, R> T.run(block: T.() -> R): R
		Calls the specified function block with this value as its receiver and returns its result.
		val car: Car = Person("Peter").run { Car(this.name) }
		
		
	with - fun <T, R> with(receiver: T, block: T.() -> R): R
		Calls the specified function block with the given receiver as its receiver and returns its result.
		val car: Car = with(Person("Peter")) { Car(this.name) }
		
	run - fun <R> run(block: () -> R): R
		Calls the specified function block and returns its result.
		val car: Car = run { Car("Peter") }


	also - fun <T> T.also(block: (T) -> Unit): T
		Calls the specified function block with this value as its argument and returns this value.
		val person: Person = Person("Peter").also { println(it.name) }
		
		val persons = mutableListOf<Person>(Person("Peter")).also {
			it.add(Person("Nora"))
			it.add(Person("Niki"))
		}
		
	apply - fun <T> T.apply(block: T.() -> Unit): T
		Calls the specified function block with this value as its receiver and returns this value.
		val person: Person = Person("Peter").apply { println(name) }
		
		val persons = mutableListOf<Person>(Person("Peter")).apply { 
			add(Person("Nora"))
			this.add(Person("Niki"))
		}
		
stdlib enums

	fun test() {
		val season: Seasons = enumValueOf<Seasons>("WINTER")
		val values: Array<Seasons> = enumValues<Seasons>()
	}

	enum class Seasons {
		WINTER,
		SUMMER,
		AUTUMN,
		SPRING
	}
	
	
Tuples
	Pair, Triple
	

Arrays, Collections

	val arr = Array(10) { Person(it) }
	val arr = arrayOf(1, 2, 3)
	val a = listOf(1, 2, 3)
	val a = mutableListOf(1, 2, 3)
	val a = ArrayList<Int>()
	val a = arrayListOf(1, 2)
	
	val a = setOf(1, 2, 3)
	val a = mutableSetOf(1, 2, 3)
	val a = HashSet<Int>()
	val a = hashSetOf(1, 2)
	
	val a = mapOf(1 to "1", 2 to "2")
	val a = mutableMapOf(Pair(1, "1"), Pair(2, "2"))
	val a = hashMapOf<Int, String>()
	val a = HashMap<Int, String>()
	
	// for lazy collections
	val a = sequenceOf(1, 2, 3)
	
	// for synchronized blocks
	synchronized - fun <R> synchronized(lock: Any, block: () -> R): R
		executes the given function block while holding the monitor of the given object lock.
		synchronized(this) {
			...
		}
	
	// try-with-resources block
	use - fun <T : AutoCloseable?, R> T.use(block: (T) -> R): R
	Executes the given block function on this resource and then closes it down correctly whether an exception is thrown or not.
		File("my.txt").inputStream().bufferedReader().use {
			it.lines().forEach { }
		}
		File("my.txt").bufferedReader().use {
			it.lines().forEach { }
		}
		
	Note that the read-only types are covariant. That means, you can take a List<Rectangle> and assign it to List<Shape> assuming Rectangle inherits from Shape. This wouldn't be allowed with the mutable collection types because it would allow for failures at runtime.
	
	val items = listOf(1, 2, 3, 4)
	items.first() == 1
	items.last() == 4
	items.filter { it % 2 == 0 }   // returns [2, 4]

	val rwList = mutableListOf(1, 2, 3)
	rwList.requireNoNulls()        // returns [1, 2, 3]
	if (rwList.none { it > 6 }) println("No items above 6")  // prints "No items above 6"
	val item = rwList.firstOrNull()
	
	// groupBy example
	class InfoFromDatabase(val catId: Long, val catName: String, val coupId: Long, val couponName: String)
	class CoupInfo(val coupId: Long, val coupName: String)
	class GroupedInfo(val catId: Long, val catName: String, val coupons: Iterable<CoupInfo>)

	val infos = listOf(1L, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)
			.map { InfoFromDatabase(catId = it % 3, catName = "CatName${it % 3}", coupId = it, couponName = "CoupoName$it") }

	val res = infos.groupBy { it.catId }
			.mapKeys {
				object {
					val catId = it.key
					val catName = it.value[0].catName
				}
			}
			.mapValues { entry ->
				entry.value.map {
					object {
						val coupId = it.coupId
						val coupName = it.couponName
					}
				}
			}
			.map { GroupedInfo(it.key.catId, it.key.catName, it.value.map { c -> CoupInfo(c.coupId, c.coupName) }) }

	val resDifferently = infos.groupBy { it.catId }
			.map { GroupedInfo(it.key, it.value[0].catName, it.value.map { c -> CoupInfo(c.coupId, c.couponName) }) }
			
			
Returns and Jumps

	val s = person.name ?: return
	
	Break and Continue Labels	
		loop@ for (i in 1..100) {
			for (j in 1..100) {
				if (...) break@loop
			}
		}

	Return at Labels: returning normally from a lambda exists the entire function to the caller. However, returning from an anonymous function returns only from that function!
		fun foo() {
			ints.forEach {
				if (it == 0) return  // nonlocal return from inside lambda directly to the caller of foo()
				print(it)
			}
		}
		
		fun foo() {
			ints.forEach lit@ {
				if (it == 0) return@lit
				print(it)
			}
		}
		
		fun foo() {
			ints.forEach {
				if (it == 0) return@forEach
				print(it)
			}
		}
		
		fun foo() {
			ints.forEach(fun(value: Int) {
				if (value == 0) return  // local return to the caller of the anonymous fun, i.e. the forEach loop
				print(value)
			})
		}
		
		
Control Flow: if, when, for, while
	If Expression
		// Traditional usage 
		var max = a 
		if (a < b) max = b
		
		// As expression 
		val max = if (a > b) a else b
		
	When Expression
		when (x) {
			0, 1 -> print("x == 0 or x == 1")
			else -> print("otherwise")
		}
		when (x) {
			in 1..10 -> print("x is in the range")
			in validNumbers -> print("x is valid")
			!in 10..20 -> print("x is outside the range")
			else -> print("none of the above")
		}
		when {
			x.isOdd() -> print("x is odd")
			x.isEven() -> print("x is even")
			else -> print("x is funny")
		}
		
	For Loops
		for (item in collection) print(item)
		
		As mentioned before, for iterates through anything that provides an iterator, i.e.
			has a member- or extension-function iterator(), whose return type
				has a member- or extension-function next(), and
				has a member- or extension-function hasNext() that returns Boolean.
			All of these three functions need to be marked as operator.
			
		for (i in array.indices) {
			print(array[i])
		}
		for ((index, value) in array.withIndex()) {
			println("the element at $index is $value")
		}
		
	While Loops
		while (x > 0) {
			x--
		}
		do {
			val y = retrieveData()
		} while (y != null) // y is visible here!
		
		
Classes and Inheritance
	Constructors
	
		Primary constructors
			A class in Kotlin can have a primary constructor and one or more secondary constructors. The primary constructor is part of the class header: it goes after the class name (and optional type parameters).
			class Person internal constructor(firstName: String) {
			}
			class Person(firstName: String) {
			}
			
			The primary constructor cannot contain any code. Initialization code can be placed in initializer blocks, which are prefixed with the init keyword:

				class Customer(name: String) {
					init {
						logger.info("Customer initialized with value ${name}")
					}
				}
				
			Note that parameters of the primary constructor can be used in the initializer blocks. They can also be used in property initializers declared in the class body:

				class Customer(name: String) {
					val customerKey = name.toUpperCase()
				}
				
			In fact, for declaring properties and initializing them from the primary constructor, Kotlin has a concise syntax:
				class Person(val firstName: String, val lastName: String, var age: Int) {
					// ...
				}
			
			If the constructor has annotations or visibility modifiers, the constructor keyword is required, and the modifiers go before it:
				class Customer public @Inject constructor(name: String) { ... }
				
		Secondary Constructors
		
			The class can also declare secondary constructors, which are prefixed with constructor:
			class Person {
				constructor(parent: Person) {
					parent.children.add(this)
				}
			}
			
			If the class has a primary constructor, each secondary constructor needs to delegate to the primary constructor, either directly or indirectly through another secondary constructor(s). Delegation to another constructor of the same class is done using the this keyword:
				class Person(val name: String) {
					constructor(name: String, parent: Person) : this(name) {
						parent.children.add(this)
					}
				}
				
	Inheritance
		All classes in Kotlin have a common superclass Any, that is a default super for a class with no supertypes declared
		
		open class Base(p: Int)
		class Derived(p: Int) : Base(p)
		
		If the class has no primary constructor, then each secondary constructor has to initialize the base type using the super keyword, or to delegate to another constructor which does that. 
			class MyView : View {
				constructor(ctx: Context) : super(ctx)
				constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)
			}
			
		Overriding methods:
			open class Base {
				open fun v() {}
				fun nv() {}
			}
			class Derived() : Base() {
				override fun v() {}
			}
			
			A member marked override is itself open, i.e. it may be overridden in subclasses. If you want to prohibit re-overriding, use final:
				open class AnotherDerived() : Base() {
					final override fun v() {}
				}
				
		Overriding Properties
			open class Foo {
				open val x: Int get() { ... }
			}
			class Bar1 : Foo() {
				override val x: Int = ...
			}
			You can also override a val property with a var property, but not vice versa. This is allowed because a val property essentially declares a getter method, and overriding it as a var additionally declares a setter method in the derived class.
			
			interface Foo {
				val count: Int
			}
			class Bar1(override val count: Int) : Foo
			class Bar2 : Foo {
				override var count: Int = 0
			}
			
		Abstract Classes
			We can override a non-abstract open member with an abstract one
			open class Base {
				open fun f() {}
			}
			abstract class Derived : Base() {
				override abstract fun f()
			}
			
	Class delegation: works only on interfaces

		The Delegation pattern has proven to be a good alternative to implementation inheritance, and Kotlin supports it natively requiring zero boilerplate code. 
		A class Derived can inherit from an interface Base and delegate all of its public methods to a specified object.
		
		Example
			interface Base {
				fun print()
			}

			class BaseImpl(val x: Int) : Base {
				override fun print() {
					print(x)
				}
			}

			class Derived(x: Int) : Base by BaseImpl(x)
			class Derived2(b: Base) : Base by b

			fun main(args: Array<String>) {
				Derived(10).print()
				Derived2(BaseImpl(10)).print() // prints 10
			}
	
		More importantly, overrides work: the compiler will use your override implementations instead of those in the delegate object, but the delegate object's implementation can still be invoked with the
			good old "super" keyword.
			
		The default functions of the interface can also be overridden!
			
		!IMPORTANT: 1. when the delegate object in its code invokes a method that the delegator overrides, still the delegate's method gets invoked!  (BaseImpl in the example above is the delegate object)
						This is because "this" points to the delegate object, not to the delegator!
						The overridden method in the delegator gets invoked only and only if "this" points to the delegator: which happens only if the code execution STARTS at the delegator itself. (delegator are Derived and Derived2 in the example above)
							- If the interface is the starting point (or the delegate object itself but this is obvious) then "this" is the delegate object and there is no way to get into the delegator.
			Example
			
				fun main(args: Array<String>) {
					val der = Derived(666)

					// prints out Derived\nBase
					// in spite of BaseImpl overrides the "notAbstractPrint" method, the super.notAbstractPrint() call in Derived invokes the Base interface
					der.notAbstractPrint()
					println()

					// prints BaseImpl666 as expected
					der.print()
					println()

					// prints "BaseImpl" because BaseImpl overrides printWithInvoke() and "this" points to the BaseImpl object - because Derived does not override the method
					// even if it didn't override it, the result would still be "BaseImpl" because BaseImpl overrides the "notAbstractPrint()" method as well
					der.printWithInvoke()
				}


				interface Base {
					fun print()

					fun notAbstractPrint() {
						println("Base")
					}

					fun printWithInvoke() = notAbstractPrint()
				}

				class BaseImpl(val x: Int) : Base {
					override fun print() {
						println("BaseImpl$x")
					}

					override fun notAbstractPrint() {
						println("BaseImpl")
					}
				}

				class Derived(x: Int) : Base by BaseImpl(x) {
					override fun notAbstractPrint() {
						println("Derived")
						super.notAbstractPrint()
					}
				}

Object Expressions and Declarations

	Object expressions
		To create an object of an anonymous class that inherits from some type (or types), we write:
		
		window.addMouseListener(object : MouseAdapter() {
			override fun mouseClicked(e: MouseEvent) {
				// ...
			}

			override fun mouseEntered(e: MouseEvent) {
				// ...
			}
		})
		
		open class A(x: Int) {
			public open val y: Int = x
		}

		interface B {...}

		val ab: A = object : A(1), B {
			override val y = 15
		}
		
	Object declarations
		Singleton is a very useful pattern, and Kotlin (after Scala) makes it easy to declare singletons:
		object DataProviderManager {
			fun registerDataProvider(provider: DataProvider) {
				// ...
			}

			val allDataProviders: Collection<DataProvider>
				get() = // ...
		}
		DataProviderManager.registerDataProvider(...)
		object DefaultListener : MouseAdapter() {
			override fun mouseClicked(e: MouseEvent) {
				// ...
			}

			override fun mouseEntered(e: MouseEvent) {
				// ...
			}
		}
		
	Semantic difference between object expressions and declarations
		There is one important semantic difference between object expressions and object declarations:

		- object expressions are executed (and initialized) immediately, where they are used;
		- object declarations are initialized lazily, when accessed for the first time;
		- a companion object is initialized when the corresponding class is loaded (resolved), matching the semantics of a Java static initializer.


Interfaces

	Interfaces in Kotlin are very similar to Java 8. They can contain declarations of abstract methods, as well as method implementations. 
	What makes them different from abstract classes is that interfaces cannot store state. They can have properties but these need to be abstract or to provide accessor implementations.

		interface MyInterface {
			fun bar()
			fun foo() {
			  // optional body
			}
		}
		class Child : MyInterface {
			override fun bar() {
				// body
			}
		}
	
	Properties in Interfaces
		interface MyInterface {
			val prop: Int // abstract

			val propertyWithImplementation: String
				get() = "foo"

			fun foo() {
				print(prop)
			}
		}

		class Child : MyInterface {
			override val prop: Int = 29
		}


Properties and Fields

	The initializer, getter and setter are optional. Property type is optional if it can be inferred from the initializer (or from the getter return type, as shown below).
		var allByDefault: Int? // error: explicit initializer required, default getter and setter implied
		var initialized = 1 // has type Int, default getter and setter
		
	The full syntax of a read-only property declaration differs from a mutable one in two ways: it starts with val instead of var and does not allow a setter:
		val simple: Int? // has type Int, default getter, must be initialized in constructor
		val inferredType = 1 // has type Int and a default getter
		
	We can write custom accessors, very much like ordinary functions, right inside a property declaration. Here's an example of a custom getter:
		val isEmpty: Boolean
			get() = this.size == 0
			
		var stringRepresentation: String
			get() = this.toString()
			set(value) {
				setDataFromString(value) // parses the string and assigns values to other properties
			}
			
		If you need to change the visibility of an accessor or to annotate it, but don't need to change the default implementation, you can define the accessor without defining its body:

			var setterVisibility: String = "abc"
				private set // the setter is private and has the default implementation

			var setterWithAnnotation: Any? = null
				@Inject set // annotate the setter with Inject
				
	Backing Fields
		Classes in Kotlin cannot have fields. However, sometimes it is necessary to have a backing field when using custom accessors.
		For these purposes, Kotlin provides an automatic backing field which can be accessed using the field identifier.
		
		var identityProp: Int = 0
			get() = field
			set(value) {
				field = value
			}
			
	Compile-Time Constants

		Properties the value of which is known at compile time can be marked as compile time constants using the const modifier. Such properties need to fulfil the following requirements:
			- Top-level or member of an object
			- Initialized with a value of type String or a primitive type
			- No custom getter
			
		Such properties can be used in annotations:
			const val SUBSYSTEM_DEPRECATED: String = "This subsystem is deprecated"
			@Deprecated(SUBSYSTEM_DEPRECATED) fun foo() { ... }
		
	Backing Properties

		If you want to do something that does not fit into this "implicit backing field" scheme, you can always fall back to having a backing property:
		private var _table: Map<String, Int>? = null
		public val table: Map<String, Int>
			get() {
				if (_table == null) {
					_table = HashMap() // Type parameters are inferred
				}
				return _table ?: throw AssertionError("Set to null by another thread")
			}
			
	Late-Initialized Properties and Variables
		Normally, properties declared as having a non-null type must be initialized in the constructor. 
		However, fairly often this is not convenient. For example, properties can be initialized through dependency injection, or in the setup method of a unit test. 
		In this case, you cannot supply a non-null initializer in the constructor, but you still want to avoid null checks when referencing the property inside the body of a class.

		To handle this case, you can mark the property with the lateinit modifier:
			lateinit var subject: TestSubject
			
		Checking whether a lateinit var is initialized (since 1.2)
			if (foo::bar.isInitialized) {
				println(foo.bar)
			}
			

Data Classes
	We frequently create classes whose main purpose is to hold data. In such a class some standard functionality and utility functions are often mechanically derivable from the data. In Kotlin, this is called a data class and is marked as data:

		data class User(val name: String, val age: Int)
		
	The compiler automatically derives the following members from all properties declared in the primary constructor:
		- equals()/hashCode() pair;
		- toString() of the form "User(name=John, age=42)";
		- componentN() functions corresponding to the properties in their order of declaration;
		- copy() function (see below)
		
	Data Classes and Destructuring Declarations

		Component functions generated for data classes enable their use in destructuring declarations:
			val jane = User("Jane", 35) 
			val (name, age) = jane
			println("$name, $age years of age") // prints "Jane, 35 years of age"
			
			
Sealed Classes
	To declare a sealed class, you put the sealed modifier before the name of the class. A sealed class can have subclasses, but all of them must be declared in the same file as the sealed class itself. (Before Kotlin 1.1, the rules were even more strict: classes had to be nested inside the declaration of the sealed class).
	
		sealed class Expr
		data class Const(val number: Double) : Expr()
		data class Sum(val e1: Expr, val e2: Expr) : Expr()
		object NotANumber : Expr()
		
	Example 1
		fun eval(expr: Expr): Double = when(expr) {
			is Const -> expr.number
			is Sum -> eval(expr.e1) + eval(expr.e2)
			NotANumber -> Double.NaN
			// the `else` clause is not required because we've covered all the cases
		}
		
	Example 2
		fun test() {
			val hTry = Try.create()
			// invoke operator on the Try instance
			val res = hTry { 3 }
			// invoke operator in Try's companion object
			val res2 = Try { "result" }
			
			fun getData() = 32
			val res3 = Try(::getData)
			
			when (res) {
				is Try.Success<*> -> println(res.value)
				is Try.Fail -> println(res.error)
			}
		}

		sealed class Try {

			operator fun <T> invoke(body: () -> T): Try =
					try {
						Success(body())
					} catch (e: Exception) {
						Fail(e)
					}

			companion object {

				fun create(): Try = Success(0)

				operator fun <T> invoke(body: () -> T): Try =
						try {
							Success(body())
						} catch (e: Exception) {
							Fail(e)
						}
			}


			class Success<T>(val value: T) : Try()
			class Fail(val error: Exception) : Try()
		}


Enum Classes
	The most basic usage of enum classes is implementing type-safe enums:

		enum class Direction {
			NORTH, SOUTH, WEST, EAST
		}
		
	Initialization

		Since each enum is an instance of the enum class, they can be initialized as:
			enum class Color(val rgb: Int) {
					RED(0xFF0000),
					GREEN(0x00FF00),
					BLUE(0x0000FF)
			}
			
	Anonymous Classes

		Enum constants can also declare their own anonymous classes:
			enum class ProtocolState {
				WAITING {
					override fun signal() = TALKING
				},

				TALKING {
					override fun signal() = WAITING
				};

				abstract fun signal(): ProtocolState
			}
		
	Working with Enum Constants
	
		Just like in Java, enum classes in Kotlin have synthetic methods allowing to list the defined enum constants and to get an enum constant by its name. The signatures of these methods are as follows (assuming the name of the enum class is EnumClass):

			EnumClass.valueOf(value: String): EnumClass
			EnumClass.values(): Array<EnumClass>
	
		Since Kotlin 1.1, it's possible to access the constants in an enum class in a generic way, using the enumValues<T>() and enumValueOf<T>() functions:
			enum class RGB { RED, GREEN, BLUE }

			inline fun <reified T : Enum<T>> printAllValues() {
				print(enumValues<T>().joinToString { it.name })
			}

			printAllValues<RGB>() // prints RED, GREEN, BLUE
			
		Every enum constant has properties to obtain its name and position in the enum class declaration:

			val name: String
			val ordinal: Int
			The enum constants also implement the Comparable interface, with the natural order being the order in which they are defined in the enum class.


Type casts, smart casts

	// x is automatically cast to string on the right-hand side of `&&`
    if (x is String && x.length > 0) {
        print(x.length) // x is automatically cast to String
    }
	
	if (x !is String) return
    print(x.length) // x is automatically cast to String
	
	
	Such smart casts work for when-expressions and while-loops as well:
		when (x) {
			is Int -> print(x + 1)
			is String -> print(x.length + 1)
			is IntArray -> print(x.sum())
		}
	
	Note that smart casts do not work when the compiler cannot guarantee that the variable cannot change between the check and the usage. More specifically, smart casts are applicable according to the following rules:
		val local variables - always;
		val properties - if the property is private or internal or the check is performed in the same module where the property is declared. Smart casts aren't applicable to open properties or properties that have custom getters;
		var local variables - if the variable is not modified between the check and the usage and is not captured in a lambda that modifies it;
		var properties - never (because the variable can be modified at any time by other code).
		
	"Unsafe" cast operator: "as"
		Usually, the cast operator throws an exception if the cast is not possible. Thus, we call it unsafe. The unsafe cast in Kotlin is done by the infix operator as (see operator precedence):
		val x: String = y as String
		
		Note that null cannot be cast to String as this type is not nullable, i.e. if y is null, the code above throws an exception. In order to match Java cast semantics we have to have nullable type at cast right hand side, like:
			val x: String? = y as String?
			
	"Safe" (nullable) cast operator: "as?"
		To avoid an exception being thrown, one can use a safe cast operator as? that returns null on failure:
		val x: String? = y as? String
			Note that despite the fact that the right-hand side of as? is a non-null type String the result of the cast is nullable.
			
Variable number of arguments (Varargs)
	fun foo(vararg strings: String) { /* ... */ }
	foo(strings = *arrayOf("a", "b", "c"))
	
	
	fun <T> asList(vararg ts: T): List<T> {
		val result = ArrayList<T>()
		for (t in ts) // ts is an Array
			result.add(t)
		return result
	}
	val list = asList(1, 2, 3)
			
			
Ranges
	Range expressions are formed with rangeTo functions that have the operator form .. which is complemented by in and !in. Range is defined for any comparable type, but for integral primitive types it has an optimized implementation. Here are some examples of using ranges:
	
	val range = 1.rangeTo(10)	// this is equivalent to using the ".." operator: 1..10
	if (i in 1..10) { // equivalent of 1 <= i && i <= 1
		println(i)
	}
	
	outer@ for (i in 1..5) {
		for (j in 10 downTo 1) {
			if (j == 4) break@outer	// break out from the outer@ label
		}
	}
	
	for (i in 1..4) print(i) // prints "1234"
	for (i in 4..1) print(i) // prints nothing
		for (i in 4 downTo 1) print(i) // prints "4321"
	for (i in 1..4 step 2) print(i) // prints "13"
	for (i in 4 downTo 1 step 2) print(i) // prints "42"
	
	To create a range which does not include its end element, you can use the until function:
		for (i in 1 until 10) { // i in [1, 10), 10 is excluded
			 println(i)
		}
	for(i in (10 downTo 1).reversed()) {
		...
	}
		
	How it works
		Ranges implement a common interface in the library: ClosedRange<T>.
		ClosedRange<T> denotes a closed interval in the mathematical sense, defined for comparable types. It has two endpoints: start and endInclusive, which are included in the range. The main operation is contains, usually used in the form of in/!in operators.

	
Delegated properties

	val lazyValue: String by lazy {
		println("computed!")
		"Hello"
	}
	
	var name: String by Delegates.observable("<no name>") {
        prop, old, new ->
        println("$old -> $new")
    }
	
	class User(val map: Map<String, Any?>) {
		val name: String by map
		val age: Int     by map
	}
	
	Custom property delegate
	
		/** Property delegates examples: to override getters and setters. */
		class ExampleCustomDelegates {
			var p: String by Delegate()
			var p2: LocalDateTime by TypedDelegate()

			class Delegate {
				operator fun getValue(thisRef: Any?, property: KProperty<*>): String {
					return "$thisRef, thank you for delegating '${property.name}' to me!"
				}

				operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {
					println("$value has been assigned to '${property.name} in $thisRef.'")
				}
			}

			class TypedDelegate : ReadWriteProperty<ExampleCustomDelegates, LocalDateTime> {
				override fun getValue(thisRef: ExampleCustomDelegates, property: KProperty<*>): LocalDateTime {
					TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
				}

				override fun setValue(thisRef: ExampleCustomDelegates, property: KProperty<*>, value: LocalDateTime) {
					TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
				}
			}
		}
		
	Custom property delegation example from Exposed:
		fun <T:Any> transactionScope(init: () -> T) = TransactionStore(init) as ReadWriteProperty<Any?, T>
		fun <T:Any> nullableTransactionScope() = TransactionStore<T>()

		class TransactionStore<T:Any>(val init: (() -> T)? = null) : ReadWriteProperty<Any?, T?> {

			private val key = Key<T>()

			@Suppress("UNCHECKED_CAST")
			override fun getValue(thisRef: Any?, property: KProperty<*>): T? {
				val currentOrNullTransaction = TransactionManager.currentOrNull()
				return init?.let { currentOrNullTransaction!!.getOrCreate(key, init) } ?: currentOrNullTransaction?.getUserData(key)
			}

			override fun setValue(thisRef: Any?, property: KProperty<*>, value: T?) {
				TransactionManager.currentOrNull()?.let{
					if (value == null)
						it.removeUserData(key)
					else
						it.putUserData(key, value)
				}
			}
		}
		
		usage: private val events by transactionScope { CopyOnWriteArrayList<EntityChange<*>>() }



:: - reflection and method reference at the same time.

	list.forEach(::println) 	- method reference: it is bound to its receiver
	myClass::fun1				- method reference, bound function to its receiver (to the MyClass instance)
	this::fun1					- method reference, bound function to its receiver
	
	IntroAndLang::class.java 	- reflection
	MyClass::myProp				- reflection, unbound property
	MyClass::fun1				- reflection, unbound function
	
	
Lambda

	Lambdas can be passed down to functions as parameters with the :: method reference syntax:
	
		class MyClass(lazyInitializer: () -> Int) {

			// passing down the lambda
			val lazyProp: Int by lazy(lazyInitializer)
			// passing down a method reference
			val lazyProp2: Int by lazy(this::createInt)

			fun createInt() = 2

			fun test(message: Int, message2: String) {
				println(this::test)
			}
		}
		
	Interesting: lambda vs local function
	
		class Wrapper {
			fun test() {
				val lamb = { s: String ->
					// this is Wrapper
				}
				lamb("par")

				val lamb2: (s: String) -> Unit = { s ->  }
				lamb2("named_par")

				val func = fun String.(s: String) {
					// this is the string receiver!
				}
				func("receiver", "par")
				"receiver".func("par")
				
				val functionalInterface = Function<String, Int> { param -> 3 }
				functionalInterface.apply("Java functional interface implementation example. Casting needed.")
			}
		}
		
	Passing "toBeSynchronized" as a method reference to the "lock" top-level function:
		fun toBeSynchronized() = sharedResource.operation()
		val result = lock(lock, ::toBeSynchronized)
		
		Another, often more convenient way is to pass a lambda expression:
		val result = lock(lock, { sharedResource.operation() })
		val result = lock (lock) {
			sharedResource.operation()
		}
		
	We can explicitly return a value from the lambda using the qualified return syntax. Otherwise, the value of the last expression is implicitly returned. Therefore, the two following snippets are equivalent:
	ints.filter { it > 0 } // this literal is of type '(it: Int) -> Boolean'
	
	ints.filter {
		val shouldFilter = it > 0 
		// return "shouldFilter" as the value of this lambda
		shouldFilter
	}

	ints.filter {
		val shouldFilter = it > 0 
		// return "shouldFilter" as the value of this lambda
		return@filter shouldFilter
	}
		
Anonymous Functions

	One thing missing from the lambda expression syntax presented above is the ability to specify the return type of the function. In most cases, this is unnecessary because the return type can be inferred automatically. However, if you do need to specify it explicitly, you can use an alternative syntax: an anonymous function.

	fun(x: Int, y: Int): Int = x + y
	fun(x: Int, y: Int): Int {
		return x + y
	}
	ints.filter(fun(item) = item > 0)		
	
	The return type inference for anonymous functions works just like for normal functions: the return type is inferred automatically for anonymous functions with an expression body and has to be specified explicitly (or is assumed to be Unit) for anonymous functions with a block body.

	Note that anonymous function parameters are always passed inside the parentheses. The shorthand syntax allowing to leave the function outside the parentheses works only for lambda expressions.
	
	One other difference between lambda expressions and anonymous functions is the behavior of non-local returns. A return statement without a label always returns from the function declared with the fun keyword. This means that a return inside a lambda expression will return from the enclosing function, whereas a return inside an anonymous function will return from the anonymous function itself.
			fun test(message: Int, message2: String) {

				synchronized(this, fun() {
					// return from this anonymous method
					return
				})
				
				synchronized(this) {
					// returns from the "test" function itself
					return
				}
			}
			
			
Function Literals with Receiver

	Kotlin provides the ability to call a function literal with a specified receiver object. Inside the body of the function literal, you can call methods on that receiver object without any additional qualifiers. This is similar to extension functions, which allow you to access members of the receiver object inside the body of the function. One of the most important examples of their usage is Type-safe Groovy-style builders.

	The type of such a function literal is a function type with receiver:
		sum : Int.(other: Int) -> Int			
		// inside the body of this function "this" is the receiver the "sum" method is invoked on
		val sum = fun Int.(other: Int): Int = this + other
		1.sum(2)	// "this" is the 1 on the left handside
		
	
	A non-literal value of a function-with-receiver type can also be assigned or passed as an argument where an ordinary function is expected that has an additional first parameter of the receiver type, and vice versa. For example, the types String.(Int) -> Boolean and (String, Int) -> Boolean are compatible:

		val represents: String.(Int) -> Boolean = { other -> toIntOrNull() == other }
		println("123".represents(123)) // true
		
	Lambda expressions can be used as function literals with receiver when the receiver type can be inferred from context.
		
		class HTML {
			fun body() { ... }
		}

		fun html(init: HTML.() -> Unit): HTML {
			val html = HTML()  // create the receiver object
			html.init()        // pass the receiver object to the lambda
			return html
		}


		html {       // lambda with receiver begins here
			body()   // calling a method on the receiver object (a HTML instance)
		}
	
	
Function literals with receiver new:
	Function types with receiver, such as A.(B) -> C, can be instantiated with a special form of function literals – function literals with receiver.

	As said above, Kotlin provides the ability to call an instance of a function type with receiver providing the receiver object.

	Inside the body of the function literal, the receiver object passed to a call becomes an implicit this, so that you can access the members of that receiver object without any additional qualifiers, or access the receiver object using a this expression.

	This behavior is similar to extension functions, which also allow you to access the members of the receiver object inside the body of the function.

	Here is an example of a function literal with receiver along with its type, where plus is called on the receiver object:

	val sum: Int.(Int) -> Int = { other -> plus(other) } 
	The anonymous function syntax allows you to specify the receiver type of a function literal directly. This can be useful if you need to declare a variable of a function type with receiver, and to use it later.

	val sum = fun Int.(other: Int): Int = this + other
	Lambda expressions can be used as function literals with receiver when the receiver type can be inferred from context. One of the most important examples of their usage is type-safe builders:

	class HTML {
		fun body() { ... }
	}

	fun html(init: HTML.() -> Unit): HTML {
		val html = HTML()  // create the receiver object
		html.init()        // pass the receiver object to the lambda
		return html
	}

	html {       // lambda with receiver begins here
		body()   // calling a method on the receiver object
	}

		
Inline functions

	Note that if an inline function has no inlinable function parameters and no reified type parameters, the compiler will issue a warning, since inlining such functions is very unlikely to be beneficial (you can suppress the warning if you are sure the inlining is needed using the annotation @Suppress("NOTHING_TO_INLINE")).
	
	noinline: In case you want only some of the lambdas passed to an inline function to be inlined, you can mark some of your function parameters with the noinline modifier:
		inline fun foo(inlined: () -> Unit, noinline notInlined: () -> Unit) {
			// ...
		}
		
	Non-local returns

		In Kotlin, we can only use a normal, unqualified return to exit a named function or an anonymous function. This means that to exit a lambda, we have to use a label, and a bare return is forbidden inside a lambda, because a lambda can not make the enclosing function return:

		fun foo() {
			ordinaryFunction {
				return // ERROR: can not make `foo` return here
			}
		}
		But if the function the lambda is passed to is inlined, the return can be inlined as well, so it is allowed:

		fun foo() {
			inlineFunction {
				return // OK: the lambda is inlined
			}
		}
		Such returns (located in a lambda, but exiting the enclosing function) are called non-local returns. We are used to this sort of construct in loops, which inline functions often enclose:

		fun hasZeros(ints: List<Int>): Boolean {
			ints.forEach {
				if (it == 0) return true // returns from hasZeros
			}
			return false
		}
		
	crossinline:
		Note that some inline functions may call the lambdas passed to them as parameters not directly from the function body, but from another execution context, such as a local object or a nested function. In such cases, non-local control flow is also not allowed in the lambdas. To indicate that, the lambda parameter needs to be marked with the crossinline modifier:

		inline fun f(crossinline body: () -> Unit) {
			val f = object: Runnable {
				override fun run() = body()
			}
			// ...
		}
		
	reified: marks a type parameter of an inline function as accessible at runtime
	
		What we actually want is simply pass a type to this function, i.e. call it like this:

		treeNode.findParentOfType<MyTreeNode>()
			To enable this, inline functions support reified type parameters, so we can write something like this:

			inline fun <reified T> TreeNode.findParentOfType(): T? {
				var p = parent
				while (p != null && p !is T) {
					p = p.parent
				}
				return p as T?
			}
		
		We qualified the type parameter with the reified modifier, now it’s accessible inside the function, almost as if it were a normal class. Since the function is inlined, no reflection is needed, normal operators like !is and as are working now. Also, we can call it as mentioned above: myTree.findParentOfType<MyTreeNodeType>().
		
		Though reflection may not be needed in many cases, we can still use it with a reified type parameter:

			inline fun <reified T> membersOf() = T::class.members

			fun main(s: Array<String>) {
				println(membersOf<StringBuilder>().joinToString("\n"))
			}
	
	inline properties (since 1.1)

		The inline modifier can be used on accessors of properties that don't have a backing field. You can annotate individual property accessors:

		val foo: Foo
			inline get() = Foo()

		var bar: Bar
			get() = ...
			inline set(v) { ... }
		You can also annotate an entire property, which marks both of its accessors as inline:

		inline var bar: Bar
			get() = ...
			set(v) { ... }
			
			
Function types: https://kotlinlang.org/docs/reference/lambdas.html#function-types
	Kotlin uses a family of function types like (Int) -> String for declarations that deal with functions: val onClick: () -> Unit = ...
	- All function types have a parenthesized parameter types list and a return type: (A, B) -> C denotes a type that represents functions taking two arguments of types A and B and returning a value of type C. The parameter types list may be empty, as in () -> A. The Unit return type cannot be omitted.
	- Function types can optionally have an additional receiver type, which is specified before a dot in the notation: the type A.(B) -> C represents functions that can be called on a receiver object of A with a parameter of B and return a value of C. Function literals with receiver are often used along with these types.
	- Suspending functions belong to function types of a special kind, which have a suspend modifier in the notation, such as suspend () -> Unit or suspend A.(B) -> C.
	- To specify that a function type is nullable, use parentheses: ((Int, Int) -> Int)?
	- Function types can be combined using parentheses: (Int) -> ((Int) -> Unit) - Higher-order function
	- The arrow notation is right-associative, (Int) -> (Int) -> Unit is equivalent to the previous example, but not to ((Int) -> (Int)) -> Unit.
	
	Instantiating a function type
	
		- Using a code block within a function literal, in one of the forms:
			- a lambda expression: { a, b -> a + b }
			- an anonymous function: fun(s: String): Int { return s.toIntOrNull() ?: 0 }
		- Using a callable reference to an existing declaration:
			- a top-level, local, member, or extension function: ::isOdd, String::toInt,
			- a top-level, member, or extension property: List<Int>::size,
			- a	constructor: ::Regex
			These include bound callable references that point to a member of a particular instance: foo::toString.
				val to = Foo::toString
				val foo = Foo()
				val to2 = foo::toString
				
				to(foo)
				to2()
		- Using instances of a custom class that implements a function type as an interface:
			class IntTransformer: (Int) -> Int {
				override operator fun invoke(x: Int): Int = TODO()
			}
				
			val intFunction: (Int) -> Int = IntTransformer() 
			intFunction(300)
			
	Non-literal values of function types with and without receiver are interchangeable, so that the receiver can stand in for the first parameter, and vice versa. For instance, a value of type (A, B) -> C can be passed or assigned where a A.(B) -> C is expected and the other way around:
	
		val repeat: String.(Int) -> String = { times -> repeat(times) }
		val twoParameters: (String, Int) -> String = repeat // OK

		fun runTransformation(f: (String, Int) -> String): String {
			return f("hello", 3)
		}
		val result = runTransformation(repeat) // OK
		
	
	Invoking a function type instance
	
		A value of a function type can be invoked by using its invoke(...) operator: f.invoke(x) or just f(x).
		If the value has a receiver type, the receiver object should be passed as the first argument. Another way to invoke a value of a function type with receiver is to prepend it with the receiver object, as if the value were an extension function: 1.foo(2)
		
		Example:
			val stringPlus: (String, String) -> String = String::plus
			val intPlus: Int.(Int) -> Int = Int::plus

			println(stringPlus.invoke("<-", "->"))
			println(stringPlus("Hello, ", "world!")) 

			println(intPlus.invoke(1, 1))
			println(intPlus(1, 2))
			println(2.intPlus(3)) // extension-like call
			

Coroutines:
	https://github.com/Kotlin/kotlinx.coroutines
	Suspending functions can only be invoked from another suspending functions or from coroutine blocks - so we have to be in coroutine-context. Coroutine contexts are created by coroutine builders.
	
	Basically, coroutines are computations that can be suspended without blocking a thread.
	
	Blocking vs Suspending
		- Coroutine suspension is almost free, on the other hand. No context switch or any other involvement of the OS is required.
		- Another difference is that coroutines can not be suspended at random instructions, but rather only at so called suspension points, which are calls to specially marked functions.
			we can get into coroutine context by coroutine builders
			suspending functions can only be invoked from coroutine builders or from other suspending functions
			
		Such functions are called suspending functions, because calls to them may suspend a coroutine (the library can decide to proceed without suspension, if the result for the call in question is already available). 
		
		Suspending functions can take parameters and return values in the same manner as regular functions, but they can only be called from coroutines and other suspending functions.
		In fact, to start a coroutine, there must be at least one suspending function, and it is usually anonymous (i.e. it is a suspending lambda). Let's look at an example, a simplified async() function (from the kotlinx.coroutines library):
			fun <T> async(block: suspend () -> T)
			
			Here, async() is a regular function (not a suspending function), but the block parameter has a function type with the suspend modifier: suspend () -> T. So, when we pass a lambda to async(), it is a suspending lambda, and we can call a suspending function from it:
				val deferred = async {
					doSomething(foo)
					...
					5
				}
				val result: Int = deferred.await()
				deferred.cancel()
				
			- Note that suspending functions await() and doSomething() can not be called from a regular function like 
			- Also note that suspending functions can be virtual, and when overriding them, the suspend modifier has to be specified.
			- Extension functions (and lambdas) can also be marked suspend, just like regular ones. This enables creation of DSLs and other APIs that users can extend. 
	
	The inner workings of coroutines
		Coroutines are completely implemented through a compilation technique (no support from the VM or OS side is required), and suspension works through code transformation. Basically, every suspending function (optimizations may apply, but we'll not go into this here) is transformed to a state machine where states correspond to suspending calls. Right before a suspension, the next state is stored in a field of a compiler-generated class along with relevant local variables, etc. Upon resumption of that coroutine, local variables are restored and the state machine proceeds from the state right after suspension.
	
	
	fun main(args: Array<String>) = runBlocking<Unit> {
		val jobs = arrayListOf<Job>()
		jobs += launch(Unconfined) { // not confined -- will work with main thread
			println("      'Unconfined': I'm working in thread ${Thread.currentThread().name}")
		}
		jobs += launch(coroutineContext) { // context of the parent, runBlocking coroutine
			println("'coroutineContext': I'm working in thread ${Thread.currentThread().name}")
		}
		jobs += launch(CommonPool) { // will get dispatched to ForkJoinPool.commonPool (or equivalent)
			println("      'CommonPool': I'm working in thread ${Thread.currentThread().name}")
		}
		jobs += launch(newSingleThreadContext("MyOwnThread")) { // will get its own new thread
			println("          'newSTC': I'm working in thread ${Thread.currentThread().name}")
		}
		jobs.forEach { it.join() }
	}
	
	fun main(args: Array<String>) = runBlocking<Unit> {
		val jobs = arrayListOf<Job>()
		jobs += launch(Unconfined) { // not confined -- will work with main thread
			println("      'Unconfined': I'm working in thread ${Thread.currentThread().name}")	-- main thread
			delay(500)
			println("      'Unconfined': After delay in thread ${Thread.currentThread().name}")	-- not main thread, ForkJoinPool.commonPool
		}
		jobs += launch(coroutineContext) { // context of the parent, runBlocking coroutine
			println("'coroutineContext': I'm working in thread ${Thread.currentThread().name}")	-- main thread
			delay(1000)
			println("'coroutineContext': After delay in thread ${Thread.currentThread().name}")	-- main thread
		}
		jobs.forEach { it.join() }
		jobs.forEach { it.cancel() }
	}
	
	Builders:
		runBlocking
			fun <T> runBlocking(
				context: CoroutineContext = EmptyCoroutineContext, 
				block: suspend CoroutineScope.() -> T
			): T (source)
			Runs new coroutine and blocks current thread interruptibly until its completion. This function should not be used from coroutine. It is designed to bridge regular blocking code to libraries that are written in suspending style, to be used in main functions and in tests.
			
		launch
			fun launch(
				context: CoroutineContext = DefaultDispatcher, 
				start: CoroutineStart = CoroutineStart.DEFAULT, 
				block: suspend CoroutineScope.() -> Unit
			): Job (source)
			Launches new coroutine without blocking current thread and returns a reference to the coroutine as a Job. The coroutine is cancelled when the resulting job is cancelled.
			It's like a fire-and-forget model.
			
		async
			fun <T> async(
				context: CoroutineContext = DefaultDispatcher, 
				start: CoroutineStart = CoroutineStart.DEFAULT, 
				block: suspend CoroutineScope.() -> T
			): Deferred<T> (source)
			Creates new coroutine and returns its future result as an implementation of Deferred. Deferred inherits from Job.
			The running coroutine is cancelled when the resulting object is cancelled.
			
		future
			for Java 8 CompletableFuture
			https://github.com/Kotlin/kotlinx.coroutines/blob/master/integration/kotlinx-coroutines-jdk8/README.md
			
			val image: CompletableFuture<Image> = future {
				val future1 = loadImageAsync(name1) // start loading first image
				val future2 = loadImageAsync(name2) // start loading second image
				combineImages(future1.await(), future2.await()) // wait for both, combine, and return result
			}
			
		Reactive stream builders: https://github.com/Kotlin/kotlinx.coroutines/blob/master/reactive/README.md
			mono			- for Reactor
			flux
			
			rxCompletable	- for RxJava
			rxMaybe
			rxSingle
			rxObservable
			rxFlowable
			
			publish 		- for reactive streams
			
		Generators: these are shipped within kotlin-stdlib because they are related to sequences.
			buildIterator:
			buildSequence: to implement C# yield return with IEnumerable<T>
			
				val lazySeq = buildSequence {
					yield(0)
					print("START ")
					for (i in 1..5) {
						yield(i)
						print("STEP ")
					}
					print("ALMOST END")
					yieldAll(16..10)
					print("END")
				}

				for (i in lazySeq.take(10)) {

				}
			
	Scheduling:
	
		Unconfined
			A coroutine dispatcher that is not confined to any specific thread. It executes initial continuation of the coroutine right here in the current call-frame and let the coroutine resume in whatever thread that is used by the corresponding suspending function, without mandating any specific threading policy.

			Note, that if you need your coroutine to be confined to a particular thread or a thread-pool after resumption, but still want to execute it in the current call-frame until its first suspension, then you can use an optional CoroutineStart parameter in coroutine builders like launch and async setting it to the the value of CoroutineStart.UNDISPATCHED.
			
		CommonPool
			Represents common pool of shared threads as coroutine dispatcher for compute-intensive tasks. It uses java.util.concurrent.ForkJoinPool when available, which implements efficient work-stealing algorithm for its queues, so every coroutine resumption is dispatched as a separate task even when it already executes inside the pool. When available, it wraps ForkJoinPool.commonPool and provides a similar shared pool where not.
			
		newSingleThreadContext
			Creates new coroutine execution context with the a single thread and built-in yield and delay support. NOTE: The resulting ThreadPoolDispatcher owns native resources (its thread).Resources are reclaimed by ThreadPoolDispatcher.close.
			
		kotlinx.coroutines.experimental.javafx.JavaFx as UI -- for JavaFx
			 launch(UI) { // launch coroutine in UI context
				for (i in 10 downTo 1) { // countdown from 10 to 1 
					hello.text = "Countdown $i ..." // update text
					delay(500) // wait half a second
				}
				hello.text = "Done!"
			}
			
			
	Final Coroutine API:
		- When a coroutine is cancelled using Job.cancel without a cause (job.cancel()), it terminates, but it does not cancel its parent.
			- Cancelling without cause is a mechanism for parent to cancel its children without cancelling itself.
			- But when the parent is cancelled, it cancels all of his children as well automatically. 
			  That's why it is important to use the current coroutineScope.launch/async when creating new children instead of using the GlobalScope - which the parent cannot track, thus cannot cancel either it itself gets cancelled.
		- If a coroutine encounters exception other than CancellationException, it cancels its parent with that exception. 
			- This behaviour cannot be overridden and is used to provide stable coroutines hierarchies for structured concurrency which do not depend on CoroutineExceptionHandler implementation.
			
		Exception propagation
			Coroutine builders come in two flavors: propagating exceptions automatically (launch and actor) or exposing them to users (async and produce). 
			The former treat exceptions as unhandled, similar to Java's Thread.uncaughtExceptionHandler, 
			while the latter are relying on the user to consume the final exception, for example via await or receive (produce and receive are covered later in Channels section).
			
		Supervision
			As we have studied before, cancellation (due to an exception was thrown (not normal job.cancel() - CancellationException)) is a bidirectional relationship propagating through the whole coroutines hierarchy.
				- If an exception is raised in the parent or parent gets just canlled (job.cancel()) all the children are cancelled
				- If an exception is raised in one of the children - the parent and all other children gets cancelled
					- If a child gets cancelled it does not affect the other children nor the parent
				- But what if unidirectional cancellation is required (when an exception occurs)? - Supervision job
			
			Supervision job
				For these purposes SupervisorJob can be used. It is similar to a regular Job with the only exception that cancellation is propagated only downwards. 
				Job: Creates a new job object in an active state. A failure of any child of this job immediately causes this job to fail, too, and cancels the rest of its children.
					 If parent job is specified, then this job becomes a child job of its parent and is cancelled when its parent fails or is cancelled. All this job’s children are cancelled in this case, too. 
					 The invocation of cancel with exception (other than CancellationException) on this job also cancels parent.
				SupervisorJob: Creates a new supervisor job object in an active state. Children of a supervisor job can fail independently of each other.
					 A failure or cancellation of a child does not cause the supervisor job to fail and does not affect its other children, so a supervisor can implement a custom policy for handling failures of its children:
						- A failure of a child job that was created using launch can be handled via CoroutineExceptionHandler in the context.
						- A failure of a child job that was created using async can be handled via Deferred.await on the resulting deferred value.
					If parent job is specified, then this supervisor job becomes a child job of its parent and is cancelled when its parent fails or is cancelled. All this supervisor’s children are cancelled in this case, too. 
					The invocation of of cancel with exception (other than CancellationException) on this supervisor job also cancels parent.
					
			Supervision scope
				For scoped concurrency supervisorScope can be used instead of coroutineScope for the same purpose. 
				It propagates cancellation only in one direction and cancels all children only if it has failed itself. 
				It also waits for all children before completion just like coroutineScope does.
				
			Exceptions in supervised coroutines
				Another crucial difference between regular and supervisor jobs is exception handling. 
				Every child should handle its exceptions by itself via exception handling mechanisms. 
				This difference comes from the fact that child's failure is not propagated to the parent.
		
			
		
Iterator

	In C# the IEnumerable (or Enumerable<T>) interface is common between arrays and collections (List, HashSet, Dictionary)
		foreach: can be used on any array, collection objects that implement the IEnumerable<T> generic interface.
		
	In Java there is NO common interface between arrays and collections (List, Set, Map).
	
	Kotlin is like Java in this case.	
		for: can be used on any object that has an "iterator operator": public operator fun iterator(): Iterator<T> - T comes from the enclosing class (Array is a class in kotlin)
		
		
Generics
	out: can be return parameter or property getter (reading)
	in: can be in (normal) parameter or property setter (writing)

	In Kotlin, there is a way to explain this sort of thing to the compiler. This is called declaration-site variance: we can annotate the type parameter T of Source to make sure that it is only returned (produced) from members of Source<T>, and never consumed. To do this we provide the out modifier:
	abstract class Source<out T> {
		abstract fun nextT(): T
	}
	In "clever words" they say that the class C is covariant in the parameter T, or that T is a covariant type parameter. You can think of C as being a producer of T's, and NOT a consumer of T's.
	The out modifier is called a variance annotation, and since it is provided at the type parameter declaration site, we talk about declaration-site variance. This is in contrast with Java's use-site variance where wildcards in the type usages make the types covariant.
	
	In addition to out, Kotlin provides a complementary variance annotation: in. It makes a type parameter contravariant: it can only be consumed and never produced. A good example of a contravariant class is Comparable:
	abstract class Comparable<in T> {
		abstract fun compareTo(other: T): Int
	}
	
	Type projections
	
		fun copy(from: Array<out Any>, to: Array<Any>) {
		 // ...
		}
		fun fill(dest: Array<in String>, value: String) {
			// ...
		}

	Star-projections
		Kotlin provides so called star-projection syntax for this:
			For Foo<out T>, where T is a covariant type parameter with the upper bound TUpper, Foo<*> is equivalent to Foo<out TUpper>. It means that when the T is unknown you can safely read values of TUpper from Foo<*>.
			For Foo<in T>, where T is a contravariant type parameter, Foo<*> is equivalent to Foo<in Nothing>. It means there is nothing you can write to Foo<*> in a safe way when T is unknown.
			For Foo<T>, where T is an invariant type parameter with the upper bound TUpper, Foo<*> is equivalent to Foo<out TUpper> for reading values and to Foo<in Nothing> for writing values.
			
			For Foo<out T : TUpper>, where T is a covariant type parameter with the upper bound TUpper, Foo<*> is equivalent to Foo<out TUpper>. It means that when the T is unknown you can safely read values of TUpper from Foo<*>.
			For Foo<in T>, where T is a contravariant type parameter, Foo<*> is equivalent to Foo<in Nothing>. It means there is nothing you can write to Foo<*> in a safe way when T is unknown.
			For Foo<T : TUpper>, where T is an invariant type parameter with the upper bound TUpper, Foo<*> is equivalent to Foo<out TUpper> for reading values and to Foo<in Nothing> for writing values.
			
		If a generic type has several type parameters each of them can be projected independently. For example, if the type is 
		declared as interface Function<in T, out U> we can imagine the following star-projections:
			Function<*, String> means Function<in Nothing, String>;
			Function<Int, *> means Function<Int, out Any?>;
			Function<*, *> means Function<in Nothing, out Any?>.
			
	Upper bounds
		fun <T : Comparable<T>> sort(list: List<T>) {
			// ...
		}
		
		The default upper bound (if none specified) is Any?. Only one upper bound can be specified inside the angle brackets. If the same type parameter needs more than one upper bound, we need a separate where-clause:
			fun <T> cloneWhenGreater(list: List<T>, threshold: T): List<T>
				where T : Comparable<T>,
					  T : Cloneable {
			  return list.filter { it > threshold }.map { it.clone() }
			}
	
Nested classes
	class Outer {
		private val bar: Int = 1
		class Nested {
			fun foo() = 2
		}
	}
	val demo = Outer.Nested().foo() // == 2
	
	A class may be marked as inner to be able to access members of outer class. Inner classes carry a reference to an object of an outer class:
		class Outer {
			private val bar: Int = 1
			inner class Inner {
				fun foo() = bar
			}
		}
		val demo = Outer().Inner().foo() // == 1
		
	Anonymous inner classes
		window.addMouseListener(object: MouseAdapter() {
			override fun mouseClicked(e: MouseEvent) {
				// ...
			}
																													
			override fun mouseEntered(e: MouseEvent) {
				// ...
			}
		})

	If the object is an instance of a functional Java interface (i.e. a Java interface with a single abstract method), you can create it using a lambda expression prefixed with the type of the interface:
		val listener = ActionListener { println("clicked") }
		
	Nested classes can be declared even in funtions!
		private fun Transaction.couponCategories(compInfos: List<CompanyInfo>) {
			if (compInfos.isEmpty()) return

			class CategoryMini(val title: String,
							   val description: String,
							   val image: ByteArray,
							   val companyId: Long
			)
			...
		}
		

Anonymous classes, objects:
	Objects:
		val errorObject = object {
			val message = errorMessage
		}
		
	Classes:
		val thread = object : Thread() {
			override fun run() {
				super.run()
			}
		}
		thread.isDaemon = true
		thread.run()

		
		val anon = object : ObjectMapper() {
			fun myFunc(): Unit {}
		}
		anon.myFunc()
		
		
		interface SuperCar {
			fun startEngine(): Unit;
		}
		val mySupi = object : SuperCar {
			override fun startEngine() {
				TODO("not implemented")
			}
		}
		mySupi.startEngine()
		
		
This
	In a member of a class, this refers to the current object of that class.
	In an extension function or a function literal with receiver this denotes the receiver parameter that is passed on the left-hand side of a dot.
	
	Qualified this
		To access this from an outer scope (a class, or extension function, or labeled function literal with receiver) we write this@label where @label is a label on the scope this is meant to be from:
		class A { // implicit label @A
			inner class B { // implicit label @B
				fun Int.foo() { // implicit label @foo
					val a = this@A // A's this
					val b = this@B // B's this

					val c = this // foo()'s receiver, an Int
					val c1 = this@foo // foo()'s receiver, an Int

					val funLit = lambda@ fun String.() {
						val d = this // funLit's receiver
					}


					val funLit2 = { s: String ->
						// foo()'s receiver, since enclosing lambda expression
						// doesn't have any receiver
						val d1 = this
					}
				}
			}
		}
		
		
Equality

	There are 2 types:
		Referential equality (two references point to the same object); - identity
		Structural equality (a check for equals()).						- equality
		
	Referential equality
		Referential equality is checked by the === operation (and its negated counterpart !==). a === b evaluates to true if and only if a and b point to the same object.
	Structural equality
		Structural equality is checked by the == operation (and its negated counterpart !=). By convention, an expression like a == b is translated to:

		a?.equals(b) ?: (b === null)
		
	Useful methods on only Arrays:
		- contentEquals
		- contentDeepEquals
		
		
Operator overloading

	To implement an operator, we provide a member function or an extension function with a fixed name, for the corresponding type, i.e. left-hand side type for binary operations and argument type for unary ones. Functions that overload operators need to be marked with the operator modifier.
	
	data class Counter(val dayIndex: Int) {
		operator fun plus(increment: Int): Counter {
			return Counter(dayIndex + increment)
		}
	}
	
	Unary operations
	
		Unary prefix operators
			Expression				Translated to
			+a						a.unaryPlus()
			-a						a.unaryMinus()
			!a						a.not()
			
		Increments and decrements
			Expression				Translated to
			a++						a.inc()
			a--						a.dec()
		
	Binary operations
		
		Arithmetic operators
			Expression				Translated to
			a + b					a.plus(b)
			a - b					a.minus(b)
			a * b					a.times(b)
			a / b					a.div(b)
			a % b					a.rem(b), a.mod(b) (deprecated)
			a..b					a.rangeTo(b)
			
		'In' operator
			Expression				Translated to
			a in b					b.contains(a)
			a !in b					!b.contains(a)
			
		Indexed access operator
			Expression				Translated to
			a[i]					a.get(i)
			a[i, j]					a.get(i, j)
			a[i_1, ..., i_n]		a.get(i_1, ..., i_n)
			a[i] = b				a.set(i, b)
			a[i, j] = b				a.set(i, j, b)
			a[i_1, ..., i_n] = b	a.set(i_1, ..., i_n, b)


		Invoke operator
			Expression				Translated to
			a()						a.invoke()
			a(i)					a.invoke(i)
			a(i, j)					a.invoke(i, j)
			a(i_1, ..., i_n)		a.invoke(i_1, ..., i_n)
			
			Example:
				3()
				""()
				private operator fun String.invoke(): Int = this.toInt()
				private operator fun Int.invoke(): String = toString()
	
		Augmented assignments
			Expression				Translated to
			a += b					a.plusAssign(b)
			a -= b					a.minusAssign(b)
			a *= b					a.timesAssign(b)
			a /= b					a.divAssign(b)
			a %= b					a.remAssign(b), a.modAssign(b) (deprecated)	

		Equality and inequality operators
			Expression				Translated to
			a == b					a?.equals(b) ?: (b === null)
			a != b					!(a?.equals(b) ?: (b === null))

		Comparison operators
			Expression				Translated to
			a > b					a.compareTo(b) > 0
			a < b					a.compareTo(b) < 0
			a >= b					a.compareTo(b) >= 0
			a <= b					a.compareTo(b) <= 0

		Property delegation operators
			provideDelegate, getValue and setValue operator functions are described in Delegated properties.


Implement lambdas

	fun testIntMakers(): Unit {

		class IntMakerOldSchool : BiFunction<String, Boolean, Int> {
			override fun apply(name: String, addOne: Boolean): Int {
				return if (!addOne) name.toInt()
				else name.toInt() + 1
			}
		}

		/**More Kotlin-ish way*/
		class IntMaker : (String, Boolean) -> Int {
			override fun invoke(name: String, addOne: Boolean): Int = if (!addOne) name.toInt() else name.toInt() + 1
		}

		IntMakerOldSchool().apply("23232", true)
		IntMaker().invoke("23232", false)
	}


Null Safety
	Kotlin's type system is aimed to eliminate NullPointerException's from our code. The only possible causes of NPE's may be:
		An explicit call to throw NullPointerException();
		Usage of the !! operator that is described below;
		External Java code has caused it;
		There's some data inconsistency with regard to initialization (an uninitialized this available in a constructor is used somewhere).
		
			var a: String = "abc"
			a = null // compilation error
			
			var b: String? = "abc"
			b = null // ok
			
	Checking for null conditions
		val l = if (b != null) b.length else -1
	Safe Calls
		val l = b?.length ?: -1: 
		If the expression to the left of "?:" is not null, the elvis operator returns it, otherwise it returns the expression to the right. Note that the right-hand side expression is evaluated only if the left-hand side is null.
		
	Note that, since throw and return are expressions in Kotlin, they can also be used on the right hand side of the elvis operator. This can be very handy, for example, for checking function arguments:
		fun foo(node: Node): String? {
			val parent = node.getParent() ?: return null
			val name = node.getName() ?: throw IllegalArgumentException("name expected")
			// ...
		}		
		
		To perform a certain operation only for non-null values, you can use the safe call operator together with let:
			val listWithNulls: List<String?> = listOf("A", null)
			for (item in listWithNulls) {
				 item?.let { println(it) } // prints A and ignores null
			}
	
	The !! Operator

		The third option is for NPE-lovers. We can write b!!, and this will return a non-null value of b (e.g., a String in our example) or throw an NPE if b is null:
		val l = b!!.length
		
	Safe Casts
		Regular casts may result into a ClassCastException if the object is not of the target type. Another option is to use safe casts that return null if the attempt was not successful:
		val aInt: Int? = a as? Int
		Collections of Nullable Type

	If you have a collection of elements of a nullable type and want to filter non-null elements, you can do so by using filterNotNull:
		val nullableList: List<Int?> = listOf(1, 2, null, 4)
		val intList: List<Int> = nullableList.filterNotNull()
		
		
Exceptions

	Checked Exceptions
		Kotlin does not have checked exceptions. 

	Try is an expression:
		val a: Int? = try { parseInt(input) } catch (e: NumberFormatException) { null }
		
	The Nothing type
		throw is an expression in Kotlin, so you can use it, for example, as part of an Elvis expression:
			val s = person.name ?: throw IllegalArgumentException("Name required")

		The type of the throw expression is the special type Nothing. The type has no values and is used to mark code locations that can never be reached. In your own code, you can use Nothing to mark a function that never returns:
			fun fail(message: String): Nothing {
				throw IllegalArgumentException(message)
			}
			
			When you call this function, the compiler will know that the execution doesn't continue beyond the call:

			val s = person.name ?: fail("Name required")
			println(s)     // 's' is known to be initialized at this point
			
			
Annotations

	annotation class Fancy
	
	Additional attributes of the annotation can be specified by annotating the annotation class with meta-annotations:
		@Target specifies the possible kinds of elements which can be annotated with the annotation (classes, functions, properties, expressions etc.);
		@Retention specifies whether the annotation is stored in the compiled class files and whether it's visible through reflection at runtime (by default, both are true);
		@Repeatable allows using the same annotation on a single element multiple times;
		@MustBeDocumented specifies that the annotation is part of the public API and should be included in the class or method signature shown in the generated API documentation.
		
	Constructors
		Annotations may have constructors that take parameters.
		
			annotation class Special(val why: String)
			@Special("example") class Foo {}
			
	Lambdas

		Annotations can also be used on lambdas. They will be applied to the invoke() method into which the body of the lambda is generated.
		
		annotation class Suspendable
		val f = @Suspendable { Fiber.sleep(10) }
		
	Annotation Use-site Targets
		class Example(@field:Ann val foo,    // annotate Java field
              @get:Ann val bar,      // annotate Java getter
              @param:Ann val quux)   // annotate Java constructor parameter
			  
		 The full list of supported use-site targets is:

			file: to annotate the entire file
			property (annotations with this target are not visible to Java);
			field;
			get (property getter);
			set (property setter);
			receiver (receiver parameter of an extension function or property);
			param (constructor parameter);
			setparam (property setter parameter);
			delegate (the field storing the delegate instance for a delegated property).
			
		Java Annotations

			Java annotations are 100% compatible with Kotlin
			
			
Reflection
	Class References: val c = MyClass::class
		The reference is a value of type KClass.
		Note that a Kotlin class reference is not the same as a Java class reference. To obtain a Java class reference, use the .java property on a KClass instance.
	
	Bound Class References (since 1.1)
		You can get the reference to a class of a specific object with the same ::class syntax by using the object as a receiver:
		val widget: Widget = ...
		assert(widget is GoodWidget) { "Bad widget: ${widget::class.qualifiedName}" }
		
	Function References
	
		fun isOdd(x: Int) = x % 2 != 0
			We can easily call it directly (isOdd(5)), but we can also pass it as a value, e.g. to another function. To do this, we use the :: operator:
			val numbers = listOf(1, 2, 3)
			println(numbers.filter(::isOdd)) // prints [1, 3]
			Here ::isOdd is a value of function type (Int) -> Boolean.
			
			
		If on a class:
			Haha::testHaha	 	- returns KFunction, can be used as an unbound method reference: (Haha) -> Unit
			
				left handside's type can be either KFunction or a function
					var kprop: KProperty<Column<String>> = Haha::name
					var kfunc: KFunction<Any> = Haha::testHaha
					var func: (Haha) -> Unit = Haha::testHaha
					
			Haha()::testHaha	- returns KFunction, can be used as a bound method reference as well: () -> Unit
				var kprop: KProperty<Column<String>> = Haha()::name
				var kfunc: KFunction<Any> = Haha()::testHaha
				var func: () -> Unit = Haha()::testHaha
		
			var func: () -> Unit = ::test
			func = Haha()::testHaha
				fun testHaha() {
				}
				class Haha {
					fun test() {
					}
				}

		Select from overloded functions: declare the type of the function:
			val predicate: (String) -> Boolean = ::isOdd   // refers to isOdd(x: String)
				
	Example: Function Composition
	
		fun <A, B, C> compose(f: (B) -> C, g: (A) -> B): (A) -> C {
			return { x -> f(g(x)) }
		}
		
		It returns a composition of two functions passed to it: compose(f, g) = f(g(*)). Now, you can apply it to callable references:
		
		fun length(s: String) = s.length
		val oddLength = compose(::isOdd, ::length)
		val strings = listOf("a", "ab", "abc")

		println(strings.filter(oddLength)) // Prints "[a, abc]"
		
	Property References
		To access properties as first-class objects in Kotlin, we can also use the :: operator:
			val x = 1		// The expression ::x evaluates to a property object of type KProperty<Int>

			fun main(args: Array<String>) {
				println(::x.get()) // prints "1"
				println(::x.name)  // prints "x"
			}
			
			var y = 1		// For a mutable property, e.g. var y = 1, ::y returns a value of type KMutableProperty<Int>, which has a set() method

			fun main(args: Array<String>) {
				::y.set(2)
				println(y) // prints "2"
			}
			
		To access a property that is a member of a class, we qualify it:
			class A(val p: Int)
			fun main(args: Array<String>) {
				val prop = A::p
				println(prop.get(A(1))) // prints "1"
			}
			
	Constructor References
		Constructors are referenced by using the :: operator and adding the class name:
	
			class Foo
			fun function(factory: () -> Foo) {
				val x: Foo = factory()
			}
			function(::Foo)
			
	Bound Function and Property References (since 1.1) - method reference
		You can refer to an instance method of a particular object:
		
			val numberRegex = "\\d+".toRegex()
			println(numberRegex.matches("29")) // prints "true"
		 
			val isNumber = numberRegex::matches		// Instead of calling the method matches directly we are storing a reference to it. Such reference is bound to its receiver. 
			println(isNumber("29")) // prints "true"
			
			
		Compare the types of bound and the corresponding unbound references. Bound callable reference has its receiver "attached" to it, so the type of the receiver is no longer a parameter:
		
			var boundFunc: () -> Unit = Wrapper()::test // bound function - to its receiver
			var unboundFunc: (Wrapper) -> Unit = Wrapper::test  // unbound function - need to pass in a receiver
			var method: KFunction<*> = Wrapper::test    // method for reflection
			
				// surprisingly the "method" can be invoked just like a method
				method(Wrapper())
				method.invoke(Wrapper())
				
				boundFunc.invoke()
				unboundFunc.invoke(Wrapper())
			
			val isNumber: (CharSequence) -> Boolean = numberRegex::matches
			val matches: (Regex, CharSequence) -> Boolean = Regex::matches
			
		Property reference can be bound as well:

			val prop = "abc"::length
			println(prop.get())   // prints "3"
			
		Since Kotlin 1.2, explicitly specifying this as the receiver is not necessary: this::foo and ::foo are equivalent.
		
		
Type aliases

	Type aliases provide alternative names for existing types. If the type name is too long you can introduce a different shorter name and use the new one instead.
	
		typealias NodeSet = Set<Network.Node>
		typealias FileTable<K> = MutableMap<K, MutableList<File>>
		
	You can provide different aliases for function types:
		typealias MyHandler = (Int, String, Any) -> Unit
		typealias Predicate<T> = (T) -> Boolean
		
	You can have new names for inner and nested classes:
		class A {
			inner class Inner
		}
		class B {
			inner class Inner
		}
		typealias AInner = A.Inner
		typealias BInner = B.Inner
	
	
	Type aliases do not introduce new types. They are equivalent to the corresponding underlying types. When you add typealias Predicate<T> and use Predicate<Int> in your code, the Kotlin compiler always expand it to (Int) -> Boolean. Thus you can pass a variable of your type whenever a general function type is required and vice versa:
		typealias Predicate<T> = (T) -> Boolean
		fun foo(p: Predicate<Int>) = p(42)

		fun main(args: Array<String>) {
			val f: (Int) -> Boolean = { it > 0 }
			println(foo(f)) // prints "true"

			val p: Predicate<Int> = { it > 0 }
			println(listOf(1, -2).filter(p)) // prints "[1]"
		}		

Java interop

	Calling Java from Kotlin

		Platform types:
			T! - this means it can be either T or T?
			Types of Java declarations are treated specially in Kotlin and called platform types. Null-checks are relaxed for such types, so that safety guarantees for them are the same as in Java
			
			a java "Integer" becomes a platform type in kotlin: Int! (because Integer in java can be either int or a null)
			however a java "int" becomes a kotlin type: Int (because "int" in java cannot be null)
			
			
			Notion for platform types:
				- T! means "T or T?",
				- (Mutable)Collection<T>! means "Java collection of T may be mutable or not, may be nullable or not",
				- Array<(out) T>! means "Java array of T (or a subtype of T), nullable or not"
				
		Mapped types
			Kotlin treats some Java types specially. Such types are not loaded from Java "as is", but are mapped to corresponding Kotlin types.
			The mapping only matters at compile time, the runtime representation remains unchanged. Java's primitive types are mapped to corresponding Kotlin types (keeping platform types in mind):
				Java type	Kotlin type
				byte		kotlin.Byte
				short		kotlin.Short
				int			kotlin.Int
				long		kotlin.Long
				char		kotlin.Char
				float		kotlin.Float
				double		kotlin.Double
				boolean		kotlin.Boolean
				
			Some non-primitive built-in classes are also mapped:
				Java type				Kotlin type
				java.lang.Object		kotlin.Any!			But not all methods! Missing ones are implemented as extension functions.
				java.lang.Cloneable		kotlin.Cloneable!
				java.lang.Comparable	kotlin.Comparable!
				java.lang.Enum			kotlin.Enum!
				java.lang.Annotation	kotlin.Annotation!
				java.lang.Deprecated	kotlin.Deprecated!
				java.lang.CharSequence	kotlin.CharSequence!
				java.lang.String		kotlin.String!
				java.lang.Number		kotlin.Number!
				java.lang.Throwable		kotlin.Throwable!
				
			Java's boxed primitive types are mapped to nullable Kotlin types:
				Java type				Kotlin type
				java.lang.Byte			kotlin.Byte?
				java.lang.Short			kotlin.Short?
				java.lang.Integer		kotlin.Int?
				java.lang.Long			kotlin.Long?
				java.lang.Character		kotlin.Char?
				java.lang.Float			kotlin.Float?
				java.lang.Double		kotlin.Double?
				java.lang.Boolean		kotlin.Boolean?
				
				Note that a boxed primitive type used as a type parameter is mapped to a platform type: for example, List<java.lang.Integer> becomes a List<Int!> in Kotlin.
				
			Collection types may be read-only or mutable in Kotlin, so Java's collections are mapped as follows (all Kotlin types in this table reside in the package kotlin.collections):
					Java type			Kotlin read-only type			Kotlin mutable type				Loaded platform type
					Iterator<T>			Iterator<T>						MutableIterator<T>				(Mutable)Iterator<T>!
					Iterable<T>			Iterable<T>						MutableIterable<T>				(Mutable)Iterable<T>!
					Collection<T>		Collection<T>					MutableCollection<T>			(Mutable)Collection<T>!
					Set<T>				Set<T>							MutableSet<T>					(Mutable)Set<T>!
					List<T>				List<T>							MutableList<T>					(Mutable)List<T>!
					ListIterator<T>		ListIterator<T>					MutableListIterator<T>			(Mutable)ListIterator<T>!
					Map<K, V>			Map<K, V>						MutableMap<K, V>				(Mutable)Map<K, V>!
					Map.Entry<K, V>		Map.Entry<K, V>					MutableMap.MutableEntry<K,V>	(Mutable)Map.(Mutable)Entry<K, V>!
					
			Java's arrays are mapped as mentioned below:
				Java type		Kotlin type
				int[]			kotlin.IntArray!
				String[]		kotlin.Array<(out) String>!
					
		Java generics in Kotlin		
			Kotlin's generics are a little different from Java's (see Generics). When importing Java types to Kotlin we perform some conversions:
			Java's wildcards are converted into type projections,
				Foo<? extends Bar> becomes Foo<out Bar!>!,
				Foo<? super Bar> becomes Foo<in Bar!>!;
			Java's raw types are converted into star projections,
				List becomes List<*>!, i.e. List<out Any?>!.
			
		Java Arrays
			Arrays in Kotlin are invariant, unlike Java. This means that Kotlin does not let us assign an Array<String> to an Array<Any>, which prevents a possible runtime failure. 
			Passing an array of a subclass as an array of superclass to a Kotlin method is also prohibited, but for Java methods this is allowed (through platform types of the form Array<(out) String>!).
			
			Arrays are used with primitive datatypes on the Java platform to avoid the cost of boxing/unboxing operations. 
			As Kotlin hides those implementation details, a workaround is required to interface with Java code. 
			There are specialized classes for every type of primitive array (IntArray, DoubleArray, CharArray, and so on) to handle this case. 
			They are not related to the Array class and are compiled down to Java's primitive arrays for maximum performance.
			
				val javaObj = JavaArrayExample()
				val array = intArrayOf(0, 1, 2, 3)
				javaObj.removeIndices(array)  // passes int[] to method
				
			Even when we navigate with an index, it does not introduce any overhead:

				for (i in array.indices) { // no iterator created
					array[i] += 2
				}
				
			Finally, in-checks have no overhead either:

				if (i in array.indices) { // same as (i >= 0 && i < array.size)
					print(array[i])
				}
				
		Java Varargs
			Java classes sometimes use a method declaration for the indices with a variable number of arguments (varargs):

				public class JavaArrayExample {

					public void removeIndicesVarArg(int... indices) {
						// code here...
					}
				}
				val javaObj = JavaArrayExample()
				val array = intArrayOf(0, 1, 2, 3)
				javaObj.removeIndicesVarArg(*array)
				
		Checked Exceptions
			In Kotlin, all exceptions are unchecked, meaning that the compiler does not force you to catch any of them. 
			So, when you call a Java method that declares a checked exception, Kotlin does not force you to do anything

		Object Methods
			When Java types are imported into Kotlin, all the references of the type java.lang.Object are turned into Any. 
			Since Any is not platform-specific, it only declares toString(), hashCode() and equals() as its members, so to make other members of java.lang.Object available, Kotlin uses extension functions.
			
			getClass()
				To retrieve the Java class of an object, use the java extension property on a class reference:
				val fooClass = foo::class.java
				val fooClass = foo.javaClass
			
			finalize()
				To override finalize(), all you need to do is simply declare it, without using the override keyword:
				class C {
					protected fun finalize() {
						// finalization logic
					}
				}
				
		Inheritance from Java classes
			At most one Java class (and as many Java interfaces as you like) can be a supertype for a class in Kotlin.
				
		Accessing static members
			Static members of Java classes form "companion objects" for these classes. We cannot pass such a "companion object" around as a value, but can access the members explicitly, for example:
			if (Character.isLetter(a)) {
				// ...
			}
				
		SAM Conversions
			Just like Java 8, Kotlin supports SAM conversions. This means that Kotlin function literals can be automatically converted into implementations of Java interfaces with a single non-default method,
			as long as the parameter types of the interface method match the parameter types of the Kotlin function.
			
			You can use this for creating instances of SAM interfaces:
			val runnable = Runnable { println("This runs in a runnable") }
			
			val executor = ThreadPoolExecutor()
			// Java signature: void execute(Runnable command)
			executor.execute { println("This runs in a thread pool") }
			executor.execute(Runnable { println("This runs in a thread pool") })
				
		Using JNI with Kotlin
			To declare a function that is implemented in native (C or C++) code, you need to mark it with the external modifier:
			external fun foo(x: Int): Double
			
	Calling Kotlin from Java
	
		Properties
			A Kotlin property is compiled to the following Java elements:
				- A getter method, with the name calculated by prepending the get prefix;
				- A setter method, with the name calculated by prepending the set prefix (only for var properties);
				- A private field, with the same name as the property name (only for properties with backing fields).
				
			If the name of the property starts with is, a different name mapping rule is used: 
				-the name of the getter will be the same as the property name,
				- and the name of the setter will be obtained by replacing is with set. 
				For example, for a property isOpen, the getter will be called isOpen() and the setter will be called setOpen(). This rule applies for properties of any type, not just Boolean.
				
		Package-Level Functions
			// example.kt
			package demo

			class Foo

			fun bar() {
			}
			
			// Java
			new demo.Foo();
			demo.ExampleKt.bar();
			
		The name of the generated Java class can be changed using the @JvmName annotation:
			@file:JvmName("DemoUtils")

			package demo

			class Foo

			fun bar() {
			}
			
			// Java
			new demo.Foo();
			demo.DemoUtils.bar();
			
		Having multiple files which have the same generated Java class name (the same package and the same name or the same @JvmName annotation) is normally an error. However, the compiler has the ability to generate a single Java facade class which has the specified name and contains all the declarations from all the files which have that name. To enable the generation of such a facade, use the @JvmMultifileClass annotation in all of the files.
		
			// oldutils.kt
			@file:JvmName("Utils")
			@file:JvmMultifileClass

			package demo

			fun foo() {
			}
			
			// newutils.kt
			@file:JvmName("Utils")
			@file:JvmMultifileClass

			package demo

			fun bar() {
			}
			
			// Java
			demo.Utils.foo();
			demo.Utils.bar();
			
		Instance Fields
		
			If you need to expose a Kotlin property as a field in Java, you need to annotate it with the @JvmField annotation.
			
			class C(id: String) {
				@JvmField val ID = id
			}
			// Java
			class JavaClient {
				public String getID(C c) {
					return c.ID;
				}
			}
			
		Static Fields
		
			Kotlin properties declared in a named object or a companion object will have static backing fields either in that named object or in the class containing the companion object.
			Usually these fields are private but they can be exposed in one of the following ways:
				- @JvmField annotation;
				- lateinit modifier;
				- const modifier.
			Annotating such a property with @JvmField makes it a static field with the same visibility as the property itself.
			
				class Key(val value: Int) {
					companion object {
						@JvmField
						val COMPARATOR: Comparator<Key> = compareBy<Key> { it.value }
					}
				}
				// Java
				Key.COMPARATOR.compare(key1, key2);
				// public static final field in Key class
				
			A late-initialized property in an object or a companion object has a static backing field with the same visibility as the property setter.

				object Singleton {
					lateinit var provider: Provider
				}
				// Java
				Singleton.provider = new Provider();
				// public static non-final field in Singleton class
				
			Properties annotated with const (in classes as well as at the top level) are turned into static fields in Java:
			
				// file example.kt
				object Obj {
					const val CONST = 1
				}
				class C {
					companion object {
						const val VERSION = 9
					}
				}
				const val MAX = 239
				
				// Java
				int c = Obj.CONST;
				int d = ExampleKt.MAX;
				int v = C.VERSION;
				
		Static Methods
		
			As mentioned above, Kotlin represents package-level functions as static methods. 
			Kotlin can also generate static methods for functions defined in named objects or companion objects if you annotate those functions as @JvmStatic. 
			If you use this annotation, the compiler will generate both a static method in the enclosing class of the object and an instance method in the object itself. For example:
			
				class C {
					companion object {
						@JvmStatic fun foo() {}
						fun bar() {}
					}
				}
				
				Now, foo() is static in Java, while bar() is not:

				C.foo(); // works fine
				C.bar(); // error: not a static method
				C.Companion.foo(); // instance method remains
				C.Companion.bar(); // the only way it works
				
			Same for named objects:

				object Obj {
					@JvmStatic fun foo() {}
					fun bar() {}
				}
				
				In Java:

				Obj.foo(); // works fine
				Obj.bar(); // error
				Obj.INSTANCE.bar(); // works, a call through the singleton instance
				Obj.INSTANCE.foo(); // works too
				
		Visibility
			The Kotlin visibilities are mapped to Java in the following way:
				- private members are compiled to private members;
				- private top-level declarations are compiled to package-local declarations;
				- protected remains protected (note that Java allows accessing protected members from other classes in the same package and Kotlin doesn't, so Java classes will have broader access to the code);
				- internal declarations become public in Java. Members of internal classes go through name mangling, to make it harder to accidentally use them from Java and to allow overloading for members with the same signature that don't see each other according to Kotlin rules;
				- public remains public.
				
		KClass
			There is no automatic conversion from Class to KClass, so you have to do it manually by invoking the equivalent of the Class<T>.kotlin extension property:
			kotlin.jvm.JvmClassMappingKt.getKotlinClass(MainView.class)
			
		Handling signature clashes with @JvmName
		
			Sometimes we have a named function in Kotlin, for which we need a different JVM name the byte code. The most prominent example happens due to type erasure:
				fun List<String>.filterValid(): List<String>
				fun List<Int>.filterValid(): List<Int>
			These two functions can not be defined side-by-side, because their JVM signatures are the same: filterValid(Ljava/util/List;)Ljava/util/List;. 
			If we really want them to have the same name in Kotlin, we can annotate one (or both) of them with @JvmName and specify a different name as an argument:

				fun List<String>.filterValid(): List<String>

				@JvmName("filterValidInt")
				fun List<Int>.filterValid(): List<Int>
				
			From Kotlin they will be accessible by the same name filterValid, but from Java it will be filterValid and filterValidInt.
			
			The same trick applies when we need to have a property x alongside with a function getX():

				val x: Int
					@JvmName("getX_prop")
					get() = 15

				fun getX() = 10
				
		Overloads Generation
			Normally, if you write a Kotlin function with default parameter values, it will be visible in Java only as a full signature, with all parameters present. If you wish to expose multiple overloads to Java callers, you can use the @JvmOverloads annotation.
			
			The annotation also works for constructors, static methods etc. It can't be used on abstract methods, including methods defined in interfaces.			
			
				class Foo @JvmOverloads constructor(x: Int, y: Double = 0.0) {
				@JvmOverloads fun f(a: String, b: Int = 0, c: String = "abc") {
					...
				}
				
			For every parameter with a default value, this will generate one additional overload, which has this parameter and all parameters to the right of it in the parameter list removed. In this example, the following will be generated:

				// Constructors:
				Foo(int x, double y)
				Foo(int x)

				// Methods
				void f(String a, int b, String c) { }
				void f(String a, int b) { }
				void f(String a) { }
		
		Checked Exceptions
			As we mentioned above, Kotlin does not have checked exceptions.
			To work around this problem, use the @Throws annotation in Kotlin:
				@Throws(IOException::class)
				fun foo() {
					throw IOException()
				}
				
		Null-safety
			When calling Kotlin functions from Java, nobody prevents us from passing null as a non-null parameter. That's why Kotlin generates runtime checks for all public functions that expect non-nulls. This way we get a NullPointerException in the Java code immediately.
			
		Variant generics
		
				class Box<out T>(val value: T)

				interface Base
				class Derived : Base

				fun boxDerived(value: Derived): Box<Derived> = Box(value)
				fun unboxBase(box: Box<Base>): Base = box.value

			To make Kotlin APIs work in Java we generate Box<Super> as Box<? extends Super> for covariantly defined Box (or Foo<? super Bar> for contravariantly defined Foo) when it appears as a parameter. When it's a return value, we don't generate wildcards, because otherwise Java clients will have to deal with them (and it's against the common Java coding style). Therefore, the functions from our example are actually translated as follows:
			
				// return type - no wildcards
				Box<Derived> boxDerived(Derived value) { ... }
				 
				// parameter - wildcards 
				Base unboxBase(Box<? extends Base> box) { ... }
				
			NOTE: when the argument type is final, there's usually no point in generating the wildcard, so Box<String> is always Box<String>, no matter what position it takes.

			If we need wildcards where they are not generated by default, we can use the @JvmWildcard annotation:
				fun boxDerived(value: Derived): Box<@JvmWildcard Derived> = Box(value)
				// is translated to 
				// Box<? extends Derived> boxDerived(Derived value) { ... }
				
			On the other hand, if we don't need wildcards where they are generated, we can use @JvmSuppressWildcards:
				fun unboxBase(box: Box<@JvmSuppressWildcards Base>): Base = box.value
				// is translated to 
				// Base unboxBase(Box<Base> box) { ... }
				
		Translation of type Nothing
		
			The type Nothing is special, because it has no natural counterpart in Java. Indeed, every Java reference type, including java.lang.Void, accepts null as a value, and Nothing doesn't accept even that. So, this type cannot be accurately represented in the Java world. This is why Kotlin generates a raw type where an argument of type Nothing is used:

				fun emptyList(): List<Nothing> = listOf()
				// is translated to
				// List emptyList() { ... }


If, try-catch expressions
		
	When expression
		when replaces the switch operator of C-like languages. In the simplest form it looks like this
		
		when (x) {
			in 1..10 -> print("x is in the range")
			in validNumbers -> print("x is valid")
			!in 10..20 -> print("x is outside the range")
			else -> print("none of the above")
		}
		when (x) {
			0, 1 -> print("x == 0 or x == 1")
			else -> print("otherwise")
		}
		fun hasPrefix(x: Any) = when(x) {
			is String -> x.startsWith("prefix")
			else -> false
		}
		when {
			x.isOdd() -> print("x is odd")
			x.isEven() -> print("x is even")
			else -> print("x is funny")
		}
	
	Try-catch
		try is an expression, i.e. it may have a return value:
		val a: Int? = try { parseInt(input) } catch (e: NumberFormatException) { null }
		The returned value of a try-expression is either the last expression in the try block or the last expression in the catch block (or blocks). Contents of the finally block do not affect the result of the expression.
	
	
Tuple implementation
	object Tuple {
		operator fun <A> invoke(_1: A): Tuple1<A> = Tuple1(_1)
		operator fun <A, B> invoke(_1: A, _2: B): Tuple2<A, B> = Tuple2(_1, _2)
		operator fun <A, B, C> invoke(_1: A, _2: B, _3: C): Tuple3<A, B, C> = Tuple3(_1, _2, _3)
		operator fun <A, B, C, D> invoke(_1: A, _2: B, _3: C, _4: D): Tuple4<A, B, C, D> = Tuple4(_1, _2, _3, _4)
		operator fun <A, B, C, D, E> invoke(_1: A, _2: B, _3: C, _4: D, _5: E): Tuple5<A, B, C, D, E> = Tuple5(_1, _2, _3, _4, _5)
	}
	
	...
	data class Tuple2<out A, out B>(val _1: A, val _2: B)
	...
	
	usage:
		val tup2 = Tuple("elem1", "elem2")
		val tup3 = Tuple("elem1", "elem2", "elem3")
		val tup4 = Tuple("elem1", "elem2", "elem3", "elem4")


Spring

	Leveraging Kotlin nullable information in Spring annotations

		Originally based on a community contribution from Raman Gupta, Spring now takes advantage of Kotlin null-safety support to determine if an HTTP parameter is required without having to define explicitly the required 
		attribute. That means @RequestParam name: String? with be treated as not required and @RequestParam name: String as required. This is also supported on Spring Messaging @Header annotation.

		In a similar fashion, Spring bean injection with @Autowired or @Inject uses this information to know if a bean is required or not. 
			@Autowired lateinit var foo: Foo 	- implies that a bean of type Foo must be registered in the application context 
			@Autowired lateinit var foo: Foo?  	- while this won’t raise an error if such bean does not exist.
		
		Optional ctor dependencies can also be specified:
			@RestController
			@RequestMapping("/")
			class HomeController(private val superFormula: SuperFormula?) { ... }}
			
	WebFlux WebFilter kotlin possible implementations:
	
		1.
		val aFilter = object : WebFilter {
			override fun filter(exchange: ServerWebExchange, chain: WebFilterChain): Mono<Void> {
				return chain.filter(exchange);
			}
		}
	
		2.
		val bFilter = WebFilter { exchange, chain -> chain.filter(exchange) }
		
		3.
		val func: (exchange: ServerWebExchange, chain: WebFilterChain) -> Mono<Void> = { exchange, chain -> chain.filter(exchange) }
		val cFilter = WebFilter(func)