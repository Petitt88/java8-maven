:: - reflection and method reference at the same time.

	list.forEach(::println) 	- method reference
	myClass::fun1				- method reference
	this::fun1					- method reference
	
	IntroAndLang::class.java 	- reflection
	MyClass::myProp				- reflection
	MyClass::fun1				- reflection
	
	
Lambda

	Lambdas can be passed down to functions as parameters with the :: method reference syntax:
	
		class MyClass(lazyInitializer: () -> Int) {

			// passing down the lambda
			val lazyProp: Int by lazy(lazyInitializer)
			// passing down a method reference
			val lazyProp2: Int by lazy(this::createInt)

			fun createInt() = 2

			fun test(message: Int, message2: String) {
				println(this::test)
			}
		}
		
Iterator

	In C# the IEnumerable (or Enumerable<T>) interface is common between arrays and collections (List, HashSet, Dictionary)
		foreach: can be used on any array, collection objects that implement the IEnumerable<T> generic interface.
		
	In Java there is NO common interface between arrays and collections (List, Set, Map).
	
	Kotlin is like Java in this case.	
		for: can be used on any object that has an "iterator operator": public operator fun iterator(): Iterator<T> - T comes from the enclosing class (Array is a class in kotlin)

		
Spring

	Leveraging Kotlin nullable information in Spring annotations

		Originally based on a community contribution from Raman Gupta, Spring now takes advantage of Kotlin null-safety support to determine if an HTTP parameter is required without having to define explicitly the required 
		attribute. That means @RequestParam name: String? with be treated as not required and @RequestParam name: String as required. This is also supported on Spring Messaging @Header annotation.

		In a similar fashion, Spring bean injection with @Autowired or @Inject uses this information to know if a bean is required or not. 
			@Autowired lateinit var foo: Foo 	- implies that a bean of type Foo must be registered in the application context 
			@Autowired lateinit var foo: Foo?  	- while this wonâ€™t raise an error if such bean does not exist.
		
		Optional ctor dependencies can also be specified:
			@RestController
			@RequestMapping("/")
			class HomeController(private val superFormula: SuperFormula?) { ... }