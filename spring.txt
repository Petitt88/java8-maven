@Component
@Service
@Repository
@Controller
@RestController
@Scope
@Bean

@Valid
@ModelAttribute - this is used to add stuff to spring's model and it ultimately goes into the HttpServletRequest object after the handler executes
@SessionAttributes("key") - adds the value from the ModelMap that belongs to the specified key to the HttpSession object after the handler executes
@ResponseBody
@RequestBody
@PathParam
@Value - specify default value on properties. Can be arbirtary string or expression e.g. "#{systemProperties.myProp}"

@ControllerAdvice
@ExceptionHandler
@ResponseStatus

@Lazy - lazily initialze beans

FileCopyUtils


org.springframework.beans.factory.Aware
Sometimes we need Spring Framework objects in our beans to perform some operations, 
for example reading ServletConfig and ServletContext parameters or to know the bean definitions loaded by the ApplicationContext. 
That’s why spring framework provides a bunch of *Aware interfaces that we can implement in our bean classes.

mvn -DskipTests=true clean install

spring.factories: a file that contains auto-configuration classes for everything. These are only included when certain
	conditions are met thanks to the @ConditionalOnClass annotation which is like the .NET #ifdef
	
https://github.com/spring-projects/spring-boot
https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure
	

Spring:
	- Dev tools: automatically restarts the server when any change happens to our source files (.java, .jsp) on the local classpath.
				 It is automatically disabled in production: when the app is started via the command line.

		- this is achieved by using 2 class loaders: 1 for the libs, maven dependencies which never change
													 1 for our source code which can change
		- in case of a change the lib classloader remains intact, whereas the source-file classloader is recreated. This ensures performance in a microservice world.
		
	- Actuator: provides monitoring capabilities that can be reached via http endpoints or via JMX

		- Endpoints Actuator endpoints allow you to monitor and interact with your application. 
		  Spring Boot includes a number of built-in endpoints and you can also add your own. 
		  For example the health endpoint provides basic application health information. 
		  Run up a basic application and look at /health (and see /mappings for a list of other HTTP endpoints).

		- Metrics Spring Boot Actuator includes a metrics service with “gauge” and “counter” support.
		  A “gauge” records a single value; and a “counter” records a delta (an increment or decrement). 
		  Metrics for all HTTP requests are automatically recorded, so if you hit the metrics endpoint should see a sensible response.

		- Audit Spring Boot Actuator has a flexible audit framework that will publish events to an AuditService. 
		  Once Spring Security is in play it automatically publishes authentication events by default. 
		  This can be very useful for reporting, and also to implement a lock-out policy based on authentication failures.

		- Process Monitoring In Spring Boot Actuator you can find ApplicationPidFileWriter which creates a file containing the 
		  application PID (by default in the application directory with a file name of application.pid).
		  
		  
		  
JDBC:
		// load the Driver Class
		Class.forName(props.getProperty("DB_DRIVER_CLASS"));

		// create the connection now
		con = DriverManager.getConnection(props.getProperty("DB_URL"),
				props.getProperty("DB_USERNAME"),
				props.getProperty("DB_PASSWORD"));
	
	
JDBC DataSource:
	Most of the times we are looking for loose coupling for connectivity so that we can switch databases easily, 
	connection pooling for transaction management and distributed systems support. JDBC DataSource is the preferred approach 
	if you are looking for any of these features in your application. 
	
	
Spring DataSoruce implementation: DriverManagerDataSource!
	<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">

		<property name="driverClassName" value="com.mysql.jdbc.Driver" />
		<property name="url" value="jdbc:mysql://localhost:3306/TestDB" />
		<property name="username" value="pankaj" />
		<property name="password" value="pankaj123" />
	</bean>
	
	But we still have to write a lot of boilerplate code: opening connection, statements, closing them, reading the resulet set in a for loop.
	
	
Spring JdbcTemplate to the rescue:
	All we need is to provide the arguments as Object array and implement Callback interfaces such as 
	PreparedStatementSetter and RowMapper for mapping arguments or converting ResultSet data to bean objects.
	
	
JPA: EntityManager
Hibernate: Session


@Lob @Basic(fetch = FetchType.LAZY)
@Column(name="content", nullable=false)
private byte[] content;
 
We have chosen a byte[] to store the content of file. @LobSpecifies that a this persistent property should be persisted as a 
large object to a database-supported large object type which in our case is longblob. 
@Basic annotation is an optional annotation, serving here as placeholder to instruct hibernate to lazy load the binary content.

Java's transient keyword is used to denote that a field is not to be serialized, whereas JPA's @Transient 
annotation is used to indicate that a field is not to be persisted in the database, i.e. their semantics are different.

Hibernate SQLQuery: not recommended because we loose benefits of 1st level cache

1st level cache: - at the Session level
				 - enabled by default
				 - for the current user
2nd level cache: - at the JVM level, Session Factory object --> concurrency is a problem
				 - for all users
				 - disabled by default
					- can enable globally (not recommended)
					- only for certain entities, collections
					- configurable at the Session level with CacheMode
				 - cache all properties (default) or only non-lazy
Query cache: - good for repetitive queries with identical params
			 - if used, best in conjunection with 2LC

session.save() 				- saves changes to db (insert or update)) but does not add entity to persistent context: doesn't track entity
							  and further changes at transaction commit won't get saved. 
							  Works without transaction.

session.saveOrUpdate() 		- adds the entity object to persistent context and track any further changes. 
							  Any further changes are saved at the time of committing transaction, like persist.
							  Works without transaction.

session.persist()			- Hibernate persist is similar to save (with transaction) and it adds the entity object to the persistent context, 
							  so any further changes are tracked. If the object properties are changed before the transaction is committed or 
							  session is flushed, it will also be saved into database.
							  Second difference is that we can use persist() method only within the boundary of a transaction, 
							  so it’s safe and takes care of any cascaded objects.
							  
session.update()			- Hibernate update should be used where we know that we are only updating the entity information. 
							  This operation adds the entity object to persistent context and further changes are tracked and saved when 
							  transaction is committed.
							  
session.merge()				- Hibernate merge can be used to update existing values, however this method create a copy from the passed entity object
							  and return it. The returned object is part of persistent context and tracked for any changes, 
							  passed object is not tracked. This is the major difference with merge() from all other methods. 
							  

							  
SessionFactory (org.hibernate.SessionFactory): 						SessionFactory is an immutable thread-safe cache of compiled mappings for a 
																	single database. We can get instance of org.hibernate.Session using SessionFactory.
																	
Session (org.hibernate.Session): 									Session is a single-threaded, short-lived object representing a conversation 
																	between the application and the persistent store. 
																	It wraps JDBC java.sql.Connection and works as a factory for 
																	org.hibernate.Transaction.
																	
ConnectionProvider (org.hibernate.connection.ConnectionProvider): 	ConnectionProvider is a factory for JDBC connections. It provides abstraction 
																	between the application and underlying javax.sql.DataSource or 
																	java.sql.DriverManager. It is not exposed to application, but it can be 
																	extended by the developer.

TransactionFactory (org.hibernate.TransactionFactory): 				A factory for org.hibernate.Transaction instances.

In its default configuration, the Spring Framework’s transaction infrastructure code only marks a transaction for rollback in the case of runtime,
unchecked exceptions; that is, when the thrown exception is an instance or subclass of RuntimeException. 
(Errors will also - by default - result in a rollback). 
Checked exceptions that are thrown from a transactional method do not result in rollback in the default configuration.

@Transactional: must be applied on public methods to get weaved. Also, only works when invoking the object outside of it - means that invoking 
				another public method from the invoked public method that has @Transactional would take no effect either.
				Rolled back automatically only if unchecked RuntimeException is thrown (checked exceptions does not make the transaction rollback)

Normally both JPA and Hibernate require an xml config (persistence.xml, hibernate.cfg.xml), but with Spring these can be omitted.
(Spring scans the package and packages down for @Entity classes.) @EnableJpaRepositories("com.acme.repositories")

@Entity --> @Respository (Dao) --> @Service --> @Controller/@Restcontroller


********************************
Spring MVC:
********************************

The WebMvcConfigurerAdapter is for configuring Spring MVC, the replacement of the xml file loaded by the 
DispatcherServlet for configuring Spring MVC. The WebMvcConfigurerAdapter should be used for a @Configuration class.
@EnableWebMvc //<mvc:annotation-driven />
@Configuration
@ComponentScan({ "com.mkyong.helloworld.web" })
public class SpringWebConfig extends WebMvcConfigurerAdapter

AbstractAnnotationConfigDispatcherServletInitializer (ServletInitializer) is the replacement of web.xml. Initializes the servlet container.
public class MyWebInitializer extends
		AbstractAnnotationConfigDispatcherServletInitializer {

	@Override
	protected Class<?>[] getRootConfigClasses() {
		return new Class[] { SpringRootConfig.class };
	}

	@Override
	protected Class<?>[] getServletConfigClasses() {
		return new Class[] { SpringWebConfig.class };
	}

	@Override
	protected String[] getServletMappings() {
		return new String[] { "/" };
	}
}


WebDataBinder binds custom validators.
To do this, we create a method in controller and annotate it with @InitBinder which plays the role to identify WebDataBinder method in our controller.


Controller:

// this is used to add stuff to spring's model and it ultimately goes into the HttpServletRequest object after the handler executes
@ModelAttribute("myRequestObject")
public MyCommandBean addStuffToRequestScope() {
	System.out.println("Inside of addStuffToRequestScope");
	MyCommandBean bean = new MyCommandBean("Hello World",42);
	return bean;
}
	
	@ModelAttribute refers to a property of the Model object (the M in MVC ;) so let's say we have a form with a form backing object that is called "Person" 
	Then you can have Spring MVC supply this object to a Controller method by using the @ModelAttribute annotation:

	public String processForm(@ModelAttribute("person") Person person){
		person.getStuff();
	}
	Check here for an example (Spring 2.5), also see "Using @ModelAttribute on a method argument" (Spring 3.1).

	On the other hand the annotation is used to define objects which should be part of a Model. So if you want to have a Person object referenced in the Model you can use the following method:
	@ModelAttribute("person")
	public Person getPerson(){
		return new Person();
	}

@Valid asks spring to validate the associated object(Employee). 
BindingResult contains the outcome of this validation and any error that might have occurred during this validation. 
Notice that BindingResult must come right after the validated object else spring won’t be able to validate and an exception been thrown.
Custom errors can be added to the BindingResult: bindingResult.addError(new FieldError(...));					
					
					
********************************
Spring Security
********************************

When security is only the classpath, all endpoints by default requires basic authentitcation (including the static resource files).
CSRF protection is enabled by default.

.formLogin() - injects a Filter to the FilterChain pipeline
			 - invoked only when url is "loginProcessingUrl()"
			 - default authenticationProvider is used which uses basic authentication - can be replaced with inMemory, jdbc, or custom

@Autowired
public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
	// in memory
	auth.inMemoryAuthentication().withUser("user").password("user");

	// jdbc
	auth.jdbcAuthentication().dataSource(dataSource)
			.usersByUsernameQuery("select username,password, enabled from users where username=?")
			.authoritiesByUsernameQuery("select username, role from user_roles where username=?");

	// custom
	auth.authenticationProvider(authenticationProvider);
}

public class CustomAuthenticationProvider implements AuthenticationProvider { ... }

HttpServletRequest.login(String,String) - to programatically log the user in
HttpServletRequest.logout() - for logout

Annotation based security: @EnableGlobalMethodSecurity

f you’ve used Spring Security before, you’ll know that the framework maintains a chain of filters in order to apply its services. 
You may want to add your own filters to the stack at particular locations or use a Spring Security filter for 
which there isn’t currently a namespace configuration option.


UsernamePasswordAuthenticationFilter: this reads the "username" and "password" from the request and uses the AuthenticationManager
	to authenticate the request.
	
SecurityContextPersistenceFilter: stores the SecurityContext (user info) into the HttpSession
	
UserDetailsService: can be optionally overridden and provide a custom userDetails implementation (reach the db for instance)
GrantedAuthority: UserDetailsService provides them, usually they are roles

	
What we need for authentication:
	- Csrf filter
	- UsernamePasswordAuthenticationFilter - or a custom filter that reads the credentials and invokes AuthenticationManager.authenticate
	- custom AuthenticationProvider
	
SecurityContextRepository: its job is to store the SecurityContext. The default ones stores it in the HttpSession as an attribute.

We can use a custom filter chain by @Bean FilterChainProxy getFilterChain() {...}
	There are 3 mandatory security filters that must be included: SecurityContextPersistenceFilter, ExceptionTranslationFilter, FilterSecurityInterceptor
	
To use a custom FilterChainProxy:
	@Bean(name = "springSecurityFilterChain")
	public FilterChainProxy getFilterChainProxy() {
		SecurityFilterChain chain = new SecurityFilterChain() {

			@Override
			public boolean matches(HttpServletRequest request) {
				// All goes through here
				return true;
			}

			@Override
			public List<Filter> getFilters() {
				List<Filter> filters = new ArrayList<Filter>();

				filters.add(getCookieAuthenticationFilter());
				filters.add(getLogoutFilter());
				filters.add(getUserNamePasswordAuthenticationFilter());
				filters.add(getSecurityContextHolderAwareRequestFilter());
				filters.add(getAnonymousAuthenticationFilter());
				filters.add(getExceptionTranslationFilter());
				filters.add(getFilterSecurityInterceptor());

				return filters;
			}
		};
    
		return new FilterChainProxy(chain);
	}
	
Spring Security’s web infrastructure is based entirely on standard servlet filters. 
It doesn’t use servlets or any other servlet-based frameworks (such as Spring MVC) internally, so it has no strong links 
to any particular web technology.
Spring Security maintains a filter chain internally where each of the filters has a particular responsibility 
and filters are added or removed from the configuration depending on which services are required.


********************************
Spring Session
********************************

Overrdies the default session provided by the servlet container. We can use Gemfire, Redis, Jdbc, MongoDB transparently to store the session.

We have already mentioned that Spring Session provides transparent integration with HttpSession, but what benefits do we get out of this?
	Clustered Sessions - Spring Session makes it trivial to support clustered sessions without being tied to an application container 
					     specific solution.
						 
	Multiple Browser Sessions - Spring Session supports managing multiple users' sessions in a single browser instance 
								(i.e. multiple authenticated accounts similar to Google).

	RESTful APIs - Spring Session allows providing session ids in headers to work with RESTful APIs
	

Redis can be used by:
@Configuration
@EnableRedisHttpSession(maxInactiveIntervalInSeconds=7200)
public class HttpSessionConfig {
	@Bean
    public JedisConnectionFactory connectionFactory() {
		return new JedisConnectionFactory(); 
    }
}


JSESSIONID: this is the cookie that hold the id of the user's session


********************************
Spring Cloud, Microservices
********************************

Eureka, ZooKeeper: service registry and provide network discovery (prefer to use eureka since it is more resilient to failures)
Hystrix: fallback methods in case of failures - on the edge service, microservices
Microservice: invoked by the edge service, and they can invoke each other (hystrix needed if invoking other services for the best user experience - avoid showing stacktraces)
Zuul: egde service implementation: micro proxy, api gateway
Actuator: monitoring capabilities via jmx and rest api (use with the config server)
Config server: central store for configurations of the participants of the system
Hystrix dashboard, Turbine: use for health monitoring
Ribbon: round robin load balancer


Config service: just a super lightweight service that is used to centralize the configuration data 
	Scenario is that I have multiple microservices and do not want to store config one by one for each service, rather I would store them in a 
	central config server.
	
	@EanbleConfigServer
	application.properties: spring.cloud.config.server.git.uri=${HOME}/Desktop/config <-- in this folder resides the configs for the various microservices	
							server.port=8888

Service registry: (Eureka for example)
				  It is like a phonebook for the cloud.
				  Just a registry the regisers microservices and enables client side loadbalancing.
	
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-could-starter-config</artifactId>
	</dependency>
	
	@EnableEurekaServer
	
	bootstrap.properties: spring.application.name=eureka-service
						  spring.cloud.config.uri=http://localhost:8888	<-- config is from the config server
						  
	Start the service and visit it in the browser: you'll see a nice console window.
						  
MicroService:

	1. config comes from the config server
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-could-starter-config</artifactId>
	</dependency>

	bootstrap.properties: string.application.name=reservation-service
						  spring.cloud.config.uri=http://localhost:8888

	2. teach this service to talk to Eureka
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-could-starter-eureka</artifactId>
	</dependency>

	@EnableDiscoveryClient - now service will get registered in Eureka
						   - going to Eureka's console will display the this service ("reservation-service", comes from the bootstrap.properties)
						   
						   
Edge service: there are two types:
				1. Micro proxy: bindlys forward packages outside to the datacenter inside the loadbalancer
				2. API gateway: transforms the request to the services behind the loadbalancer
				
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-could-starter-config</artifactId>
	</dependency>
				
	1. Micro proxy: Eureka discovery, Config client, Hystrix (for circuit breakers), Zuul (for micro proxy), Stream Redis, Zipkin (distributed tracing)
	
		@EnableDiscoveryClient
		@EnableZuulProxy - blindly forward the requests from the edge service into the service that we reference in the request's url
			localhost:9999/reservation-service/reservations: {edge-service}/{serviceId as registered in the service registry}/{url in the referenced service}
		
		bootstrap.properties: sptring.application.name=reservation-client
								spring.cloud.config.uri=http://localhost:8888	<-- config is from the config server
								
	2. Api gateway: at this point same the Micro proxy: to test, localhost:9999/reservations/name
		
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-hateoas</artifactId>
		</dependency>
		
		Hystrix: allows us to specify a fallback path if the microserve request goes wrong
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-boot-starter-hystrix</artifactId>
		</dependency>
		@EnableCircuitBreaker
		
		@RestController
		@RequestMapping("/reservations")
		public class ReservationApiGatewayController {

			@Autowired
			private RestTemplate restTemplate;

			public Collection<String> getReservationNamesFallback() {
				return new ArrayList<>();
			}

			@HystrixCommand(fallbackMethod = "getReservationNamesFallback")
			@RequestMapping(method = RequestMethod.GET, value = "/names")
			public Collection<String> getReservationNames() {

				ParameterizedTypeReference<Resources<Reservation>> ptr = new ParameterizedTypeReference<Resources<Reservation>>() {};

				// "reservation-service" indentifies the microservice we are to call
				// this works if there is 1 service instance or there are multiple instances
				// however it blows chunks of there is no service, that is why the fallbackMethod specified
				ResponseEntity<Resources<Reservation>> entity = this.restTemplate.exchange("http://reservation-service/reservations", ptr);
		
				return entity
					.getBody()
					.getContent()
					.stream()
					.map(Reservation::getReservationName)
					.collapseInCollections(Collectors.toList()));
			}
		}
		
		When the url gets executed it 
			1. grabs the serviceId (reservation-service)
			2. goes to the service registry
			3. gets all registered instances of reservation-service services from the registry
			4. invokes one instance via Ribbon (which is a round-robin load-balander, each instance has the same chance to get invoked)
	
	
	This is good for reading, however for writing which requires synchronization is not good.
	We could use distributed transations but Josh Long urges us not to, it just slows down aggregate system.
	Instead use messaging: forward to the service on a message bus: job is put into a queue (buffer) and eventually gets picked up by the service.
	
	
	Spring cloud stream: a way of describing messaging based services and compose them outside of the actual code.
	
	2.1. continuing the Api gateway: the sender, producer - reservation-client
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-could-starter-stream-redis</artifactId>
		</dependency>
		Redis is just one implmenation, we could use "Rabbit and queue" or whatever
		
		@EanbleBinding(Source.class) - this enables spring cloud stream, this is the producer
		
		@RestController
		@RequestMapping("/reservations")
		public class ReservationApiGatewayController {
		
			@Autowired
			private Source source;

			@RequestMapping(method = RequestMethod.POST)
			public void writeReservation(@RequestBody Reservation r) {
				Message<String> msg = MessageBuilder<T>.withPayload(r.getReservationName())build();
				this.source.output().send(msg;)
			}
			
			...
		}
		
		where the request is sent is in the configuration: reservation-client: spring.cloud.stream.bindings.ouput: "reservations"
														   reservation-service: spring.cloud.stream.bindings.input: "reservations"
														   
														   
	2.2 the consumer, reservation-service
	
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-could-starter-stream-redis</artifactId>
		</dependency>
		
		@EanbleBinding(Sink.class)
		@IntegrationComponentScan - using Spring Integration
		
		@MessageEndpoint
		class ReservationProcessor {
		
			@ServiceActivator(inputChannel = Sink.INPUT)
			public void acceptNewReservations(String rn) {
				this.reservationRepository.save(new Reservation(rn));
			}
		}
		

Hystrix dashboard, H2 console - good stuff, start.spring.io starters
Spring cloud handles Single Sign on, Oath2 is dead simple


********************************
Spring IO
********************************

Spring IO Platform brings together the core Spring APIs into a cohesive platform for modern applications. 
It provides versions of numerous projects in the Spring portfolio along with their dependencies that are tested and known to work together.

Overriding a version using maven
	<properties>
		<foo.version>1.1.0.RELEASE</foo.version>
	</properties>
	
	
	
********************************
Spring Data
********************************

The goal of Spring Data repository abstraction is to significantly reduce the amount of boilerplate code required to implement data 
access layers for various persistence stores.

Auditing: 
	We provide @CreatedBy, @LastModifiedBy to capture the user who created or modified the entity as well as 
	@CreatedDate and @LastModifiedDate to capture the point in time this happened.
	
	@Entity
	@EntityListeners(AuditingEntityListener.class)
	public class MyEntity { }
	
	interface UserRepository extends Repository<User, Long> {
		// Redeclaration of a CRUD method
		@Lock(LockModeType.READ);
		List<User> findAll();
	}
	

	
Autogenerate sqls: CrudRepository, PagingAndSortingRepository

Async query results: @Async
					 CompletableFuture<User> findOneByFirstname(String firstname)
					 
Adding custom behavior to all repositories
	@NoRepositoryBean
	public interface MyRepository<T, ID extends Serializable>
		extends PagingAndSortingRepository<T, ID> {

		void sharedCustomMethod(ID id);
	}
	
	public class MyRepositoryImpl<T, ID extends Serializable> extends SimpleJpaRepository<T, ID> implements MyRepository<T, ID> {

		private final EntityManager entityManager;

		public MyRepositoryImpl(JpaEntityInformation entityInformation, EntityManager entityManager) {
			super(entityInformation, entityManager);

			// Keep the EntityManager around to used from the newly introduced methods.
			this.entityManager = entityManager;
		}

		public void sharedCustomMethod(ID id) {
			// implementation goes here
		}
	}
	
	
The results of query methods can be processed incrementally by using a Java 8 Stream<T> as return type. 
Instead of simply wrapping the query results in a Stream data store specific methods are used to perform the streaming.	
	@Query("select u from User u")
	Stream<User> findAllByCustomQueryAndStream();
	
	Stream<User> readAllByFirstnameNotNull();
	
	
@Query("select u from User u where u.firstname = :firstname or u.lastname = :lastname")
User findByLastnameOrFirstname(@Param("lastname") String lastname, @Param("firstname") String firstname);
								 
@Query(value = "SELECT * FROM USERS WHERE LASTNAME = ?1",
	   countQuery = "SELECT count(*) FROM USERS WHERE LASTNAME = ?1",
       nativeQuery = true)
Page<User> findByLastname(String lastname, Pageable pageable);


	
********************************
Spring Data Rest - good for integration: consumer can easily discover our API - HATEOAS
********************************

HATEOAS (Hypermedia as the Engine of Application State) is a constraint of the REST application architecture.

A hypermedia-driven site provides information to navigate the site's REST interfaces dynamically by 
including hypermedia links with the responses. This capability differs from that of SOA-based systems and WSDL-driven interfaces. 
With SOA, servers and clients usually must access a fixed specification that might be staged somewhere else on the website, on another website, 
or perhaps distributed by email.

A core principle of HATEOAS is that resources should be discoverable through the publication of links that point to the available resources. 
There are a few competing de-facto standards of how to represent links in JSON. By default, 
Spring Data REST uses HAL to render responses. HAL defines links to be contained in a property of the returned document.


Spring Data REST officially supports: Spring Data Jpa, Spring Data MongoDB, GemFire, Cassandra, Neo4j

public interface OrderRepository extends CrudRepository<Order, Long> { }. For this repository, Spring Data REST exposes a collection resource at /orders.

curl -v http://localhost:8080/

	< HTTP/1.1 200 OK
	< Content-Type: application/hal+json

	{ "_links" : {
		"orders" : {
		"href" : "http://localhost:8080/orders"
		},
		"profile" : {
		"href" : "http://localhost:8080/api/alps"
		}
	  }
	}


	
********************************
Spring Framework
********************************

Dependency Injection:
	@PostConstruct
	@PreDestroy

	
	
********************************
Spring Boot
********************************

Boot priorities:
	1. Commandline args
	2. JNDI
	3. Java System properties		- System.getProperty("path.separator");
	4. OS Environment variables		- System.getenv();
	5. Properties files				- application.properties
	6. @PropertySource				- @PropertySource("classpath:/com/myco/app.properties"), then in the config java file: @Autowired Environment env;
	7. Defaults


	
********************************
Useful utils
********************************
	
org.springframework.util.FileSystemUtils
org.springframework.beans.BeanUtils




********************************
Streaming http requests
********************************

Return RxJava Observable


********************************
Eclipse multi maven project with Spring, TDPraktiker
********************************
1. workspace resolution works, eclipse sees, maven also sees the dependencies being in the same workspace: 
2. install the dependency into  the local repo with "mvn install" --> update the consumer project via "maven update" then voila, works!

TDPraktiker: parentPom/pom.xml: only for jenkins build

ServletInitializer: necessary in order for Spring to generate web.xml (project is dynamic webproject and packaging is war - app is deployed to an existing serverlet container)
					Without this the war is either not generated or not works at all (not sure what Gabor said)
					however probably this can be omitted by using "AbstractAnnotationConfigDispatcherServletInitializer" as demonstrated above



class Convert<M, R> {

	public R convert(M model, Class<R> aClass) {
		R result;
		try {
			result = aClass.newInstance();
			org.springframework.beans.BeanUtils.copyProperties(model, result);
			return result;
		} catch (InstantiationException | IllegalAccessException e) {
			e.printStackTrace();
		}
		return null;
	}
}