@Component
@Service
@Repository
@Controller
@RestController
@Scope
@Bean

@Valid
@ModelAttribute - this is used to add stuff to spring's model and it ultimately goes into the HttpServletRequest object after the handler executes
@SessionAttributes("key") - adds the value from the ModelMap that belongs to the specified key to the HttpSession object after the handler executes
@ResponseBody
@RequestBody
@PathParam
@Value - specify default value on properties. Can be arbirtary string or expression e.g. "#{systemProperties.myProp}"

@ControllerAdvice - it is typically used to define @ExceptionHandler, @InitBinder, and @ModelAttribute methods that apply to all @RequestMapping methods.
@ExceptionHandler
@ResponseStatus

@Cacheable - to use Spring's cache - implementations can be swapped

@Lazy - lazily initialze beans

@Import - Provides functionality equivalent to the <import/> element in Spring XML. Allows for importing @Configuration classes, ImportSelector and ImportBeanDefinitionRegistrar implementations, 
		  as well as regular component classes (as of 4.2; analogous to AnnotationConfigApplicationContext.register(java.lang.Class<?>...)).
	
@EnableScheduling
@Scheduled

@Cacheable	
		  
MVC:
@RequestAttribute allows to access request attributes
@CookieValue annotation allows a method parameter to be bound to the value of an HTTP cookie.
@RequestHeader annotation allows a method parameter to be bound to a request header.
@InitBinder - allows you to configure web data binding directly within your controller class
@ControllerAdvice and @RestControllerAdvice is a component annotation allowing implementation classes to be auto-detected through classpath scanning. 
	Classes annotated with @ControllerAdvice can contain @ExceptionHandler, @InitBinder, and @ModelAttribute annotated methods, 
	and these methods will apply to @RequestMapping methods across all controller hierarchies as opposed to the controller hierarchy within which they are declared.
	

org.springframework.beans.factory.Aware
Sometimes we need Spring Framework objects in our beans to perform some operations, 
for example reading ServletConfig and ServletContext parameters or to know the bean definitions loaded by the ApplicationContext. 
That’s why spring framework provides a bunch of *Aware interfaces that we can implement in our bean classes.

mvn -DskipTests=true clean install

spring.factories: a file that contains auto-configuration classes for everything. These are only included when certain
	conditions are met thanks to the @ConditionalOnClass annotation which is like the .NET #ifdef
	
https://github.com/spring-projects/spring-boot
https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure
	

Spring:
	- Dev tools: automatically restarts the server when any change happens to our source files (.java, .jsp) on the local classpath.
				 It is automatically disabled in production: when the app is started via the command line.

		- this is achieved by using 2 class loaders: 1 for the libs, maven dependencies which never change
													 1 for our source code which can change
		- in case of a change the lib classloader remains intact, whereas the source-file classloader is recreated. This ensures performance in a microservice world.
		
	- Actuator: provides monitoring capabilities that can be reached via http endpoints or via JMX

		- Endpoints Actuator endpoints allow you to monitor and interact with your application. 
		  Spring Boot includes a number of built-in endpoints and you can also add your own. 
		  For example the health endpoint provides basic application health information. 
		  Run up a basic application and look at /health (and see /mappings for a list of other HTTP endpoints).

		- Metrics Spring Boot Actuator includes a metrics service with “gauge” and “counter” support.
		  A “gauge” records a single value; and a “counter” records a delta (an increment or decrement). 
		  Metrics for all HTTP requests are automatically recorded, so if you hit the metrics endpoint should see a sensible response.

		- Audit Spring Boot Actuator has a flexible audit framework that will publish events to an AuditService. 
		  Once Spring Security is in play it automatically publishes authentication events by default. 
		  This can be very useful for reporting, and also to implement a lock-out policy based on authentication failures.

		- Process Monitoring In Spring Boot Actuator you can find ApplicationPidFileWriter which creates a file containing the 
		  application PID (by default in the application directory with a file name of application.pid).
		  
		  
		  
JDBC:
		// load the Driver Class
		Class.forName(props.getProperty("DB_DRIVER_CLASS"));

		// create the connection now
		con = DriverManager.getConnection(props.getProperty("DB_URL"),
				props.getProperty("DB_USERNAME"),
				props.getProperty("DB_PASSWORD"));
	
	
JDBC DataSource:
	Most of the times we are looking for loose coupling for connectivity so that we can switch databases easily, 
	connection pooling for transaction management and distributed systems support. JDBC DataSource is the preferred approach 
	if you are looking for any of these features in your application. 
	
	
Spring DataSource implementation: DriverManagerDataSource!
	<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">

		<property name="driverClassName" value="com.mysql.jdbc.Driver" />
		<property name="url" value="jdbc:mysql://localhost:3306/TestDB" />
		<property name="username" value="pankaj" />
		<property name="password" value="pankaj123" />
	</bean>
	
	But we still have to write a lot of boilerplate code: opening connection, statements, closing them, reading the resulet set in a for loop.
	
	
Spring JdbcTemplate to the rescue:
	All we need is to provide the arguments as Object array and implement Callback interfaces such as 
	PreparedStatementSetter and RowMapper for mapping arguments or converting ResultSet data to bean objects.
	
	
JPA: EntityManager
Hibernate: Session


@Lob @Basic(fetch = FetchType.LAZY)
@Column(name="content", nullable=false)
private byte[] content;
 
We have chosen a byte[] to store the content of file. @LobSpecifies that a this persistent property should be persisted as a 
large object to a database-supported large object type which in our case is longblob. 
@Basic annotation is an optional annotation, serving here as placeholder to instruct hibernate to lazy load the binary content.

Java's transient keyword is used to denote that a field is not to be serialized, whereas JPA's @Transient 
annotation is used to indicate that a field is not to be persisted in the database, i.e. their semantics are different.

Hibernate SQLQuery: not recommended because we loose benefits of 1st level cache

1st level cache: - at the Session level
				 - enabled by default
				 - for the current user
2nd level cache: - at the JVM level, Session Factory object --> concurrency is a problem
				 - for all users
				 - disabled by default
					- can enable globally (not recommended)
					- only for certain entities, collections
					- configurable at the Session level with CacheMode
				 - cache all properties (default) or only non-lazy
Query cache: - good for repetitive queries with identical params
			 - if used, best in conjunection with 2LC

session.save() 				- saves changes to db (insert or update)) but does not add entity to persistent context: doesn't track entity
							  and further changes at transaction commit won't get saved. 
							  Works without transaction.

session.saveOrUpdate() 		- adds the entity object to persistent context and track any further changes. 
							  Any further changes are saved at the time of committing transaction, like persist.
							  Works without transaction.

session.persist()			- Hibernate persist is similar to save (with transaction) and it adds the entity object to the persistent context, 
							  so any further changes are tracked. If the object properties are changed before the transaction is committed or 
							  session is flushed, it will also be saved into database.
							  Second difference is that we can use persist() method only within the boundary of a transaction, 
							  so it’s safe and takes care of any cascaded objects.
							  
session.update()			- Hibernate update should be used where we know that we are only updating the entity information. 
							  This operation adds the entity object to persistent context and further changes are tracked and saved when 
							  transaction is committed.
							  
session.merge()				- Hibernate merge can be used to update existing values, however this method create a copy from the passed entity object
							  and return it. The returned object is part of persistent context and tracked for any changes, 
							  passed object is not tracked. This is the major difference with merge() from all other methods. 
							  

							  
SessionFactory (org.hibernate.SessionFactory): 						SessionFactory is an immutable thread-safe cache of compiled mappings for a 
																	single database. We can get instance of org.hibernate.Session using SessionFactory.
																	
Session (org.hibernate.Session): 									Session is a single-threaded, short-lived object representing a conversation 
																	between the application and the persistent store. 
																	It wraps JDBC java.sql.Connection and works as a factory for 
																	org.hibernate.Transaction.
																	
ConnectionProvider (org.hibernate.connection.ConnectionProvider): 	ConnectionProvider is a factory for JDBC connections. It provides abstraction 
																	between the application and underlying javax.sql.DataSource or 
																	java.sql.DriverManager. It is not exposed to application, but it can be 
																	extended by the developer.

TransactionFactory (org.hibernate.TransactionFactory): 				A factory for org.hibernate.Transaction instances.

In its default configuration, the Spring Framework’s transaction infrastructure code only marks a transaction for rollback in the case of runtime,
unchecked exceptions; that is, when the thrown exception is an instance or subclass of RuntimeException. 
(Errors will also - by default - result in a rollback). 
Checked exceptions that are thrown from a transactional method do not result in rollback in the default configuration.

@Transactional: must be applied on public methods to get weaved. Also, only works when invoking the object outside of it - means that invoking 
				another public method from the invoked public method that has @Transactional would take no effect either.
				Rolled back automatically only if unchecked RuntimeException is thrown (checked exceptions does not make the transaction rollback)

Normally both JPA and Hibernate require an xml config (persistence.xml, hibernate.cfg.xml), but with Spring these can be omitted.
(Spring scans the package and packages down for @Entity classes.) @EnableJpaRepositories("com.acme.repositories")

@Entity --> @Respository (Dao) --> @Service --> @Controller/@Restcontroller			
					
					
********************************
Spring Security
********************************

When security is only the classpath, all endpoints by default requires basic authentitcation (including the static resource files).
CSRF protection is enabled by default.

.formLogin() - injects a Filter to the FilterChain pipeline
			 - invoked only when url is "loginProcessingUrl()"
			 - default authenticationProvider is used which uses basic authentication - can be replaced with inMemory, jdbc, or custom

@Autowired
public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
	// in memory
	auth.inMemoryAuthentication().withUser("user").password("user");

	// jdbc
	auth.jdbcAuthentication().dataSource(dataSource)
			.usersByUsernameQuery("select username,password, enabled from users where username=?")
			.authoritiesByUsernameQuery("select username, role from user_roles where username=?");

	// custom
	auth.authenticationProvider(authenticationProvider);
}

public class CustomAuthenticationProvider implements AuthenticationProvider { ... }

HttpServletRequest.login(String,String) - to programatically log the user in
HttpServletRequest.logout() - for logout

Annotation based security: @EnableGlobalMethodSecurity

f you’ve used Spring Security before, you’ll know that the framework maintains a chain of filters in order to apply its services. 
You may want to add your own filters to the stack at particular locations or use a Spring Security filter for 
which there isn’t currently a namespace configuration option.


UsernamePasswordAuthenticationFilter: this reads the "username" and "password" from the request and uses the AuthenticationManager
	to authenticate the request.
	
SecurityContextPersistenceFilter: stores the SecurityContext (user info) into the HttpSession
	
UserDetailsService: can be optionally overridden and provide a custom userDetails implementation (reach the db for instance)
GrantedAuthority: UserDetailsService provides them, usually they are roles

	
What we need for authentication:
	- Csrf filter
	- UsernamePasswordAuthenticationFilter - or a custom filter that reads the credentials and invokes AuthenticationManager.authenticate
	- custom AuthenticationProvider
	
SecurityContextRepository: its job is to store the SecurityContext. The default ones stores it in the HttpSession as an attribute.

We can use a custom filter chain by @Bean FilterChainProxy getFilterChain() {...}
	There are 3 mandatory security filters that must be included: SecurityContextPersistenceFilter, ExceptionTranslationFilter, FilterSecurityInterceptor
	
To use a custom FilterChainProxy:
	@Bean(name = "springSecurityFilterChain")
	public FilterChainProxy getFilterChainProxy() {
		SecurityFilterChain chain = new SecurityFilterChain() {

			@Override
			public boolean matches(HttpServletRequest request) {
				// All goes through here
				return true;
			}

			@Override
			public List<Filter> getFilters() {
				List<Filter> filters = new ArrayList<Filter>();

				filters.add(getCookieAuthenticationFilter());
				filters.add(getLogoutFilter());
				filters.add(getUserNamePasswordAuthenticationFilter());
				filters.add(getSecurityContextHolderAwareRequestFilter());
				filters.add(getAnonymousAuthenticationFilter());
				filters.add(getExceptionTranslationFilter());
				filters.add(getFilterSecurityInterceptor());

				return filters;
			}
		};
    
		return new FilterChainProxy(chain);
	}
	
Spring Security’s web infrastructure is based entirely on standard servlet filters. 
It doesn’t use servlets or any other servlet-based frameworks (such as Spring MVC) internally, so it has no strong links 
to any particular web technology.
Spring Security maintains a filter chain internally where each of the filters has a particular responsibility 
and filters are added or removed from the configuration depending on which services are required.


********************************
Spring Session
********************************

Overrdies the default session provided by the servlet container. We can use Gemfire, Redis, Jdbc, MongoDB transparently to store the session.

We have already mentioned that Spring Session provides transparent integration with HttpSession, but what benefits do we get out of this?
	Clustered Sessions - Spring Session makes it trivial to support clustered sessions without being tied to an application container 
					     specific solution.
						 
	Multiple Browser Sessions - Spring Session supports managing multiple users' sessions in a single browser instance 
								(i.e. multiple authenticated accounts similar to Google).

	RESTful APIs - Spring Session allows providing session ids in headers to work with RESTful APIs
	

Redis can be used by:
@Configuration
@EnableRedisHttpSession(maxInactiveIntervalInSeconds=7200)
public class HttpSessionConfig {
	@Bean
    public JedisConnectionFactory connectionFactory() {
		return new JedisConnectionFactory(); 
    }
}


JSESSIONID: this is the cookie that hold the id of the user's session


********************************
Spring Cloud, Microservices
********************************

Eureka, ZooKeeper: service registry and provide network discovery (prefer to use eureka since it is more resilient to failures)
Hystrix: fallback methods in case of failures - on the edge service, microservices
Microservice: invoked by the edge service, and they can invoke each other (hystrix needed if invoking other services for the best user experience - avoid showing stacktraces)
Zuul: egde service implementation: micro proxy, api gateway
Actuator: monitoring capabilities via jmx and rest api (use with the config server)
Config server: central store for configurations of the participants of the system
Hystrix dashboard, Turbine: use for health monitoring
Ribbon: round robin load balancer


Config service: just a super lightweight service that is used to centralize the configuration data 
	Scenario is that I have multiple microservices and do not want to store config one by one for each service, rather I would store them in a 
	central config server.
	
	@EanbleConfigServer
	application.properties: spring.cloud.config.server.git.uri=${HOME}/Desktop/config <-- in this folder resides the configs for the various microservices	
							server.port=8888

Service registry: (Eureka for example)
				  It is like a phonebook for the cloud.
				  Just a registry the regisers microservices and enables client side loadbalancing.
	
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-could-starter-config</artifactId>
	</dependency>
	
	@EnableEurekaServer
	
	bootstrap.properties: spring.application.name=eureka-service
						  spring.cloud.config.uri=http://localhost:8888	<-- config is from the config server
						  
	Start the service and visit it in the browser: you'll see a nice console window.
						  
MicroService:

	1. config comes from the config server
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-could-starter-config</artifactId>
	</dependency>

	bootstrap.properties: string.application.name=reservation-service
						  spring.cloud.config.uri=http://localhost:8888

	2. teach this service to talk to Eureka
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-could-starter-eureka</artifactId>
	</dependency>

	@EnableDiscoveryClient - now service will get registered in Eureka
						   - going to Eureka's console will display the this service ("reservation-service", comes from the bootstrap.properties)
						   
						   
Edge service: there are two types:
				1. Micro proxy: bindlys forward packages outside to the datacenter inside the loadbalancer
				2. API gateway: transforms the request to the services behind the loadbalancer
				
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-could-starter-config</artifactId>
	</dependency>
				
	1. Micro proxy: Eureka discovery, Config client, Hystrix (for circuit breakers), Zuul (for micro proxy), Stream Redis, Zipkin (distributed tracing)
	
		@EnableDiscoveryClient
		@EnableZuulProxy - blindly forward the requests from the edge service into the service that we reference in the request's url
			localhost:9999/reservation-service/reservations: {edge-service}/{serviceId as registered in the service registry}/{url in the referenced service}
		
		bootstrap.properties: sptring.application.name=reservation-client
								spring.cloud.config.uri=http://localhost:8888	<-- config is from the config server
								
	2. Api gateway: at this point same the Micro proxy: to test, localhost:9999/reservations/name
		
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-hateoas</artifactId>
		</dependency>
		
		Hystrix: allows us to specify a fallback path if the microserve request goes wrong
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-boot-starter-hystrix</artifactId>
		</dependency>
		@EnableCircuitBreaker
		
		@RestController
		@RequestMapping("/reservations")
		public class ReservationApiGatewayController {

			@Autowired
			private RestTemplate restTemplate;

			public Collection<String> getReservationNamesFallback() {
				return new ArrayList<>();
			}

			@HystrixCommand(fallbackMethod = "getReservationNamesFallback")
			@RequestMapping(method = RequestMethod.GET, value = "/names")
			public Collection<String> getReservationNames() {

				ParameterizedTypeReference<Resources<Reservation>> ptr = new ParameterizedTypeReference<Resources<Reservation>>() {};

				// "reservation-service" indentifies the microservice we are to call
				// this works if there is 1 service instance or there are multiple instances
				// however it blows chunks of there is no service, that is why the fallbackMethod specified
				ResponseEntity<Resources<Reservation>> entity = this.restTemplate.exchange("http://reservation-service/reservations", ptr);
		
				return entity
					.getBody()
					.getContent()
					.stream()
					.map(Reservation::getReservationName)
					.collapseInCollections(Collectors.toList()));
			}
		}
		
		When the url gets executed it 
			1. grabs the serviceId (reservation-service)
			2. goes to the service registry
			3. gets all registered instances of reservation-service services from the registry
			4. invokes one instance via Ribbon (which is a round-robin load-balander, each instance has the same chance to get invoked)
	
	
	This is good for reading, however for writing which requires synchronization is not good.
	We could use distributed transations but Josh Long urges us not to, it just slows down aggregate system.
	Instead use messaging: forward to the service on a message bus: job is put into a queue (buffer) and eventually gets picked up by the service.
	
	
	Spring cloud stream: a way of describing messaging based services and compose them outside of the actual code.
	
	2.1. continuing the Api gateway: the sender, producer - reservation-client
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-could-starter-stream-redis</artifactId>
		</dependency>
		Redis is just one implmenation, we could use "Rabbit and queue" or whatever
		
		@EanbleBinding(Source.class) - this enables spring cloud stream, this is the producer
		
		@RestController
		@RequestMapping("/reservations")
		public class ReservationApiGatewayController {
		
			@Autowired
			private Source source;

			@RequestMapping(method = RequestMethod.POST)
			public void writeReservation(@RequestBody Reservation r) {
				Message<String> msg = MessageBuilder<T>.withPayload(r.getReservationName())build();
				this.source.output().send(msg;)
			}
			
			...
		}
		
		where the request is sent is in the configuration: reservation-client: spring.cloud.stream.bindings.ouput: "reservations"
														   reservation-service: spring.cloud.stream.bindings.input: "reservations"
														   
														   
	2.2 the consumer, reservation-service
	
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-could-starter-stream-redis</artifactId>
		</dependency>
		
		@EanbleBinding(Sink.class)
		@IntegrationComponentScan - using Spring Integration
		
		@MessageEndpoint
		class ReservationProcessor {
		
			@ServiceActivator(inputChannel = Sink.INPUT)
			public void acceptNewReservations(String rn) {
				this.reservationRepository.save(new Reservation(rn));
			}
		}
		

Hystrix dashboard, H2 console - good stuff, start.spring.io starters
Spring cloud handles Single Sign on, Oath2 is dead simple



********************************
Spring cloud deployment
********************************

Cloud Foundry: PaaS platform
BOSH: how you automate, install and congfigure a CF system (among other things, it does a lot of stuff)



********************************
Spring IO
********************************

Spring IO Platform brings together the core Spring APIs into a cohesive platform for modern applications. 
It provides versions of numerous projects in the Spring portfolio along with their dependencies that are tested and known to work together.

Overriding a version using maven
	<properties>
		<foo.version>1.1.0.RELEASE</foo.version>
	</properties>
	
	
	
********************************
Spring Data
********************************

The goal of Spring Data repository abstraction is to significantly reduce the amount of boilerplate code required to implement data 
access layers for various persistence stores.

Auditing: 
	We provide @CreatedBy, @LastModifiedBy to capture the user who created or modified the entity as well as 
	@CreatedDate and @LastModifiedDate to capture the point in time this happened.
	
	@Entity
	@EntityListeners(AuditingEntityListener.class)
	public class MyEntity { }
	
	interface UserRepository extends Repository<User, Long> {
		// Redeclaration of a CRUD method
		@Lock(LockModeType.READ);
		List<User> findAll();
	}
	

	
Autogenerate sqls: CrudRepository, PagingAndSortingRepository

Async query results: @Async
					 CompletableFuture<User> findOneByFirstname(String firstname)
					 
Adding custom behavior to all repositories
	@NoRepositoryBean
	public interface MyRepository<T, ID extends Serializable>
		extends PagingAndSortingRepository<T, ID> {

		void sharedCustomMethod(ID id);
	}
	
	public class MyRepositoryImpl<T, ID extends Serializable> extends SimpleJpaRepository<T, ID> implements MyRepository<T, ID> {

		private final EntityManager entityManager;

		public MyRepositoryImpl(JpaEntityInformation entityInformation, EntityManager entityManager) {
			super(entityInformation, entityManager);

			// Keep the EntityManager around to used from the newly introduced methods.
			this.entityManager = entityManager;
		}

		public void sharedCustomMethod(ID id) {
			// implementation goes here
		}
	}
	
	
The results of query methods can be processed incrementally by using a Java 8 Stream<T> as return type. 
Instead of simply wrapping the query results in a Stream data store specific methods are used to perform the streaming.	
	@Query("select u from User u")
	Stream<User> findAllByCustomQueryAndStream();
	
	Stream<User> readAllByFirstnameNotNull();
	
	
@Query("select u from User u where u.firstname = :firstname or u.lastname = :lastname")
User findByLastnameOrFirstname(@Param("lastname") String lastname, @Param("firstname") String firstname);
								 
@Query(value = "SELECT * FROM USERS WHERE LASTNAME = ?1",
	   countQuery = "SELECT count(*) FROM USERS WHERE LASTNAME = ?1",
       nativeQuery = true)
Page<User> findByLastname(String lastname, Pageable pageable);


	
********************************
Spring Data Rest - good for integration: consumer can easily discover our API - HATEOAS
********************************

HATEOAS (Hypermedia as the Engine of Application State) is a constraint of the REST application architecture.

A hypermedia-driven site provides information to navigate the site's REST interfaces dynamically by 
including hypermedia links with the responses. This capability differs from that of SOA-based systems and WSDL-driven interfaces. 
With SOA, servers and clients usually must access a fixed specification that might be staged somewhere else on the website, on another website, 
or perhaps distributed by email.

A core principle of HATEOAS is that resources should be discoverable through the publication of links that point to the available resources. 
There are a few competing de-facto standards of how to represent links in JSON. By default, 
Spring Data REST uses HAL to render responses. HAL defines links to be contained in a property of the returned document.


Spring Data REST officially supports: Spring Data Jpa, Spring Data MongoDB, GemFire, Cassandra, Neo4j

public interface OrderRepository extends CrudRepository<Order, Long> { }. For this repository, Spring Data REST exposes a collection resource at /orders.

curl -v http://localhost:8080/

	< HTTP/1.1 200 OK
	< Content-Type: application/hal+json

	{ "_links" : {
		"orders" : {
		"href" : "http://localhost:8080/orders"
		},
		"profile" : {
		"href" : "http://localhost:8080/api/alps"
		}
	  }
	}


	
********************************
Spring Batch
********************************

Spring Batch is not a scheduling framework.
Usage:
	A typical batch program generally reads a large number of records from a database, file, or queue, processes the data in some fashion, 
	and then writes back data in a modified form. Spring Batch automates this basic batch iteration, providing the capability to process similar 
	transactions as a set, typically in an offline environment without any user interaction. 
	
Business Scenarios:
	Commit batch process periodically
	Concurrent batch processing: parallel processing of a job
	Staged, enterprise message-driven processing
	Massively parallel batch processing
	Manual or scheduled restart after failure
	Sequential processing of dependent steps (with extensions to workflow-driven batches)
	Partial processing: skip records (e.g. on rollback)
	Whole-batch transaction: for cases with a small batch size or existing stored procedures/scripts
	
Processing options:
	1. Normal processing in a batch window during off-line
	2. Concurrent batch / on-line processing
	3. Parallel processing of many different batch runs or jobs at the same time
	4. Partitioning (i.e. processing of many instances of the same job at the same time)
	
	1. For simple batch processes running in a separate batch window, where the data being updated is not required by on-line users or other batch processes, 
		concurrency is not an issue and a single commit can be done at the end of the batch run.
		
	2. Batch applications processing data that can simultaneously be updated by on-line users, should not lock any data (either in the database or in files) which 
		could be required by on-line users for more than a few seconds. Also updates should be committed to the database at the end of every few transaction. 
		This minimizes the portion of data that is unavailable to other processes and the elapsed time the data is unavailable.
		
	3. Parallel processing allows multiple batch runs / jobs to run in parallel to minimize the total elapsed batch processing time. This is not a problem as long 
		as the jobs are not sharing the same files, db-tables or index spaces. If they do, this service should be implemented using partitioned data. 
	
	4. Using partitioning allows multiple versions of large batch applications to run concurrently. The purpose of this is to reduce the elapsed time required to 
		process long batch jobs. Processes which can be successfully partitioned are those where the input file can be split and/or the main database tables partitioned 
		to allow the application to run against different sets of data.

		
Job: A Job is an entity that encapsulates an entire batch process. It contains one or more steps.
JobIstance: JobInstance = Job + identifying JobParameters. A JobInstance refers to the concept of a logical job run.
JobExecution: A JobExecution refers to the technical concept of a single attempt to run a Job.
Setp: ItemReader + ItemProcessor + ItemWriter
StepExecution: represents a single attempt to execute a Step
JobRepository: JobRepository is the persistence mechanism for all of the Stereotypes mentioned above.
JobLauncher represents a simple interface for launching a Job with a given set of JobParameters.
ItemReader is an abstraction that represents the retrieval of input for a Step, one item at a time. When the ItemReader has exhausted the items it can provide, it will indicate this by returning null.
ItemWriter is an abstraction that represents the output of a Step, one batch or chunk of items at a time.
ItemProcessor is an abstraction that represents the business processing of an item. While the ItemReader reads one item, and the ItemWriter writes them, the ItemProcessor 
	provides access to transform or apply other business processing. If, while processing the item, it is determined that the item is not valid, returning null indicates that the item should not be written out.
	
One key issue when executing a batch job concerns the behavior of a Job when it is restarted. The launching of a Job is considered to be a 'restart' if a JobExecution already exists for the particular JobInstance.

In-Memory Repository: There are scenarios in which you may not want to persist your domain objects to the database.
	<bean id="jobRepository" class="org.springframework.batch.core.repository.support.MapJobRepositoryFactoryBean">
		<property name="transactionManager" ref="transactionManager"/>
	</bean>
	
Chunk-Oriented Processing
	Spring Batch uses a 'Chunk Oriented' processing style within its most common implementation. Chunk oriented processing refers to reading the data one at a time,
	and creating 'chunks' that will be written out, within a transaction boundary. One item is read in from an ItemReader, handed to an ItemProcessor, and aggregated. 
	Once the number of items read equals the commit interval, the entire chunk is written out via the ItemWriter, and then the transaction is committed.
	
All batch processing can be described in its most simple form as reading in large amounts of data, performing some type of calculation or transformation, and writing the result out.
	Spring Batch provides three key interfaces to help perform bulk reading and writing: ItemReader, ItemProcessor and ItemWriter.
	

Scaling and Parallel Processing
	Multi-threaded Step: The result of the above configuration will be that the Step executes by reading, processing and writing each chunk of items (each commit interval)
					 in a separate thread of execution. Note that this means there is no fixed order for the items to be processed, and a chunk might contain items that are 
					 non-consecutive compared to the single-threaded case. In addition to any limits placed by the task executor (e.g. if it is backed by a thread pool), 
					 there is a throttle limit in the tasklet configuration which defaults to 4. You may need to increase this to ensure that a thread pool is fully utilised.
					 
	Parallel Steps: steps execute parallel

	Remote Chunking: In Remote Chunking the Step processing is split across multiple processes, communicating with each other through some middleware.

	Paritioning: Spring Batch also provides an SPI for partitioning a Step execution and executing it remotely.



********************************
Spring 	Integration	
********************************

In addition to wiring together fine-grained components, Spring Integration provides a wide selection of channel adapters and gateways to 
communicate with external systems. Channel Adapters are used for one-way integration (send or receive); 
gateways are used for request/reply scenarios (inbound or outbound).


Spring Integration provides an extension of the Spring programming model to support the well-known Enterprise Integration Patterns. 
It enables lightweight messaging within Spring-based applications and supports integration with external systems via declarative adapters. 
Those adapters provide a higher-level of abstraction over Spring’s support for remoting, messaging, and scheduling.

Spring Integration is motivated by the following goals:
	Provide a simple model for implementing complex enterprise integration solutions.
	Facilitate asynchronous, message-driven behavior within a Spring-based application.
	Promote intuitive, incremental adoption for existing Spring users.
Spring Integration is guided by the following principles:
	Components should be loosely coupled for modularity and testability.
	The framework should enforce separation of concerns between business logic and integration logic.
	Extension points should be abstract in nature but within well-defined boundaries to promote reuse and portability.
	
Message: In Spring Integration, a Message is a generic wrapper for any Java object combined with metadata used by the framework while handling 
		 that object. It consists of a payload and headers.
Message Channel: A Message Channel represents the "pipe" of a pipes-and-filters architecture. 
				 Producers send Messages to a channel, and consumers receive Messages from a channel. 
				 The Message Channel therefore decouples the messaging components, and also provides a convenient point for interception 
				 and monitoring of Messages.
				 
				 A Message Channel may follow either Point-to-Point or Publish/Subscribe semantics. With a Point-to-Point channel, 
				 at most one consumer can receive each Message sent to the channel. Publish/Subscribe channels, on the other hand, 
				 will attempt to broadcast each Message to all of its subscribers. Spring Integration supports both of these.
				 will attempt to broadcast each Message to all of its subscribers. Spring Integration supports both of these.
Message Endpoint: One of the primary goals of Spring Integration is to simplify the development of enterprise integration solutions 
				  through inversion of control. This means that you should not have to implement consumers and producers directly,
				  and you should not even have to build Messages and invoke send or receive operations on a Message Channel. 
				  Instead, you should be able to focus on your specific domain model with an implementation based on plain Objects. 
				  Then, by providing declarative configuration, you can "connect" your domain-specific code to the messaging infrastructure
				  provided by Spring Integration. The components responsible for these connections are Message Endpoints.
				  
Message Endpoints: A Message Endpoint represents the "filter" of a pipes-and-filters architecture. As mentioned above, the endpoint’s 
				   primary role is to connect application code to the messaging framework and to do so in a non-invasive manner. 
				   In other words, the application code should ideally have no awareness of the Message objects or the Message Channels.
				   This is similar to the role of a Controller in the MVC paradigm. Just as a Controller handles HTTP requests, 
				   the Message Endpoint handles Messages. Just as Controllers are mapped to URL patterns, Message Endpoints are mapped 
				   to Message Channels.
Transformer: A Message Transformer is responsible for converting a Message’s content or structure and returning the modified Message.
Filter: A Message Filter determines whether a Message should be passed to an output channel at all. 
Router: A Message Router is responsible for deciding what channel or channels should receive the Message next (if any). 
Service Activator: A Service Activator is a generic endpoint for connecting a service instance to the messaging system.
Channel Adapter: A Channel Adapter is an endpoint that connects a Message Channel to some other system (external system) or transport. 
				 Channel Adapters may be either inbound or outbound. Typically, the Channel Adapter will do some mapping between the 
				 Message and whatever object or resource is received-from or sent-to the other system (File, HTTP Request, JMS Message, etc).
				 Depending on the transport, the Channel Adapter may also populate or extract Message header values. 
				 Spring Integration provides a number of Channel Adapters, and they will be described in upcoming chapters.

@EnableIntegration
@IntegrationComponentScan
@EnablePublisher

MessagingTemplate: send, receive, sendAndReceive

Channel Adapter: A Channel Adapter is a Message Endpoint that enables connecting a single sender or receiver to a Message Channel. 
				 Spring Integration provides a number of adapters out of the box to support various transports, such as JMS, File, HTTP,
				 Web Services, Mail, and more. 
Messaging Bridge: A Messaging Bridge is a relatively trivial endpoint that simply connects two Message Channels or Channel Adapters.
MessageBuilder 
	
	
********************************
Spring Framework
********************************

The syntax ${x:${y}} is Spring property shorthand for ${x} != null ? ${x} : ${y}.
eureka:
  instance:
    metadataMap:
      instanceId: ${spring.application.name}:${spring.application.instance_id:${server.port}}

Dependency Injection:
	@PostConstruct
	@PreDestroy
	

Components: 
	Core Container: consists of the spring-core, spring-beans, spring-context, spring-context-support, and spring-expression 
					(Spring Expression Language) modules. he Context module also supports Java EE features such as EJB, JMX, and basic remoting.
	AOP and Instrumentation: aspect-oriented programming implementation allowing you to define, for example, method interceptors and pointcuts to cleanly decouple code that implements functionality that should be separated.
	Messaging: Spring Framework 4 includes a spring-messaging module with key abstractions from the Spring Integration project such as Message, MessageChannel, MessageHandler, and others to serve as a foundation for messaging-based applications.
	Data Access/Integration: The Data Access/Integration layer consists of the JDBC, ORM, OXM, JMS, and Transaction modules.
	Web: The Web layer consists of the spring-web, spring-webmvc, spring-websocket, and spring-webmvc-portlet modules.
		The spring-web module provides basic web-oriented integration features such as multipart file upload functionality and the 
			initialization of the IoC container using Servlet listeners and a web-oriented application context. 
			It also contains an HTTP client and the web-related parts of Spring’s remoting support.
		The spring-webmvc module (also known as the Web-Servlet module) contains Spring’s model-view-controller (MVC) and REST Web Services
			implementation for web applications. Spring’s MVC framework provides a clean separation between domain model code and 
			web forms and integrates with all of the other features of the Spring Framework.
	Test: The spring-test module supports the unit testing and integration testing of Spring components with JUnit or TestNG. It provides consistent 
		loading of Spring ApplicationContexts and caching of those contexts. It also provides mock objects that you can use to test your code in isolation.
	
	
For logging JCL (Jakarta Common Logging) library is used, but it was a mistake. It can be excluded from the dependencies of spring-core and use
SLF4J  instead.
		
JMS improvements: Synchronous request-reply operations support in JmsTemplate
Caching improvements

Beans by default are Singletons and eagerly initialized. Use @Lazy for lazy initialization.
Bean scopes: singleton, prototype, request, session, globalsession, application, websocket

Method injection: used typically when a Singleton bean (A) has prototype dependency (B) and A needs new B instances.
	- inject the ApplicationContext and use the Service Locator pattern is the only solution
	
To interact with the container’s management of the bean lifecycle, you can implement the Spring InitializingBean and DisposableBean interfaces.
	BUT: The JSR-250 @PostConstruct and @PreDestroy annotations are generally considered best practice for receiving lifecycle callbacks in a modern 
	Spring application. Using these annotations means that your beans are not coupled to Spring specific interfaces.
	
	
7.6.3 Other Aware interfaces: ApplicationContextAware, BeanNameAware, ServletConfigAware, ServletContextAware
7.9 Annotation-based container configuration

@Required, 
@Autowired - resolves dependencies by type
@Primary - indicates that a particular bean should be given preference when multiple beans are candidates to be autowired to a single-valued dependency
@Qualifier - specify the name of the dependency (use @Beans(name = "..."))
@Bean - can be used on methods, by default the beans's name is the name of the method
@Resource - takes a name attribute, and by default Spring interprets that value as the bean name to be injected. 
			In other words, it follows by-name semantics, like this:
				@Resource(name="myMovieFinder")
				public void setMovieFinder(MovieFinder movieFinder) {
					this.movieFinder = movieFinder;
				}
@Component and further stereotype annotations: @Service, @Repository, @Controller
@Component: is a generic stereotype for any Spring-managed component.
@Repository annotation is a marker for any class that fulfills the role or stereotype of a repository (also known as Data Access Object or DAO). 
	Among the uses of this marker is the automatic translation of exceptions as described in Section 20.2.2, “Exception translation”.
	(unchecked exceptions for @Transactional to rollback the commit)

	
7.10.3 Automatically detecting classes and registering bean definitions
	To autodetect these classes and register the corresponding beans, you need to add @ComponentScan to your @Configuration class, 
	where the basePackages attribute is a common parent package for the two classes. 
	If basePackages is not specified on the @ComponentScan, then the package of the class it is applied on gets used.
	
7.10.4 Using filters to customize scanning

7.10.5 Defining metadata
	@Bean, @Lazy, @Qualifier, @Scope can be used together

	@Service("myMovieLister")
	public class SimpleMovieLister - bean's name is "myMovieLister"

	@Repository
	public class MovieFinderImpl - bean's name is "movieFinderImpl"


7.11 Using JSR 330 Standard Annotations
	@Inject vs @Autowired
	@Named vs @Component - the two are identical
	
	
7.11.3 Limitations of JSR-330 standard annotations

7.12 Java-based container configuration
	The central artifacts in Spring’s new Java-configuration support are @Configuration-annotated classes and @Bean-annotated methods.
	
	@Bean - method-level annotation and is used to indicate that a method instantiates, configures and initializes a new object 
			to be managed by the Spring IoC container.
	@Bean(initMethod = "init")
	@Bean(destroyMethod = "cleanup")
	@Configuration - indicates that its primary purpose is as a source of bean definitions. 
					 Furthermore, @Configuration classes allow inter-bean dependencies to be defined by simply calling other 
					 @Bean methods in the same class. 
					 
		
	Full @Configuration vs 'lite' @Beans mode?
	When @Bean methods are declared within classes that are not annotated with @Configuration they are referred to as being processed in a 'lite' mode.
	For example, bean methods declared in a @Component or even in a plain old class will be considered 'lite'.
	Unlike full @Configuration, lite @Bean methods cannot easily declare inter-bean dependencies. 
	Usually one @Bean method should not invoke another @Bean method when operating in 'lite' mode.
	Only using @Bean methods within @Configuration classes is a recommended approach of ensuring that 'full' mode is always used. 
	This will prevent the same @Bean method from accidentally being invoked multiple times and helps to reduce subtle bugs that can be hard 
	to track down when operating in 'lite' mode.

	@Import - annotation allows for loading @Bean definitions from another configuration class
	
Conditionally include @Configuration classes or @Bean methods
	It is often useful to conditionally enable or disable a complete @Configuration class, or even individual @Bean methods, 
	based on some arbitrary system state.
	
	@Profile - activate beans only when a specific profile has been enabled in the Spring Environment
		spring.profiles=dev,prod
		spring.profiles.active=dev
	@Conditional
	
	
Configuration injection

	@Configuration
	@ConfigurationProperties(prefix = "spring.dsMsSQL")
	public class MsSQLDataSourceConfiguration extends DatabaseConfig {
		// DatabaseConfig's fields are propagated with config properties from application.properties that match the prefix
		// like spring.dsMsSQL.password <--- "password" field gets filled with the value of this
		
		@Bean
		public SqlSessionFactoryBean mssqlSessionFactory() throws SQLException {
			SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();
			factoryBean.setDataSource(mssqlDataSource());
			return factoryBean;
		}
	}

	@Configuration
	@PropertySource("classpath:neo4j.properties")
	public class Neo4jConfig {
		@Autowired
		Environment environment;
	}
	
	@PropertySource - provides a convenient and declarative mechanism for adding a PropertySource to Spring’s Environment
	
	
7.15.1 Internationalization using MessageSource

	MessageSource, HierarchicalMessageSource interfaces
	
	
8.2 The Resource interface

	Spring’s Resource interface is meant to be a more capable interface for abstracting access to low-level resources.
	
	UrlResource: The UrlResource wraps a java.net.URL, and may be used to access any object that is normally accessible via a URL, 
				 such as files, an HTTP target, an FTP target, etc.
	ClassPathResource
	FileSystemResource: his is a Resource implementation for java.io.File handles. It obviously supports resolution as a File, and as a URL.
	ServletContextResource
	InputStreamResource
	ByteArrayResource
	
	ResourceLoader: The ResourceLoader interface is meant to be implemented by objects that can return (i.e. load) Resource instances.
		Resource template = ctx.getResource("classpath:some/resource/path/myTemplate.txt");
		Resource template = ctx.getResource("file:///some/resource/path/myTemplate.txt");
		Resource template = ctx.getResource("http://myhost.com/resource/path/myTemplate.txt");
		
		
9. Validation, Data Binding, and Type Conversion
		
	Spring Framework 4.0 supports Bean Validation 1.0 (JSR-303) and Bean Validation 1.1 (JSR-349) in terms of setup support, 
	also adapting it to Spring’s Validator interface.
	
9.5.1 Converter SPI
	org.springframework.core.convert.converter.Converter interface
	
11. Aspect Oriented Programming with Spring
	Aspect: a modularization of a concern that cuts across multiple classes. Transaction management is a good example of a crosscutting 
			concern in enterprise Java applications. In Spring AOP, aspects are implemented using regular classes 
			(the schema-based approach) or regular classes annotated with the @Aspect annotation (the @AspectJ style).
	Join point: a point during the execution of a program, such as the execution of a method or the handling of an exception. 
			In Spring AOP, a join point always represents a method execution.
	Advice: action taken by an aspect at a particular join point. Different types of advice include "around," "before" and "after" advice.
			(Advice types are discussed below.) Many AOP frameworks, including Spring, model an advice as an interceptor, maintaining a chain 
			of interceptors around the join point.
	Pointcut: a predicate that matches join points. Advice is associated with a pointcut expression and runs at any join point matched by 
			the pointcut (for example, the execution of a method with a certain name). The concept of join points as matched by pointcut 
			expressions is central to AOP, and Spring uses the AspectJ pointcut expression language by default.
	Introduction: declaring additional methods or fields on behalf of a type. Spring AOP allows you to introduce new interfaces 
			(and a corresponding implementation) to any advised object. For example, you could use an introduction to make a bean implement 
			an IsModified interface, to simplify caching. (An introduction is known as an inter-type declaration in the AspectJ community.)
	Target object: object being advised by one or more aspects. Also referred to as the advised object. Since Spring AOP is implemented 
			using runtime proxies, this object will always be a proxied object.
	AOP proxy: an object created by the AOP framework in order to implement the aspect contracts (advise method executions and so on). 
			In the Spring Framework, an AOP proxy will be a JDK dynamic proxy or a CGLIB proxy.
	Weaving: linking aspects with other application types or objects to create an advised object. This can be done at compile time 
			(using the AspectJ compiler, for example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks, 
			performs weaving at runtime.
	
	
	Types of advice:
		Before advice: Advice that executes before a join point, but which does not have the ability to prevent execution 
			flow proceeding to the join point (unless it throws an exception).
		After returning advice: Advice to be executed after a join point completes normally: for example, if a method returns without
			throwing an exception.
		After throwing advice: Advice to be executed if a method exits by throwing an exception.
		After (finally) advice: Advice to be executed regardless of the means by which a join point exits (normal or exceptional return).
		Around advice: Advice that surrounds a join point such as a method invocation. This is the most powerful kind of advice. 
			Around advice can perform custom behavior before and after the method invocation. It is also responsible for choosing 
			whether to proceed to the join point or to shortcut the advised method execution by returning its own return value or 
			throwing an exception.
			
	@Configuration
	@EnableAspectJAutoProxy
	public class AppConfig {
	}
	
	@Aspect
	public class NotVeryUsefulAspect {
	
		@Pointcut("execution(public * *(..))")
		private void anyPublicOperation() {}

		@Pointcut("within(com.xyz.someapp.trading..*)")
		private void inTrading() {}

		@Pointcut("anyPublicOperation() && inTrading()")
		private void tradingOperation() {}
		
		@Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
		public void doAccessCheck() {
		}
		
		@AfterReturning("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
		public void doAccessCheck() {
		}
		
		@AfterReturning(pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()", returning="retVal")
		public void doAccessCheck(Object retVal) {
		}
		
		@AfterThrowing("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
		public void doRecoveryActions() {
		}
	
		@After("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
		public void doReleaseLock() {
		}
	
		@Around("com.xyz.myapp.SystemArchitecture.businessService()")
		public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {
			// start stopwatch
			Object retVal = pjp.proceed();
			// stop stopwatch
			return retVal;
    }
}


Transaction Management

	PlatformTransactionManager: JtaTransactionManager, HibernateTransactionManager
	
17.4.2 Low-level synchronization approach

	DataSourceUtils (for JDBC), EntityManagerFactoryUtils (for JPA), SessionFactoryUtils, PersistenceManagerFactoryUtils (for JDO)
	
	For example, in the case of JDBC, instead of the traditional JDBC approach of calling the getConnection() method on the DataSource, 
	you instead use Spring’s org.springframework.jdbc.datasource.DataSourceUtils class as follows:
		Connection conn = DataSourceUtils.getConnection(dataSource);
		
	@Transactional - declarative transaction support are that this support is enabled via AOP proxies
	
		- Propagation setting is REQUIRED.
		- Isolation level is DEFAULT.
		- Transaction is read/write. - not read-only by default
		- Transaction timeout defaults to the default timeout of the underlying transaction system, or none if timeouts are not supported.
		- Any RuntimeException triggers rollback, and any checked Exception does not.
		
		When using proxies, you should apply the @Transactional annotation only to methods with public visibility. 
		If you do annotate protected, private or package-visible methods with the @Transactional annotation, no error is raised, 
		but the annotated method does not exhibit the configured transactional settings. 
		Consider the use of AspectJ (see below) if you need to annotate non-public methods.
		
		Spring recommends that you only annotate concrete classes (and methods of concrete classes) with the @Transactional annotation, as opposed 
		to annotating interfaces. You certainly can place the @Transactional annotation on an interface (or an interface method), but this works only 
		as you would expect it to if you are using interface-based proxies. The fact that Java annotations are not inherited from interfaces means that
		if you are using class-based proxies ( proxy-target-class="true") or the weaving-based aspect ( mode="aspectj"), then the transaction 
		settings are not recognized by the proxying and weaving infrastructure, and the object will not be wrapped in a transactional proxy, 
		which would be decidedly bad.
		
		In proxy mode (which is the default), only external method calls coming in through the proxy are intercepted. This means that 
		self-invocation, in effect, a method within the target object calling another method of the target object, will not lead to an
		actual transaction at runtime even if the invoked method is marked with @Transactional. Also, the proxy must be fully initialized
		to provide the expected behaviour so you should not rely on this feature in your initialization code, i.e. @PostConstruct.
		
		Consider the use of AspectJ mode (see mode attribute in table below) if you expect self-invocations to be wrapped with transactions
		as well. In this case, there will not be a proxy in the first place; instead, the target class will be weaved (that is, its byte 
		code will be modified) in order to turn @Transactional into runtime behavior on any kind of method.


		If you find you are repeatedly using the same attributes with @Transactional on many different methods, then 
		Spring’s meta-annotation support allows you to define custom shortcut annotations for your specific use cases. 
		For example, defining the following annotations		
			@Target({ElementType.METHOD, ElementType.TYPE})
			@Retention(RetentionPolicy.RUNTIME)
			@Transactional("account")
			public @interface AccountTx {
			}
			
			
17.5.7 Transaction propagation
	PROPAGATION_REQUIRED: However, in the case where an inner transaction scope sets the rollback-only marker, the outer transaction has not decided on 
		the rollback itself, and so the rollback (silently triggered by the inner transaction scope) is unexpected. 
		A corresponding UnexpectedRollbackException is thrown at that point. 
	PROPAGATION_REQUIRES_NEW: uses a completely independent transaction for each affected transaction scope. In that case, the underlying 
		physical transactions are different and hence can commit or roll back independently, with an outer transaction not affected by an 
		inner transaction’s rollback status.
	PROPAGATION_NESTED : uses a single physical transaction with multiple savepoints that it can roll back to. Such partial rollbacks 
		allow an inner transaction scope to trigger a rollback for its scope, with the outer transaction being able to continue the physical 
		transaction despite some operations having been rolled back. This setting is typically mapped onto JDBC savepoints, so will only work 
		with JDBC resource transactions. See Spring’s DataSourceTransactionManager.
			
			
17.6 Programmatic transaction management

	Using the TransactionTemplate.
	Using a PlatformTransactionManager implementation directly.
	
18.3 Annotations used for configuring DAO or Repository classes
	@Repository
	Any DAO or repository implementation will need to access to a persistence resource, depending on the persistence technology used; 
	for example, a JDBC-based repository will need access to a JDBC DataSource; a JPA-based repository will need access to an EntityManager. 
	The easiest way to accomplish this is to have this resource dependency injected using one of the
	@Autowired,, @Inject, @Resource or @PersistenceContext annotations. Here is an example for a JPA repository:
	
	@Repository
	public class JpaMovieFinder implements MovieFinder {
    @PersistenceContext
		private EntityManager entityManager;
	}
	
	
DataSource
	DriverManagerDataSource dataSource = new DriverManagerDataSource();
	dataSource.setDriverClassName("org.hsqldb.jdbcDriver");
	dataSource.setUrl("jdbc:hsqldb:hsql://localhost:");
	dataSource.setUsername("sa");
	dataSource.setPassword("");
	
	Only use the DriverManagerDataSource class should only be used for testing purposes since it does not provide pooling and will perform poorly 
	when multiple requests for a connection are made.
	Always use the DataSource provided by the container via JNDI
	

	DataSourceUtils
		The DataSourceUtils class is a convenient and powerful helper class that provides static methods to obtain connections from JNDI 
		and close connections if necessary. It supports thread-bound connections with, for example, DataSourceTransactionManager.
	
	
	JPA: 3 ways to set up JPA with spring: LocalEntityManagerFactoryBean, EntityManagerFactory from JNDI, LocalContainerEntityManagerFactoryBean
		Use this latter option for full JPA capabilities in a Spring-based application environment. 
	
	
21.2 Marshaller and Unmarshaller
	As stated in the introduction, a marshaller serializes an object to XML, and an unmarshaller deserializes XML stream to an object. 
	In this section, we will describe the two Spring interfaces used for this purpose.
	

********************************
Spring MVC:
********************************

	It looks like the 1st folder inside the src/main/resources gets served automatically. 
	However with @RequestMapping and viewtechnology (like thymeleaf) used together it is possible to manipulate which html gets sent for which request.
	For example: localhost:8080/index.html and localhost:8080 can return the same content!

	The WebMvcConfigurerAdapter is for configuring Spring MVC, the replacement of the xml file loaded by the 
		DispatcherServlet for configuring Spring MVC. The WebMvcConfigurerAdapter should be used for a @Configuration class.
		@EnableWebMvc //<mvc:annotation-driven />
		@Configuration
		@ComponentScan({ "com.mkyong.helloworld.web" })
		public class SpringWebConfig extends WebMvcConfigurerAdapter

	ServletInitializer: necessary in order for Spring to generate web.xml (project is dynamic webproject and packaging is war - app is deployed to an existing servlet container)
						Without this the war is either not generated or doesn’t work at all (not sure what Gabor said)
						however probably this can be omitted by using "AbstractAnnotationConfigDispatcherServletInitializer" as demonstrated above

	AbstractAnnotationConfigDispatcherServletInitializer (ServletInitializer) is the replacement of web.xml. Initializes the servlet container.
	public class MyWebInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

		@Override
		protected Class<?>[] getRootConfigClasses() {
			return new Class[] { SpringRootConfig.class };
		}

		@Override
		protected Class<?>[] getServletConfigClasses() {
			return new Class[] { SpringWebConfig.class };
		}

		@Override
		protected String[] getServletMappings() {
			return new String[] { "/" };
		}
	}


	WebDataBinder binds custom validators.
	To do this, we create a method in controller and annotate it with @InitBinder which plays the role to identify WebDataBinder method in our controller.


	Controller:

	// this is used to add stuff to spring's model and it ultimately goes into the HttpServletRequest object after the handler executes
	@ModelAttribute("myRequestObject")
	public MyCommandBean addStuffToRequestScope() {
		System.out.println("Inside of addStuffToRequestScope");
		MyCommandBean bean = new MyCommandBean("Hello World",42);
		return bean;
	}
		
		@ModelAttribute refers to a property of the Model object (the M in MVC ;) so let's say we have a form with a form backing object that is called "Person" 
		Then you can have Spring MVC supply this object to a Controller method by using the @ModelAttribute annotation:

		public String processForm(@ModelAttribute("person") Person person){
			person.getStuff();
		}
		Check here for an example (Spring 2.5), also see "Using @ModelAttribute on a method argument" (Spring 3.1).

		On the other hand the annotation is used to define objects which should be part of a Model. So if you want to have a Person object referenced in the Model you can use the following method:
		@ModelAttribute("person")
		public Person getPerson(){
			return new Person();
		}

	@Valid asks spring to validate the associated object(Employee). 
	BindingResult contains the outcome of this validation and any error that might have occurred during this validation. 
	Notice that BindingResult must come right after the validated object else spring won’t be able to validate and an exception been thrown.
	Custom errors can be added to the BindingResult: bindingResult.addError(new FieldError(...));		


22. Web MVC framework

	The Spring Web model-view-controller (MVC) framework is designed around a DispatcherServlet that dispatches requests to handlers, 
	with configurable handler mappings, view resolution, locale, time zone and theme resolution as well as support for uploading files.
	
	Spring’s view resolution is extremely flexible. A Controller is typically responsible for preparing a model Map with data 
	and selecting a view name but it can also write directly to the response stream and complete the request. @Controller, @ResponseBody or just @Restcontroller
	
	View name resolution is highly configurable through file extension or Accept header content type negotiation, through bean names, 
	a properties file, or even a custom ViewResolver implementation. The model (the M in MVC) is a Map interface, which allows for 
	the complete abstraction of the view technology. You can integrate directly with template based rendering technologies such as JSP, 
	Velocity and Freemarker, or directly generate XML, JSON, Atom, and many other types of content. The model Map is simply transformed 
	into an appropriate format, such as JSP request attributes, a Velocity template model.
	
	
DispatcherServlet
	Spring’s web MVC framework is, like many other web MVC frameworks, request-driven, designed around a central Servlet that 
	dispatches requests to controllers and offers other functionality that facilitates the development of web applications. 
	Spring’s DispatcherServlet however, does more than just that. It is completely integrated with the Spring IoC container and as 
	such allows you to use every other feature that Spring has.
	
	The DispatcherServlet is an actual Servlet (it inherits from the HttpServlet base class), and as such is declared in your web application. 
	You need to map requests that you want the DispatcherServlet to handle, by using a URL mapping. Here is a standard Java EE Servlet 
	configuration in a Servlet 3.0+ environment
	
	public class MyWebApplicationInitializer implements WebApplicationInitializer {
		@Override
		public void onStartup(ServletContext container) {
			ServletRegistration.Dynamic registration = container.addServlet("dispatcher", new DispatcherServlet());
			registration.setLoadOnStartup(1);
			registration.addMapping("/example/*");
		}
	}
	
	WebApplicationInitializer is an interface provided by Spring MVC that ensures your code-based configuration is detected and automatically 
	used to initialize any Servlet 3 container.
	
	As detailed in Section 7.15, “Additional Capabilities of the ApplicationContext”, ApplicationContext instances in Spring can be scoped.
	n the Web MVC framework, each DispatcherServlet has its own WebApplicationContext, which inherits all the beans already defined in the root
	WebApplicationContext. The root WebApplicationContext should contain all the infrastructure beans that should be shared 
	between your other contexts and Servlet instances. These inherited beans can be overridden in the servlet-specific scope, and 
	you can define new scope-specific beans local to a given Servlet instance.
	
	
	Upon initialization of a DispatcherServlet, Spring MVC looks for a file named [servlet-name]-servlet.xml in the WEB-INF directory 
	of your web application and creates the beans defined there, overriding the definitions of any beans defined with the same name in the
	global scope.
	Consider the following DispatcherServlet Servlet configuration (in the web.xml file):
	<web-app>
		<servlet>
			<servlet-name>golfing</servlet-name>
			<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
			<load-on-startup>1</load-on-startup>
		</servlet>
		<servlet-mapping>
			<servlet-name>golfing</servlet-name>
			<url-pattern>/golfing/*</url-pattern>
		</servlet-mapping>
	</web-app>
	With the above Servlet configuration in place, you will need to have a file called /WEB-INF/golfing-servlet.xml in your application; 
	this file will contain all of your Spring Web MVC-specific components (beans).
	
	
	It is also possible to have just one root context for single DispatcherServlet scenarios.
	<web-app>
		<context-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>/WEB-INF/root-context.xml</param-value>
		</context-param>
		<servlet>
			<servlet-name>dispatcher</servlet-name>
			<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
			<init-param>
				<param-name>contextConfigLocation</param-name>
				<param-value></param-value>
			</init-param>
			<load-on-startup>1</load-on-startup>
		</servlet>
		<servlet-mapping>
			<servlet-name>dispatcher</servlet-name>
			<url-pattern>/*</url-pattern>
		</servlet-mapping>
		<listener>
			<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
		</listener>
	</web-app>
	
	
	
	
	Instead of xml this can be achieved by using java-based configurations:
	public class GolfingWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
		@Override
		protected Class<?>[] getRootConfigClasses() {
			// GolfingAppConfig defines beans that would be in root-context.xml
			return new Class[] { GolfingAppConfig.class };
		}
		@Override
		protected Class<?>[] getServletConfigClasses() {
			// GolfingWebConfig defines beans that would be in golfing-servlet.xml
			return new Class[] { GolfingWebConfig.class };
		}
		@Override
		protected String[] getServletMappings() {
			return new String[] { "/golfing/*" };
		}
	}
	
22.1. Special bean types in the WebApplicationContext
	
	HandlerMapping
	ViewResolver - Resolves logical String-based view names to actual View types.
	LocaleResolver & LocaleContextResolver - Resolves the locale a client is using and possibly their time zone, in order to be able to offer internationalized views
	MultipartResolver - Parses multi-part requests for example to support processing file uploads from HTML forms.
	FlashMapManager - Stores and retrieves the "input" and the "output" FlashMap that can be used to pass attributes from one request to another, usually across a redirect.
	
	
22.3.2 Mapping Requests With @RequestMapping
	@GetMapping("/owners/{ownerId}")
	public String findOwner(@PathVariable String ownerId, Model model) {	
	
	/owners/*/pets/{petId})
	
	When a URL matches multiple patterns, a sort is used to find the most specific match.
		If two patterns have the same count, the one that is longer is considered more specific. For example /foo/bar* is longer and considered more specific than /foo/*.
		The default mapping pattern /** is less specific than any other pattern. For example /api/{a}/{b}/{c} is more specific
		
	Path Patterns with Placeholders

	Patterns in @RequestMapping annotations support ${…​} placeholders against local properties and/or system properties and 
		variables. This may be useful in cases where the path a controller is mapped to may need to be customized through configuration. 
		For more information on placeholders, see the javadocs of the PropertyPlaceholderConfigurer class.
 
	By default Spring MVC performs ".*" suffix pattern matching so that a controller mapped to /person is also implicitly mapped to /person.*. 
		This makes it easy to request different representations of a resource through the URL path (e.g. /person.pdf, /person.xml).


Matrix variables
			// GET /pets/42;q=11;r=22
			@GetMapping("/pets/{petId}")
			public void findPet(@PathVariable String petId, @MatrixVariable int q) {
				// petId == 42
				// q == 11
			}
			
			// GET /owners/42;q=11/pets/21;q=22
			@GetMapping("/owners/{ownerId}/pets/{petId}")
			public void findPet(
					@MatrixVariable(name="q", pathVar="ownerId") int q1,
					@MatrixVariable(name="q", pathVar="petId") int q2) {
				// q1 == 11
				// q2 == 22
			}
			
Consumable Media Types
	@PostMapping(path = "/pets", consumes = "application/json")
	
Producible Media Types
	@GetMapping(path = "/pets/{petId}", produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
	
Request Parameters and Header Values
	You can narrow request matching through request parameter conditions such as "myParam", "!myParam", or "myParam=myValue". 
	The first two test for request parameter presence/absence and the third for a specific parameter value.
	Here is an example with a request parameter value condition:
	
	@GetMapping(path = "/pets/{petId}", params = "myParam=myValue")
    public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) {
	
	@GetMapping
    public String setupForm(@RequestParam("petId") int petId, ModelMap model) {
	When an @RequestParam annotation is used on a Map<String, String> or MultiValueMap<String, String> argument, the map is populated with all request parameters.
	
	@PutMapping("/something")
	public void handle(@RequestBody String body, Writer writer) throws IOException {
	
	The @ResponseBody annotation is similar to @RequestBody. This annotation can be placed on a method and indicates that the return 
		type should be written straight to the HTTP response body (and not placed in a Model, or interpreted as a view name). For example:
	@GetMapping("/something")
	@ResponseBody
	public String helloWorld() {
		return "Hello World";
	}
	
	@RequestMapping("/something")
	public ResponseEntity<String> handle(HttpEntity<byte[]> requestEntity) throws UnsupportedEncodingException {
		String requestHeader = requestEntity.getHeaders().getFirst("MyRequestHeader"));
		byte[] requestBody = requestEntity.getBody();

		// do something with request header and body

		HttpHeaders responseHeaders = new HttpHeaders();
		responseHeaders.set("MyResponseHeader", "MyValue");
		return new ResponseEntity<String>("Hello World", responseHeaders, HttpStatus.CREATED);
	}
	

Supported method argument types
	Request or response objects (Servlet API). Choose any specific request or response type, for example ServletRequest or HttpServletRequest.
	Session object (Servlet API): of type HttpSession.
	org.springframework.web.context.request.WebRequest or org.springframework.web.context.request.NativeWebRequest. Allows for generic request parameter access as well as request/session attribute access, without ties to the native Servlet/Portlet API.
	java.util.Locale for the current request locale, determined by the most specific locale resolver available, in effect, the configured LocaleResolver / LocaleContextResolver in an MVC environment.
	java.util.TimeZone (Java 6+) / java.time.ZoneId (on Java 8) for the time zone associated with the current request, as determined by a LocaleContextResolver.
	java.io.InputStream / java.io.Reader for access to the request’s content. This value is the raw InputStream/Reader as exposed by the Servlet API.
	java.io.OutputStream / java.io.Writer for generating the response’s content. This value is the raw OutputStream/Writer as exposed by the Servlet API.
	org.springframework.http.HttpMethod for the HTTP request method.
	java.security.Principal containing the currently authenticated user.
	@PathVariable annotated parameters for access to URI template variables. See the section called “URI Template Patterns”.
	@MatrixVariable annotated parameters for access to name-value pairs located in URI path segments. See the section called “Matrix Variables”.
	@RequestParam annotated parameters for access to specific Servlet request parameters. Parameter values are converted to the declared method argument type. See the section called “Binding request parameters to method parameters with @RequestParam”.
	@RequestHeader annotated parameters for access to specific Servlet request HTTP headers. Parameter values are converted to the declared method argument type. See the section called “Mapping request header attributes with the @RequestHeader annotation”.
	@RequestBody annotated parameters for access to the HTTP request body. Parameter values are converted to the declared method argument type using HttpMessageConverters. See the section called “Mapping the request body with the @RequestBody annotation”.
	@RequestPart annotated parameters for access to the content of a "multipart/form-data" request part. See Section 22.10.5, “Handling a file upload request from programmatic clients” and Section 22.10, “Spring’s multipart (file upload) support”.
	@SessionAttribute annotated parameters for access to existing, permanent session attributes (e.g. user authentication object) as opposed to model attributes temporarily stored in the session as part of a controller workflow via @SessionAttributes.
	@RequestAttribute annotated parameters for access to request attributes.
	HttpEntity<?> parameters for access to the Servlet request HTTP headers and contents. The request stream will be converted to the entity body using HttpMessageConverters. See the section called “Using HttpEntity”.
	java.util.Map / org.springframework.ui.Model / org.springframework.ui.ModelMap for enriching the implicit model that is exposed to the web view.
	org.springframework.web.servlet.mvc.support.RedirectAttributes to specify the exact set of attributes to use in case of a redirect and also to add flash attributes (attributes stored temporarily on the server-side to make them available to the request after the redirect). See the section called “Passing Data To the Redirect Target” and Section 22.6, “Using flash attributes”.
	Command or form objects to bind request parameters to bean properties (via setters) or directly to fields, with customizable type conversion, depending on @InitBinder methods and/or the HandlerAdapter configuration. See the webBindingInitializer property on RequestMappingHandlerAdapter. Such command objects along with their validation results will be exposed as model attributes by default, using the command class name - e.g. model attribute "orderAddress" for a command object of type "some.package.OrderAddress". The ModelAttribute annotation can be used on a method argument to customize the model attribute name used.
	org.springframework.validation.Errors / org.springframework.validation.BindingResult validation results for a preceding command or form object (the immediately preceding method argument).
	org.springframework.web.bind.support.SessionStatus status handle for marking form processing as complete, which triggers the cleanup of session attributes that have been indicated by the @SessionAttributes annotation at the handler type level.
	org.springframework.web.util.UriComponentsBuilder a builder for preparing a URL relative to the current request’s host, port, scheme, context path, and the literal part of the servlet mapping.
	
Supported method return types
	A ModelAndView object, with the model implicitly enriched with command objects and the results of @ModelAttribute annotated reference data accessor methods.
	A Model object, with the view name implicitly determined through a RequestToViewNameTranslator and the model implicitly enriched with command objects and the results of @ModelAttribute annotated reference data accessor methods.
	A Map object for exposing a model, with the view name implicitly determined through a RequestToViewNameTranslator and the model implicitly enriched with command objects and the results of @ModelAttribute annotated reference data accessor methods.
	A View object, with the model implicitly determined through command objects and @ModelAttribute annotated reference data accessor methods. The handler method may also programmatically enrich the model by declaring a Model argument (see above).
	A String value that is interpreted as the logical view name, with the model implicitly determined through command objects and @ModelAttribute annotated reference data accessor methods. The handler method may also programmatically enrich the model by declaring a Model argument (see above).
	void if the method handles the response itself (by writing the response content directly, declaring an argument of type ServletResponse / HttpServletResponse for that purpose) or if the view name is supposed to be implicitly determined through a RequestToViewNameTranslator (not declaring a response argument in the handler method signature).
	If the method is annotated with @ResponseBody, the return type is written to the response HTTP body. The return value will be converted to the declared method argument type using HttpMessageConverters. See the section called “Mapping the response body with the @ResponseBody annotation”.
	An HttpEntity<?> or ResponseEntity<?> object to provide access to the Servlet response HTTP headers and contents. The entity body will be converted to the response stream using HttpMessageConverters. See the section called “Using HttpEntity”.
	An HttpHeaders object to return a response with no body.
	A Callable<?> can be returned when the application wants to produce the return value asynchronously in a thread managed by Spring MVC.
	A DeferredResult<?> can be returned when the application wants to produce the return value from a thread of its own choosing.
	A ListenableFuture<?> can be returned when the application wants to produce the return value from a thread of its own choosing.
	A ResponseBodyEmitter can be returned to write multiple objects to the response asynchronously; also supported as the body within a ResponseEntity.
	An SseEmitter can be returned to write Server-Sent Events to the response asynchronously; also supported as the body within a ResponseEntity.
	A StreamingResponseBody can be returned to write to the response OutputStream asynchronously; also supported as the body within a ResponseEntity.
	Any other return type is considered to be a single model attribute to be exposed to the view, using the attribute name specified through @ModelAttribute at the method level (or the default attribute name based on the return type class name). The model is implicitly enriched with command objects and the results of @ModelAttribute annotated reference data accessor methods.	
	

Using @ModelAttribute on a method

The @ModelAttribute annotation can be used on methods or on method arguments. 
	This section explains its usage on methods while the next section explains its usage on method arguments.
	
	// Add one attribute
	// The return value of the method is added to the model under the name "account"
	// You can customize the name via @ModelAttribute("myAccount")

	@ModelAttribute
	public Account addAccount(@RequestParam String number) {
		return accountManager.findAccount(number);
	}

	// Add multiple attributes

	@ModelAttribute
	public void populateModel(@RequestParam String number, Model model) {
		model.addAttribute(accountManager.findAccount(number));
		// add more ...
	}
	@ModelAttribute methods are used to populate the model with commonly needed attributes for example to fill a drop-down with 
	states or with pet types, or to retrieve a command object like Account in order to use it to represent the data on an HTML form. 
	The latter case is further discussed in the next section.
	A controller can have any number of @ModelAttribute methods. All such methods are invoked before @RequestMapping methods of the same controller.
	
	Using @ModelAttribute on a method argument
	
		PostMapping("/owners/{ownerId}/pets/{petId}/edit")
		public String processSubmit(@ModelAttribute Pet pet) { }
		
		An @ModelAttribute on a method argument indicates the argument should be retrieved from the model. 
		If not present in the model, the argument should be instantiated first and then added to the model. 
		Once present in the model, the argument’s fields should be populated from all request parameters that have matching names. 
		This is known as data binding in Spring MVC, a very useful mechanism that saves you from having to parse each form field individually.
	
	
	Note that in some cases it may be useful to gain access to an attribute in the model without data binding. 
	For such cases you may inject the Model into the controller or alternatively use the binding flag on the annotation:
		@ModelAttribute
		public AccountForm setUpForm() {
			return new AccountForm();
		}
		
		@ModelAttribute
		public Account findAccount(@PathVariable String accountId) {
			return accountRepository.findOne(accountId);
		}

		@PostMapping("update")
		public String update(@Valid AccountUpdateForm form, BindingResult result,
				@ModelAttribute(binding=false) Account account) {

			// ...
		}
	
	n addition to data binding you can also invoke validation using your own custom validator passing the same BindingResult that was used to 
	record data binding errors. That allows for data binding and validation errors to be accumulated in one place and subsequently reported back 
	to the user:
		@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
		public String processSubmit(@ModelAttribute("pet") Pet pet, BindingResult result) {

			new PetValidator().validate(pet, result);
			if (result.hasErrors()) {
				return "petForm";
			}
			// ...
		}
		
		Or you can have validation invoked automatically by adding the JSR-303 @Valid annotation:
		@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
		public String processSubmit(@Valid @ModelAttribute("pet") Pet pet, BindingResult result) {
			if (result.hasErrors()) {
				return "petForm";
			}
			// ...
		}
	
Using @SessionAttributes to store model attributes in the HTTP session between requests
	The type-level @SessionAttributes annotation declares session attributes used by a specific handler. 
	This will typically list the names of model attributes or types of model attributes which should be transparently 
	stored in the session or some conversational storage, serving as form-backing beans between subsequent requests.
	@Controller
	@RequestMapping("/editPet.do")
	@SessionAttributes("pet")
	public class EditPetForm {
		// ...
	}
	
Using @SessionAttribute to access pre-existing global session attributes
	@RequestMapping("/")
	public String handle(@SessionAttribute User user) {
		// ...
	}
	
Using @RequestAttribute to access request attributes

Similar to @SessionAttribute the @RequestAttribute annotation can be used to access pre-existing request attributes created by a filter 
	or interceptor:
	@RequestMapping("/")
	public String handle(@RequestAttribute Client client) {
		// ...
	}
	
	
	@CookieValue annotation allows a method parameter to be bound to the value of an HTTP cookie.
		@RequestMapping("/displayHeaderInfo.do")
		public void displayHeaderInfo(@CookieValue("JSESSIONID") String cookie) {
		
	@RequestHeader annotation allows a method parameter to be bound to a request header.
		@RequestMapping("/displayHeaderInfo.do")
		public void displayHeaderInfo(@RequestHeader("Accept-Encoding") String encoding, @RequestHeader("Keep-Alive") long keepAlive) {
		
	@InitBinder - allows you to configure web data binding directly within your controller class
		The following example demonstrates the use of @InitBinder to configure a CustomDateEditor for all java.util.Date form properties.
		@Controller
		public class MyFormController {

			@InitBinder
			protected void initBinder(WebDataBinder binder) {
				SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
				dateFormat.setLenient(false);
				binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
			}

			// ...
		}

Advising controllers with @ControllerAdvice and @RestControllerAdvice

	@ControllerAdvice annotation is a component annotation allowing implementation classes to be auto-detected through classpath scanning. 
	It is automatically enabled when using the MVC namespace or the MVC Java config.
	
	Classes annotated with @ControllerAdvice can contain @ExceptionHandler, @InitBinder, and @ModelAttribute annotated methods, 
	and these methods will apply to @RequestMapping methods across all controller hierarchies as opposed to the controller hierarchy within which they are declared.
	@RestControllerAdvice is an alternative where @ExceptionHandler methods assume @ResponseBody semantics by default.
	Both @ControllerAdvice and @RestControllerAdvice can target a subset of controllers:
	
	// Target all Controllers annotated with @RestController
	@ControllerAdvice(annotations = RestController.class)
	public class AnnotationAdvice {}

	// Target all Controllers within specific packages
	@ControllerAdvice("org.example.controllers")
	public class BasePackageAdvice {}

	// Target all Controllers assignable to specific classes
	@ControllerAdvice(assignableTypes = {ControllerInterface.class, AbstractController.class})
	public class AssignableTypesAdvice {}
	
	
22.3.4 Asynchronous Request Processing
	Spring MVC 3.2 introduced Servlet 3 based asynchronous request processing. 
	Instead of returning a value, as usual, a controller method can now return a java.util.concurrent.Callable and produce the return value 
	from a Spring MVC managed thread. 
	
	@PostMapping
	public Callable<String> processUpload(final MultipartFile file) {
	
	
	Another option is for the controller method to return an instance of DeferredResult. In this case the return value will also be produced
	from any thread, i.e. one that is not managed by Spring MVC. For example the result may be produced in response to some external event
	such as a JMS message, a scheduled task, and so on. Here is an example of such a controller method:
	
		@RequestMapping("/quotes")
		@ResponseBody
		public DeferredResult<String> quotes() {
			DeferredResult<String> deferredResult = new DeferredResult<String>();
			// Save the deferredResult somewhere..
			return deferredResult;
		}

		// In some other thread...
		deferredResult.setResult(data);
		
		
	With the above in mind, the following is the sequence of events for async request processing with a Callable:
		Controller returns a Callable.
		Spring MVC starts asynchronous processing and submits the Callable to a TaskExecutor for processing in a separate thread.
		The DispatcherServlet and all Filter’s exit the Servlet container thread but the response remains open.
		The Callable produces a result and Spring MVC dispatches the request back to the Servlet container to resume processing.
		The DispatcherServlet is invoked again and processing resumes with the asynchronously produced result from the Callable.
		
	The sequence for DeferredResult is very similar except it’s up to the application to produce the asynchronous result from any thread:
		Controller returns a DeferredResult and saves it in some in-memory queue or list where it can be accessed.
		Spring MVC starts async processing.
		The DispatcherServlet and all configured Filter’s exit the request processing thread but the response remains open.
		The application sets the DeferredResult from some thread and Spring MVC dispatches the request back to the Servlet container.
		The DispatcherServlet is invoked again and processing resumes with the asynchronously produced result.
		- But since the Thread is not Spring managed, all thread-context is lost, right? E.g current user, Locale, etc.
		
		
HTTP Streaming
	What if you wanted to push multiple events on a single HTTP response? This is a technique related to "Long Polling" that is 
	known as "HTTP Streaming". Spring MVC makes this possible through the ResponseBodyEmitter return value type which can be used to 
	send multiple Objects, instead of one as is normally the case with @ResponseBody, where each Object sent is written to the response 
	with an HttpMessageConverter.
	
	
	@RequestMapping("/events")
	public ResponseBodyEmitter handle() {
		ResponseBodyEmitter emitter = new ResponseBodyEmitter();
		// Save the emitter somewhere..
		return emitter;
	}
	// In some other thread
	emitter.send("Hello once");

	// and again later on
	emitter.send("Hello again");

	// and done at some point
	emitter.complete();
	
	
HTTP Streaming Directly To The OutputStream
	ResponseBodyEmitter allows sending events by writing Objects to the response through an HttpMessageConverter. 
	This is probably the most common case, for example when writing JSON data. However sometimes it is useful to bypass message 
	conversion and write directly to the response OutputStream for example for a file download. 
	This can be done with the help of the StreamingResponseBody return value type.
	
	@RequestMapping("/download")
	public StreamingResponseBody handle() {
		return new StreamingResponseBody() {
			@Override
			public void writeTo(OutputStream outputStream) throws IOException {
				// write...
			}
		};
	}
	
22.4.1 Intercepting requests with a HandlerInterceptor
	nterceptors located in the handler mapping must implement HandlerInterceptor from the org.springframework.web.servlet package. 
	This interface defines three methods: preHandle(..) is called before the actual handler is executed; postHandle(..) is called after 
	the handler is executed; and afterCompletion(..) is called after the complete request has finished.
	
22.6 Using flash attributes - this is like TempData in .NET
	Flash attributes provide a way for one request to store attributes intended for use in another. 
	This is most commonly needed when redirecting — for example, the Post/Redirect/Get pattern. 
	Flash attributes are saved temporarily before the redirect (typically in the session) to be made 
	available to the request after the redirect and removed immediately.
	
22.8 Using locales
	Most parts of Spring’s architecture support internationalization, just as the Spring web MVC framework does.
	DispatcherServlet enables you to automatically resolve messages using the client’s locale. This is done with LocaleResolver objects.
	
	AcceptHeaderLocaleResolver, CookieLocaleResolver, SessionLocaleResolver, LocaleChangeInterceptor
	
22.10 Spring’s multipart (file upload) support - this is enabled by default with Spring boot

	 @PostMapping("/form")
    public String handleFormUpload(@RequestParam("name") String name, @RequestParam("file") MultipartFile file) {
	
22.11 Handling exceptions
	HandlerExceptionResolver, @ExceptionHandler
	
	@ControllerAdvice or @Controller
	public class SimpleController {

		// @RequestMapping methods omitted ...

		@ExceptionHandler(IOException.class)
		public ResponseEntity<String> handleIOException(IOException ex) {
			// prepare responseEntity
			return responseEntity;
		}
	}
	
	A business exception can be annotated with @ResponseStatus. When the exception is raised, the ResponseStatusExceptionResolver 
	handles it by setting the status of the response accordingly. 
	
22.14 HTTP caching support
		@Configuration
		@EnableWebMvc
		public class WebConfig extends WebMvcConfigurerAdapter {

			@Override
			public void addResourceHandlers(ResourceHandlerRegistry registry) {
				registry.addResourceHandler("/resources/**")
						.addResourceLocations("/public-resources/")
						.setCacheControl(CacheControl.maxAge(1, TimeUnit.HOURS).cachePublic());
			}

		}
		
22.15 Code-based Servlet container initialization
	public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
		@Override
		protected Class<?>[] getRootConfigClasses() {
			return null;
		}
		@Override
		protected Class<?>[] getServletConfigClasses() {
			return new Class[] { MyWebConfig.class };
		}
		@Override
		protected String[] getServletMappings() {
			return new String[] { "/" };
		}
	}
	
22.16.1 Enabling the MVC Java Config or the MVC XML Namespace
	@Configuration
	@EnableWebMvc
	public class WebConfig extends WebMvcConfigurerAdapter {
		// Override configuration methods..
		@Override
		public void addFormatters(FormatterRegistry registry) {
			// Add formatters and/or converters
		}
	}
	
22.16.4 Validation

	Spring provides a Validator interface that can be used for validation in all layers of an application. 
	In Spring MVC you can configure it for use as a global Validator instance, to be used whenever an @Valid or @Validated 
	controller method argument is encountered, and/or as a local Validator within a controller through an @InitBinder method. 
	Global and local validator instances can be combined to provide composite validation.
	
	Alternatively you can configure your own global Validator instance:
	@Configuration
	@EnableWebMvc
	public class WebConfig extends WebMvcConfigurerAdapter {
		@Override
		public Validator getValidator(); {
			// return "global" validator
		}
	}
	
	To combine global with local validation, simply add one or more local validator(s):
	@Controller
	public class MyController {
		@InitBinder
		protected void initBinder(WebDataBinder binder) {
			binder.addValidators(new FooValidator());
		}
	}
	
I22.16.5 Interceptors

	@Configuration
	@EnableWebMvc
	public class WebConfig extends WebMvcConfigurerAdapter {

		@Override
		public void addInterceptors(InterceptorRegistry registry) {
			registry.addInterceptor(new LocaleInterceptor());
			registry.addInterceptor(new ThemeInterceptor()).addPathPatterns("/**").excludePathPatterns("/admin/**");
			registry.addInterceptor(new SecurityInterceptor()).addPathPatterns("/secure/*");
		}
		
    	@Override
		public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
			configurer.mediaType("json", MediaType.APPLICATION_JSON);
		}
		
		@Override
		public void addViewControllers(ViewControllerRegistry registry) {
			registry.addViewController("/").setViewName("home");
		}
		
		@Override
		public void configureViewResolvers(ViewResolverRegistry registry) {
			registry.enableContentNegotiation(new MappingJackson2JsonView());
			registry.freeMarker().cache(false);
		}

		@Bean
		public FreeMarkerConfigurer freeMarkerConfigurer() {
			FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
			configurer.setTemplateLoaderPath("/WEB-INF/");
			return configurer;
		}
		
		// 22.16.9 Serving of Resources
   	    @Override
		public void addResourceHandlers(ResourceHandlerRegistry registry) {
			registry.addResourceHandler("/resources/**").addResourceLocations("/public-resources/");
		}
		
		// 22.16.12 Message Converters
	    @Override
		public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
			Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder()
					.indentOutput(true)
					.dateFormat(new SimpleDateFormat("yyyy-MM-dd"))
					.modulesToInstall(new ParameterNamesModule());
			converters.add(new MappingJackson2HttpMessageConverter(builder.build()));
			converters.add(new MappingJackson2XmlHttpMessageConverter(builder.xml().build()));
		}
	}
	
23.10 Document views (PDF/Excel)

	Returning an HTML page isn’t always the best way for the user to view the model output, and Spring makes it simple to generate a PDF document or an 
	Excel spreadsheet dynamically from the model data. The document is the view and will be streamed from the server with the correct content type to 
	In order to use Excel views, you need to add the 'poi' library to your classpath, and for PDF generation, the iText library.
	(hopefully) enable the client PC to run their spreadsheet or PDF viewer application in response.
	
26. WebSocket Support
	This part of the reference documentation covers Spring Framework’s support for WebSocket-style messaging in web applications including use of 
	STOMP as an application level WebSocket sub-protocol.
	
26.1.2 A Messaging Architecture
	Today REST is a widely accepted, understood, and supported architecture for building web applications. It is an architecture that relies on having many 
	URLs (nouns), a handful of HTTP methods (verbs), and other principles such as using hypermedia (links), remaining stateless, etc.

	By contrast a WebSocket application may use a single URL only for the initial HTTP handshake. All messages thereafter share and flow on the same TCP connection. 
	This points to an entirely different, asynchronous, event-driven, messaging architecture. One that is much closer to traditional
	messaging applications (e.g. JMS, AMQP).

	Spring Framework 4 includes a new spring-messaging module with key abstractions from the Spring Integration project such as Message, MessageChannel, MessageHandler,
	and others that can serve as a foundation for such a messaging architecture. The module also includes a set of annotations for mapping messages to methods,
	similar to the Spring MVC annotation based programming model.
	
	
27. CORS Support

	You can add an @CrossOrigin annotation to your @RequestMapping annotated handler method in order to enable CORS on it. 
	By default @CrossOrigin allows all origins and the HTTP methods specified in the @RequestMapping annotation:
	
	@RestController
	@RequestMapping("/account")
	public class AccountController {
		@CrossOrigin
		@RequestMapping("/{id}")
		public Account retrieve(@PathVariable Long id) {
			// ...
		}
	}
	
	It is also possible to enable CORS for the whole controller:
	@CrossOrigin(origins = "http://domain2.com", maxAge = 3600)
	@RestController
	@RequestMapping("/account")
	public class AccountController {
	
	You can even use both controller-level and method-level CORS configurations; Spring will then combine attributes from both annotations to create merged CORS configuration.
	CORS support is enabled for both the retrieve() and the remove() handler methods, and you can also see how you can customize the CORS configuration using @CrossOrigin attributes.
	@CrossOrigin(maxAge = 3600)
	@RestController
	@RequestMapping("/account")
	public class AccountController {

		@CrossOrigin("http://domain2.com")
		@RequestMapping("/{id}")
		public Account retrieve(@PathVariable Long id) {
			// ...
		}

		@RequestMapping(method = RequestMethod.DELETE, path = "/{id}")
		public void remove(@PathVariable Long id) {
			// ...
		}
	}
	
27.3 Global CORS configuration
	@Configuration
	@EnableWebMvc
	public class WebConfig extends WebMvcConfigurerAdapter {

		@Override
		public void addCorsMappings(CorsRegistry registry) {
			registry.addMapping("/api/**")
				.allowedOrigins("http://domain2.com")
				.allowedMethods("PUT", "DELETE")
				.allowedHeaders("header1", "header2", "header3")
				.exposedHeaders("header1", "header2")
				.allowCredentials(false).maxAge(3600);
		}
	}

	
Part VII. Integration

28.5 Web services
	@WebService(serviceName="AccountService")
	public class AccountServiceEndpoint extends SpringBeanAutowiringSupport {

		@Autowired
		private AccountService biz;

		@WebMethod
		public void insertAccount(Account acc) {
			biz.insertAccount(acc);
		}

		@WebMethod
		public Account[] getAccounts(String name) {
			return biz.getAccounts(name);
		}

	}
	
30. JMS

	Asynchronous message processing via annotation:
	@JmsListener - The easiest way to receive a message asynchronously is to use the annotated listener endpoint infrastructure. In a nutshell, it allows you to expose a method of a managed bean as a JMS listener endpoint.
	
	To enable support for @JmsListener annotations add @EnableJms to one of your @Configuration classes.
	@Configuration
	@EnableJms
	public class AppConfig {

		@Bean
		public DefaultJmsListenerContainerFactory jmsListenerContainerFactory() {
			DefaultJmsListenerContainerFactory factory =
					new DefaultJmsListenerContainerFactory();
			factory.setConnectionFactory(connectionFactory());
			factory.setDestinationResolver(destinationResolver());
			factory.setConcurrency("3-10");
			return factory;
		}
	}
	

32. JCA CCI
	Java EE provides a specification to standardize access to enterprise information systems (EIS): the JCA (Java EE Connector Architecture). This specification is divided into several different parts:
		SPI (Service provider interfaces) that the connector provider must implement. 
		CCI (Common Client Interface) that an application can use to interact with the connector and thus communicate with an EIS. 
		
33. Email
	JavaMailSenderImpl sender = new JavaMailSenderImpl();
	sender.setHost("mail.host.com");

	MimeMessage message = sender.createMimeMessage();

	// use the true flag to indicate you need a multipart message
	MimeMessageHelper helper = new MimeMessageHelper(message, true);
	helper.setTo("test@host.com");

	helper.setText("Check out this image!");

	// let's attach the infamous windows Sample file (this time copied to c:/)
	FileSystemResource file = new FileSystemResource(new File("c:/Sample.jpg"));
	helper.addAttachment("CoolImage.jpg", file);

	sender.send(message);

	
34. Task Execution and Scheduling
	The Spring Framework provides abstractions for asynchronous execution and scheduling of tasks with the TaskExecutor and TaskScheduler interfaces, respectively. 
	
	To enable support for @Scheduled and @Async annotations add @EnableScheduling and @EnableAsync to one of your @Configuration classes:
	@Configuration
	@EnableAsync
	@EnableScheduling
	public class AppConfig {
	}
	
	@Scheduled(fixedDelay=5000)
	public void doSomething() {
		// something that should execute periodically
	}
	
	
34.4.3 The @Async Annotation	
	The @Async annotation can be provided on a method so that invocation of that method will occur asynchronously.
	 In other words, the caller will return immediately upon invocation and the actual execution of the method will occur in a task that has been submitted to a Spring TaskExecutor. In the simplest case, the annotation may be applied to a void-returning method.
	 @Async
	void doSomething() {
		// this will be executed asynchronously
	}
	
	@Async
	Future<String> returnSomething(int i) {
		// this will be executed asynchronously
	}

34.4.5 Exception management with @Async
	When an @Async method has a Future typed return value, it is easy to manage an exception that was thrown during the method execution as this exception 
	will be thrown when calling get on the Future result. With a void return type however, the exception is uncaught and cannot be transmitted.
	For those cases, an AsyncUncaughtExceptionHandler can be provided to handle such exceptions.
	
	public class MyAsyncUncaughtExceptionHandler implements AsyncUncaughtExceptionHandler {
		@Override
		public void handleUncaughtException(Throwable ex, Method method, Object... params) {
			// handle exception
		}
	}

	
36. Cache Abstraction
	Cache vs Buffer
		Buffer is used traditionally as an intermediate temporary store for data between a fast and a slow entity. As one party would have to wait for the other 
	affecting performance, the buffer alleviates this by allowing entire blocks of data to move at once rather then in small chunks. The data is written and 
	read only once from the buffer. Furthermore, the buffers are visible to at least one party which is aware of it.
		A cache on the other hand by definition is hidden and neither party is aware that caching occurs.It as well improves performance but does that 
	by allowing the same data to be read multiple times in a fast fashion.
	
	@Cacheable("books")
	public Book findBook(ISBN isbn) {...}
	

	
********************************
Spring Boot
********************************

Boot priorities:
	1. Commandline args
	2. JNDI
	3. Java System properties		- System.getProperty("path.separator");
	4. OS Environment variables		- System.getenv();
	5. Properties files				- application.properties
	6. @PropertySource				- @PropertySource("classpath:/com/myco/app.properties"), then in the config java file: @Autowired Environment env;
	7. Defaults

	
	
********************************
Spring React
********************************

Will be available from Spring Framework 5.

Another source of pain is that if we ever make a mistake and block in one of our Reactive callbacks, 
we will be holding up all requests on the same thread. With the servlet-based containers every request is isolated to a thread, 
and blocking doesn’t hold up other requests because they are be processed on different threads. 
Blocking all requests is still a recipe for trouble, but it only shows up as increased latency with roughly a constant factor per request. 
In the Reactive world, blocking a single request can lead to increased latency for all requests, 
and blocking all requests can bring a server to its knees because the extra layers of buffers and threads are not there to take up the slack.
	
	
	
	
	
********************************
Cloud: IaaS, PaaS, Clound Foundry
********************************

IaaS support: eIMS can be deployed on a cloud-based infrastructure. With this approach only the hardware is provided and scaling the 
	application means firing up more virtual machine instances, and after that each instance needs to be configured: 
	install an operating system, configure the connection to the datafarm, install, the Java runtime and all the necessary packages needed. 
	IaaS provides only the infrastructure (CPU, RAM, storage) but not the platform.
	
PaaS support: through Cloud Foundry which is an open source PaaS implementation. PaaS sits above the infrastructure (IaaS) and provides an 
	operating system for applications on top of that with all the tooling needed to scale the deployed applications. When scaling the application 
	is needed we can forget about installing new virtual machines and post-configurations. The application is the new unit of scale here, 
	we just say we need more instances of this component and the platform will automatically set things up.
	In a microservices world, where there are more components, we can even tell the system which component needs to be scaled up or down.
	What this means for the eIMS is that let’s say Alert Management microservice is having increased requests and struggles to serve them. 
	We can tell the platform that we need more instances of the Alert Management microservice and the platform will handle firing them up.
	Cloud Foundry is host-agnostic, meaning that it can run on VMWare, AWS, OpenStack, ...


	
********************************
Useful utils
********************************

FileCopyUtils	
org.springframework.util.FileSystemUtils
org.springframework.beans.BeanUtils
org.springframework.validation.ValidationUtils
DataSourceUtils (for JDBC), EntityManagerFactoryUtils (for JPA), SessionFactoryUtils, PersistenceManagerFactoryUtils (for JDO)


********************************
Streaming http requests
********************************

Return RxJava Observable


********************************
Eclipse multi maven project with Spring, TDPraktiker
********************************
1. workspace resolution works, eclipse sees, maven also sees the dependencies being in the same workspace: 
2. install the dependency into  the local repo with "mvn install" --> update the consumer project via "maven update" then voila, works!

TDPraktiker: parentPom/pom.xml: only for jenkins build
					
OAuth2 is basically a protocol that supports authorization workflows. What this means is that it gives you a way to ensure that 
a specific user has permissions to do something. That’s it. 
OAuth2 isn’t meant to do stuff like validate a user’s identity — that’s taken care of by an Authentication service. 
Authentication is when you validate a user’s identity (like asking for a username / password to log in), 
whereas authorization is when you check to see what permissions an existing user already has.
Just remember that OAuth2 is a protocol for authorization.



class Convert<M, R> {

	public R convert(M model, Class<R> aClass) {
		R result;
		try {
			result = aClass.newInstance();
			org.springframework.beans.BeanUtils.copyProperties(model, result);
			return result;
		} catch (InstantiationException | IllegalAccessException e) {
			e.printStackTrace();
		}
		return null;
	}
}