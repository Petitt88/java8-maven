Spell extension usage: look for "@authz" (Spring security)
Spring expression usage: look for "#{beanName.fieldName}" (Spring framework)

@PostConstruct - bean lifecycle
@PreDestroy - bean lifecycle

@Component
@Service
@Repository
@Controller
@RestController
@Scope
@Bean

@Valid
@ModelAttribute - this is used to add stuff to spring's model and it ultimately goes into the HttpServletRequest object after the handler executes
	Using @ModelAttribute on a method argument: An @ModelAttribute on a method argument indicates the argument should be retrieved from the model. 
		If not present in the model, the argument should be instantiated first and then added to the model. 
		Once present in the model, the argument’s fields should be populated from all request parameters that have matching names. 
		This is known as data binding in Spring MVC, a very useful mechanism that saves you from having to parse each form field individually.
@SessionAttributes("key") - adds the value from the ModelMap that belongs to the specified key to the HttpSession object after the handler executes
@ResponseBody - @Controller + @ResponseBody = @RestController: write the response to the body (json, xml)
@RequestBody - for json and xml request payloads: map them to arbitrary java classes
@PathVariable - to map url/route parameters, like: "tender/{year}/forms"
@RequestParam - for querystring parameter mapping
@PathParam - t
@RequestAttribute - to bind a controller method's parameter to an object from the HttpServletRequest.Request
@SessionAttribute - to bind a controller method's parameter to an object from the HttpServletRequest.Session
@AuthenticationPrincipal - Spring injects the current user with this

@Value - specify default value on properties. Can be arbirtary string or expression e.g. "#{systemProperties.myProp}"
@Value("#{ @environment['stormpath.sso.message.primary'] ?: 'Primary' }") --> ?: <-- this is the Elvis operator, we can specify fallback value to be used 
																					 if the one is not found in application.properties
@Value("#{beanName.fieldName}")
@Value("server.port") - from application.properties or from @PropertySource file
@ConfigurationProperties - as @Value works with one field, this populates an entire java class's fields

@Order: defines the sort order for an annotated component. The value() is optional and represents an order value as defined in the Ordered interface. Lower values have higher priority. The default value is Ordered.LOWEST_PRECEDENCE, indicating lowest priority (losing to any other specified order value).
@Priority: the standardized version of @Order

@ControllerAdvice - it is typically used to define @ExceptionHandler, @InitBinder, and @ModelAttribute methods that apply to all @RequestMapping methods.
@ExceptionHandler
@ResponseStatus

@Cacheable - to use Spring's cache - implementations can be swapped

@Lazy - lazily initialze beans
	  - it can easily solve circular dependency problems: if one of the ends is lazy than it solves most of the cases
	@Bean @Lazy
	public MyRepository<Account> myAccountRepository() {
		return new MyAccountRepository();
	}
	
	@Service
	public class MyBookAdminService implements BookAdminService {
		// @Autowired
		public MyBookAdminService(@Lazy MyRepository<Account> repo) {
			// "repo" will be a lazy-initializing proxy
		}
	}

@Import - Provides functionality equivalent to the <import/> element in Spring XML. Allows for importing configuration classes (which are not annotated with @Configuration), ImportSelector and ImportBeanDefinitionRegistrar implementations, 
		  as well as regular component classes (as of 4.2; analogous to AnnotationConfigApplicationContext.register(java.lang.Class<?>...)).
		  With this you don't have to specify everything in a single @Configuration (there can be multiple @Configuration classes though), you can @Import any classes that has @Bean beans on them.
@ImportResource: to import configuration from xml files
	
@EnableScheduling
@Scheduled

@Cacheable
@CachePut(key="#book.id") - on methods that just put values into the cache
@CacheEvict - to remove from the cache
	- JCache support
	
	@CacheConfig("books")
	public class BookRepository {
	
		@Cacheable
		public Book findById(String id) {...}
		
		@CachePut(key="#book.id")
		public void updateBook(Book book) {...}
		
		@CacheEvict
		public void delete(String id) {...}
	}

@Transactional - declarative transaction support are that this support is enabled via AOP proxies
@TransactionalEventListener - processes application events if they were published between the specified Transaction boundary - after/before commit, after/before rollback
	- events can be any arbitrary java class (does not have to extend ApplicationEvent anymore (from Spring 4.2))
	- event listener is either a method (@EventListener) or a class that implement ApplicationListener<XXXEvent>
		- @Async can be used to process the event asynchronously
		- by default event processing are synchronous like in C# events: the same thread handles the events that has a ApplicationEventPublisher fired it
	- event can be published via the ApplicationEventPublisher class: applicationEventPublisher.publishEvent(new OrderCreatedEvent(order));
	
	https://spring.io/blog/2015/02/11/better-application-events-in-spring-framework-4-2
	

@EnableWebSecurity
@EnableGlobalMethodSecurity(securedEnabled = true), @Secured("ROLE_TELLER") - for method-level securing
@EnableGlobalMethodSecurity(jsr250Enabled = true) - Support for JSR-250 annotations can be enabled using this. @RolesAllowed, @PermitAll, @DenyAll
@EnableGlobalMethodSecurity(prePostEnabled = true), @PreAuthorize("hasAuthority('ROLE_TELLER')") - These are standards-based and allow simple role-based constraints to be applied but do not have the power Spring Security’s native annotations. To use the new expression-based syntax, you would use this.
		  
MVC:
@RequestAttribute allows to access request attributes
@CookieValue annotation allows a method parameter to be bound to the value of an HTTP cookie.
@RequestHeader annotation allows a method parameter to be bound to a request header.
@InitBinder - allows you to configure web data binding directly within your controller class
@ControllerAdvice and @RestControllerAdvice is a component annotation allowing implementation classes to be auto-detected through classpath scanning. 
	Classes annotated with @ControllerAdvice can contain @ExceptionHandler, @InitBinder, and @ModelAttribute annotated methods, 
	and these methods will apply to @RequestMapping methods across all controller hierarchies as opposed to the controller hierarchy within which they are declared.
	

org.springframework.beans.factory.Aware
Sometimes we need Spring Framework objects in our beans to perform some operations, 
for example reading ServletConfig and ServletContext parameters or to know the bean definitions loaded by the ApplicationContext. 
That’s why spring framework provides a bunch of *Aware interfaces that we can implement in our bean classes.

spring.factories: a file that contains auto-configuration classes for everything. These are only included when certain
	conditions are met thanks to the @ConditionalOnClass annotation which is like the .NET #ifdef
	
https://github.com/spring-projects/spring-boot
https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure
	

Spring:
	- Dev tools: automatically restarts the server when any change happens to our source files (.java, .jsp) on the local classpath.
				 It is automatically disabled in production: when the app is started via the command line.

		- this is achieved by using 2 class loaders: 1 for the libs, maven dependencies which never change
													 1 for our source code which can change
		- in case of a change the lib classloader remains intact, whereas the source-file classloader is recreated. This ensures performance in a microservice world.
		
	- Actuator: provides monitoring capabilities that can be reached via http endpoints or via JMX

		- Endpoints Actuator endpoints allow you to monitor and interact with your application. 
		  Spring Boot includes a number of built-in endpoints and you can also add your own. 
		  For example the health endpoint provides basic application health information. 
		  Run up a basic application and look at /health (and see /mappings for a list of other HTTP endpoints).

		- Metrics Spring Boot Actuator includes a metrics service with “gauge” and “counter” support.
		  A “gauge” records a single value; and a “counter” records a delta (an increment or decrement). 
		  Metrics for all HTTP requests are automatically recorded, so if you hit the metrics endpoint should see a sensible response.

		- Audit Spring Boot Actuator has a flexible audit framework that will publish events to an AuditService. 
		  Once Spring Security is in play it automatically publishes authentication events by default. 
		  This can be very useful for reporting, and also to implement a lock-out policy based on authentication failures.

		- Process Monitoring In Spring Boot Actuator you can find ApplicationPidFileWriter which creates a file containing the 
		  application PID (by default in the application directory with a file name of application.pid).
		  
		  
********************************
JDBC, JPA, Hibernate
********************************
		  
JDBC:
		// load the Driver Class
		Class.forName(props.getProperty("DB_DRIVER_CLASS"));

		// create the connection now
		con = DriverManager.getConnection(props.getProperty("DB_URL"),
				props.getProperty("DB_USERNAME"),
				props.getProperty("DB_PASSWORD"));
	
	
JDBC DataSource:
	Most of the times we are looking for loose coupling for connectivity so that we can switch databases easily, 
	connection pooling for transaction management and distributed systems support. JDBC DataSource is the preferred approach 
	if you are looking for any of these features in your application. 
	
	
Spring DataSource implementation: DriverManagerDataSource!
	<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">

		<property name="driverClassName" value="com.mysql.jdbc.Driver" />
		<property name="url" value="jdbc:mysql://localhost:3306/TestDB" />
		<property name="username" value="pankaj" />
		<property name="password" value="pankaj123" />
	</bean>
	
	But we still have to write a lot of boilerplate code: opening connection, statements, closing them, reading the resulet set in a for loop.
	
	
Spring JdbcTemplate to the rescue:
	All we need is to provide the arguments as Object array and implement Callback interfaces such as 
	PreparedStatementSetter and RowMapper for mapping arguments or converting ResultSet data to bean objects.
	
Spring DataSourceBuilder: creates a DataSource that using connection pooling if Tomcat, HikariCP or Commons DBCP is on the classpath.
	Convenience class for building a DataSource with common implementations and properties. If Tomcat, HikariCP or Commons DBCP are on the classpath one of them will be selected (in that order with Tomcat first). In the interest of a uniform interface, and so that there can be a fallback to an embedded database if one can be detected on the classpath, only a small set of common configuration properties are supported. To inject additional properties into the result you can downcast it, or use @ConfigurationProperties.
	
	
JPA: EntityManager
Hibernate: Session


@Lob @Basic(fetch = FetchType.LAZY)
@Column(name="content", nullable=false)
private byte[] content;
 
We have chosen a byte[] to store the content of file. @LobSpecifies that a this persistent property should be persisted as a 
large object to a database-supported large object type which in our case is longblob. 
@Basic annotation is an optional annotation, serving here as placeholder to instruct hibernate to lazy load the binary content.

Java's transient keyword is used to denote that a field is not to be serialized, whereas JPA's @Transient 
annotation is used to indicate that a field is not to be persisted in the database, i.e. their semantics are different.

Hibernate SQLQuery: not recommended because we loose benefits of 1st level cache.

	Sesssion: not singleton, for the current user (current thread), "cheap" to create. Uses connection pooling if the DataSource supports it.
	SessionFactory: singleton object, expensive to create. Always cache it (Spring caches it).

1st level cache: - at the Session level
				 - enabled by default
				 - for the current user
2nd level cache: - at the JVM level, Session Factory object --> concurrency is a problem
				 - for all users
				 - disabled by default
					- can enable globally (not recommended)
					- only for certain entities, collections
					- configurable at the Session level with CacheMode
				 - cache all properties (default) or only non-lazy
Query cache: - good for repetitive queries with identical params
			 - if used, best in conjunection with 2LC

session.save() 				- saves changes to db (insert or update)) but does not add entity to persistent context: doesn't track entity
							  and further changes at transaction commit won't get saved. 
							  Works without transaction.

session.saveOrUpdate() 		- adds the entity object to persistent context and track any further changes. 
							  Any further changes are saved at the time of committing transaction, like persist.
							  Works without transaction.

session.persist()			- Hibernate persist is similar to save (with transaction) and it adds the entity object to the persistent context, 
							  so any further changes are tracked. If the object properties are changed before the transaction is committed or 
							  session is flushed, it will also be saved into database.
							  Second difference is that we can use persist() method only within the boundary of a transaction, 
							  so it’s safe and takes care of any cascaded objects.
							  
session.update()			- Hibernate update should be used where we know that we are only updating the entity information. 
							  This operation adds the entity object to persistent context and further changes are tracked and saved when 
							  transaction is committed.
							  
session.merge()				- Hibernate merge can be used to update existing values, however this method create a copy from the passed entity object
							  and return it. The returned object is part of persistent context and tracked for any changes, 
							  passed object is not tracked. This is the major difference with merge() from all other methods. 
							  

							  
SessionFactory (org.hibernate.SessionFactory): 						SessionFactory is an immutable thread-safe cache of compiled mappings for a 
																	single database. We can get instance of org.hibernate.Session using SessionFactory.
																	
Session (org.hibernate.Session): 									Session is a single-threaded, short-lived object representing a conversation 
																	between the application and the persistent store. 
																	It wraps JDBC java.sql.Connection and works as a factory for 
																	org.hibernate.Transaction.
																	
ConnectionProvider (org.hibernate.connection.ConnectionProvider): 	ConnectionProvider is a factory for JDBC connections. It provides abstraction 
																	between the application and underlying javax.sql.DataSource or 
																	java.sql.DriverManager. It is not exposed to application, but it can be 
																	extended by the developer.

TransactionFactory (org.hibernate.TransactionFactory): 				A factory for org.hibernate.Transaction instances.

In its default configuration, the Spring Framework’s transaction infrastructure code only marks a transaction for rollback in the case of runtime,
unchecked exceptions; that is, when the thrown exception is an instance or subclass of RuntimeException. 
(Errors will also - by default - result in a rollback). 
Checked exceptions that are thrown from a transactional method do not result in rollback in the default configuration.

@Transactional: must be applied on public methods to get weaved. Also, only works when invoking the object outside of it - means that invoking 
				another public method from the invoked public method that has @Transactional would take no effect either.
				Rolled back automatically only if unchecked RuntimeException is thrown (checked exceptions does not make the transaction rollback)

Normally both JPA and Hibernate require an xml config (persistence.xml, hibernate.cfg.xml), but with Spring these can be omitted.
(Spring scans the package and packages down for @Entity classes.) @EnableJpaRepositories("com.acme.repositories")

A persistence context is a concept that is a list of SQL statements to be sent to the database. Each Hibernate session has one persistence context.

Mappings:
	@OneToOne: @OneToOne(fetch = FetchType.LAZY, optional = false) to prevent hibernate from querying the related entity in a separate query even if the FetchType is LAZY.
			   http://stackoverflow.com/questions/17987638/hibernate-one-to-one-lazy-loading-optional-false


@Entity --> @Respository (Dao) --> @Service --> @Controller/@Restcontroller

					
					
********************************
Spring Security
********************************

When security is only the classpath, all endpoints by default requires basic authentitcation (including the static resource files).
CSRF protection is enabled by default.

.formLogin() - injects a Filter (UsernamePasswordAuthenticationFilter) to the FilterChain pipeline
			 - invoked only when url is "loginProcessingUrl()"
			 - default authenticationProvider is used which uses basic authentication - can be replaced with inMemory, jdbc, or custom

@Autowired
public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
	// in memory
	auth.inMemoryAuthentication().withUser("user").password("user");

	// jdbc
	auth.jdbcAuthentication().dataSource(dataSource)
			.usersByUsernameQuery("select username,password, enabled from users where username=?")
			.authoritiesByUsernameQuery("select username, role from user_roles where username=?");

	// custom
	auth.authenticationProvider(authenticationProvider);
}

public class CustomAuthenticationProvider implements AuthenticationProvider { ... }

HttpServletRequest.login(String,String) - to programatically log the user in
HttpServletRequest.logout() - for logout

Annotation based security: @EnableGlobalMethodSecurity

f you’ve used Spring Security before, you’ll know that the framework maintains a chain of filters in order to apply its services. 
You may want to add your own filters to the stack at particular locations or use a Spring Security filter for 
which there isn’t currently a namespace configuration option.


UsernamePasswordAuthenticationFilter: this reads the "username" and "password" from the request and uses the AuthenticationManager
	to authenticate the request.
	
SecurityContextPersistenceFilter: stores the SecurityContext (user info) into the HttpSession
	
UserDetailsService: can be optionally overridden and provide a custom userDetails implementation (reach the db for instance)
GrantedAuthority: UserDetailsService provides them, usually they are roles

	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		super.configure(auth);

		// auth.authenticationProvider(authenticationProvider)
		// auth.userDetailsService(userDetailsService)
	}

26.2 Web Security Expressions
	What we need for authentication:
		- Csrf filter
		- UsernamePasswordAuthenticationFilter - or a custom filter that reads the credentials and invokes AuthenticationManager.authenticate
		- custom AuthenticationProvider
		
		@Configuration
		@PropertySource("classpath:custom.yml")
		@EnableWebSecurity
		@EnableGlobalMethodSecurity(prePostEnabled = true)
		public class SecurityConfig extends WebSecurityConfigurerAdapter {
		
			@Override
			protected void configure(HttpSecurity http) throws Exception {
				System.out.println("env");
				System.out.println(env.getProperty("vmc.admin.name"));

				CookieCsrfTokenRepository tokenRepo = CookieCsrfTokenRepository.withHttpOnlyFalse();
				tokenRepo.setHeaderName("X-XSRF-TOKEN");
				tokenRepo.setCookieName("XSRF-TOKEN");

				http.authorizeRequests()
						.antMatchers("**/**").permitAll()
						.antMatchers("/users/{userId}").access("#userId == principal.id.toString()")	// this is Spring Security path variables.
																										// principal is the current user - whatever we return from out UserDetailsService
																										// This is called "Spell extension with Spring Data" 
																										//			- SecurityDataConfiguration provides the SecurityEvaluationContextExtensions to process the expression
																										
						.antMatchers("/users/{userId}").access("@authz.check(#userId, principal)")	// but I don't like the ".toString()" - I can refer to any bean in Spring Spell using the "@" symbol
																									// here I have a bean called "authz"
																									
						.antMatchers("/admin").denyAll()	// matches only /admin and denies it.
															// however if this is an Mvc controller route it can still be accessed by /admin/ or /admin.json, /admin.html etc because Spring Mvc removes file extensions
						.antMatchers("/admin/**").denyAll()	// the correct way to disable /admin - but this also disables /admin/whatever
						.mvcMatchers("/admin").denyAll() 	// use this to properly disable the Mvc route
						
						// .anyRequest().authenticated()
						.and()
						.formLogin()
						.and()
						.httpBasic()
						.and()
						.csrf()
						.csrfTokenRepository(tokenRepo)
						.and()
						.headers()
						/*.contentSecurityPolicy(policyDirectives)*/;
				// .and()
				// .sessionManagement()
				// .sessionCreationPolicy(SessionCreationPolicy.STATELESS);
				// .anonymous().disable();
			}
		}
		
		@Component
		public class Authz {
			// used in the SecurityConfig
			public boolean check(Long userId, User user) {
				return userId.equals(user.getId());
			}
			
			// used by @ReadableMessage
			public boolean check(Message message, User user) {
				...
			}
		}
		
		public interface MessageRepository extends CrudRepository<Message, Long> {
		
			@Query("select m from Message m where m.to.id = ?#{principal.id}")	// ?#{principal.id} refers to the current user's id
			Iterable<Message> inbox();
			
			@PostAuthorize("returnObject?.to?.id == principal.id || returnObject?.from?.id == principal.id")	// returnObject refers to whatever object the query returns. The ?. is just to avoid NullPointerException
			Message findBySummary(@Param("summary") String summary);
			
			@ReadableMessage	// this is a Meta-annotation, we avoided ugly string Spell extensions here and moreover we do not tie ourselves to Spring Security API
			Message findBySummaryEvenBetter(@Param("summary") String summary);
		}
		
		// Meta-annotation annotated with @PostAuthorize annotation that has the "authz" custom bean invoking check
		@Retention(RetentionPolicy.RUNTIME)
		@PostAuthorize("@authz.check(returnObject, principal)")
		public @interface ReadableMessage {
		}
	
SecurityContextRepository: its job is to store the SecurityContext. The default ones stores it in the HttpSession as an attribute.

We can use a custom filter chain by @Bean FilterChainProxy getFilterChain() {...}
	There are 3 mandatory security filters that must be included: SecurityContextPersistenceFilter, ExceptionTranslationFilter, FilterSecurityInterceptor
	
To use a custom FilterChainProxy:
	@Bean(name = "springSecurityFilterChain")
	public FilterChainProxy getFilterChainProxy() {
		SecurityFilterChain chain = new SecurityFilterChain() {

			@Override
			public boolean matches(HttpServletRequest request) {
				// All goes through here
				return true;
			}

			@Override
			public List<Filter> getFilters() {
				List<Filter> filters = new ArrayList<Filter>();

				filters.add(getCookieAuthenticationFilter());
				filters.add(getLogoutFilter());
				filters.add(getUserNamePasswordAuthenticationFilter());
				filters.add(getSecurityContextHolderAwareRequestFilter());
				filters.add(getAnonymousAuthenticationFilter());
				filters.add(getExceptionTranslationFilter());
				filters.add(getFilterSecurityInterceptor());

				return filters;
			}
		};
    
		return new FilterChainProxy(chain);
	}
	
Spring Security’s web infrastructure is based entirely on standard servlet filters. 
It doesn’t use servlets or any other servlet-based frameworks (such as Spring MVC) internally, so it has no strong links 
to any particular web technology.
Spring Security maintains a filter chain internally where each of the filters has a particular responsibility 
and filters are added or removed from the configuration depending on which services are required.


********************************
Spring Session
********************************

Overrdies the default session provided by the servlet container. We can use Gemfire, Redis, Jdbc, MongoDB transparently to store the session.
By default the session-data gets stored in the servlet container's memory.

We have already mentioned that Spring Session provides transparent integration with HttpSession, but what benefits do we get out of this?
	Clustered Sessions - Spring Session makes it trivial to support clustered sessions without being tied to an application container 
					     specific solution.
						 
	Multiple Browser Sessions - Spring Session supports managing multiple users' sessions in a single browser instance 
								(i.e. multiple authenticated accounts similar to Google).

	RESTful APIs - Spring Session allows providing session ids in headers to work with RESTful APIs
	

Redis can be used by:
@Configuration
@EnableRedisHttpSession(maxInactiveIntervalInSeconds=7200)
public class HttpSessionConfig {
	@Bean
    public JedisConnectionFactory connectionFactory() {
		return new JedisConnectionFactory(); 
    }
}


JSESSIONID: this is the cookie that holds the id of the user's session

To replace the path of the session cookie:

	http://docs.spring.io/spring-session/docs/1.2.1.RELEASE/reference/html5/guides/custom-cookie.html
		
	@Bean
	public CookieSerializer cookieSerializer() {
			DefaultCookieSerializer serializer = new DefaultCookieSerializer();
			serializer.setCookieName("JSESSIONID"); 
			serializer.setCookiePath("/"); 
			serializer.setDomainNamePattern("^.+?\\.(\\w+\\.[a-z]+)$"); 
			return serializer;
	}
	
To replace the HttpSessionStrategy and store the sessionId in a header instead of a cookie use:
	@Configuration
	@EnableRedisHttpSession 
	public class HttpSessionConfig {

			@Bean
			public HttpSessionStrategy httpSessionStrategy() {
					return new HeaderHttpSessionStrategy(); 
			}
	}


********************************
Spring Cloud, Microservices
********************************

Eureka, ZooKeeper: service registry and provide network discovery (prefer to use eureka since it is more resilient to failures)
Hystrix: fault tolerance: fallback methods in case of failures - on the edge service, microservices. Implements the circuit breaker pattern.
Microservice: invoked by the edge service, and they can invoke each other (hystrix needed if invoking other services for the best user experience - avoid showing stacktraces)
Zuul: egde service implementation: micro proxy, api gateway
	1. Micro proxy: blindly forward packages outside the datacenter inside the loadbalancer
	2. API gateway: transforms the request to the services behind the loadbalancer
Actuator: monitoring capabilities via jmx and rest api (use with the config server)
Config server: central store for configurations of the participants of the system
Hystrix dashboard, Turbine: use for health monitoring
	Turbine: aggregates the Hystrix health monitoring data from each method of each microservice and provides an aggregated result.
Ribbon: round robin load balancer
Zipkin: Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in microservice architectures.
Kafka: Kafka™ is used for building real-time data pipelines and streaming apps. It is horizontally scalable, fault-tolerant, wicked fast, 
	and runs in production in thousands of companies.

Config service: just a super lightweight service that is used to centralize the configuration data 
	Scenario is that I have multiple microservices and do not want to store config one by one for each service, rather I would store them in a 
	central config server.
	
	@EanbleConfigServer
	application.properties: spring.cloud.config.server.git.uri=${HOME}/Desktop/config <-- in this folder resides the configs for the various microservices	
							server.port=8888

Service registry: (Eureka for example)
				  It is like a phonebook for the cloud.
				  Just a registry the regisers microservices and enables client side loadbalancing.
	
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-could-starter-config</artifactId>
	</dependency>
	
	@EnableEurekaServer
	
	bootstrap.properties: spring.application.name=eureka-service
						  spring.cloud.config.uri=http://localhost:8888	<-- config is from the config server
						  
	Start the service and visit it in the browser: you'll see a nice console window.
						  
MicroService:

	1. config comes from the config server
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-could-starter-config</artifactId>
	</dependency>

	bootstrap.properties: string.application.name=reservation-service
						  spring.cloud.config.uri=http://localhost:8888

	2. teach this service to talk to Eureka
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-could-starter-eureka</artifactId>
	</dependency>

	@EnableDiscoveryClient - now service will get registered in Eureka
						   - going to Eureka's console will display the this service ("reservation-service", comes from the bootstrap.properties)
						   
						   
Edge service: there are two types:
				1. Micro proxy: bindlys forward packages outside to the datacenter inside the loadbalancer
				2. API gateway: transforms the request to the services behind the loadbalancer
				
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-could-starter-config</artifactId>
	</dependency>
				
	1. Micro proxy: Eureka discovery, Config client, Hystrix (for circuit breakers), Zuul (for micro proxy), Stream Redis, Zipkin (distributed tracing)
	
		@EnableDiscoveryClient
		@EnableZuulProxy - blindly forward the requests from the edge service into the service that we reference in the request's url
			localhost:9999/reservation-service/reservations: {edge-service}/{serviceId as registered in the service registry}/{url in the referenced service}
		
		bootstrap.properties: sptring.application.name=reservation-client
								spring.cloud.config.uri=http://localhost:8888	<-- config is from the config server
								
	2. Api gateway: at this point same as the Micro proxy: to test, localhost:9999/reservations/name
		
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-hateoas</artifactId>
		</dependency>
		
		Hystrix: allows us to specify a fallback path if the microserve request goes wrong
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-boot-starter-hystrix</artifactId>
		</dependency>
		@EnableCircuitBreaker
		
		@RestController
		@RequestMapping("/reservations")
		public class ReservationApiGatewayController {

			@Autowired
			private RestTemplate restTemplate;

			public Collection<String> getReservationNamesFallback() {
				return new ArrayList<>();
			}

			@HystrixCommand(fallbackMethod = "getReservationNamesFallback")
			@RequestMapping(method = RequestMethod.GET, value = "/names")
			public Collection<String> getReservationNames() {

				ParameterizedTypeReference<Resources<Reservation>> ptr = new ParameterizedTypeReference<Resources<Reservation>>() {};

				// "reservation-service" indentifies the microservice we are to call
				// this works if there is 1 service instance or there are multiple instances
				// however it blows chunks of there is no service, that is why the fallbackMethod specified
				ResponseEntity<Resources<Reservation>> entity = this.restTemplate.exchange("http://reservation-service/reservations", ptr);
		
				return entity
					.getBody()
					.getContent()
					.stream()
					.map(Reservation::getReservationName)
					.collapseInCollections(Collectors.toList()));
			}
		}
		
		When the url gets executed it 
			1. grabs the serviceId (reservation-service)
			2. goes to the service registry
			3. gets all registered instances of reservation-service services from the registry
			4. invokes one instance via Ribbon (which is a round-robin load-balander, each instance has the same chance to get invoked)
	
	
	This is good for reading, however for writing which requires synchronization is not good.
	We could use distributed transations but Josh Long urges us not to, it just slows down aggregate system.
	Instead use messaging: forward to the service on a message bus: job is put into a queue (buffer) and eventually gets picked up by the service.
	
	
	2.1. continuing the Api gateway: the sender, producer - reservation-client
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-could-starter-stream-redis</artifactId>
		</dependency>
		Redis is just one implmenation, we could use "Rabbit and queue" or whatever
		
		@EanbleBinding(Source.class) - this enables spring cloud stream, this is the producer
		
		@RestController
		@RequestMapping("/reservations")
		public class ReservationApiGatewayController {
		
			@Autowired
			private Source source;

			@RequestMapping(method = RequestMethod.POST)
			public void writeReservation(@RequestBody Reservation r) {
				Message<String> msg = MessageBuilder<T>.withPayload(r.getReservationName())build();
				this.source.output().send(msg;)
			}
			
			...
		}
		
		where the request is sent is in the configuration: reservation-client: spring.cloud.stream.bindings.ouput: "reservations"
														   reservation-service: spring.cloud.stream.bindings.input: "reservations"
														   
														   
	2.2 the consumer, reservation-service
	
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-could-starter-stream-redis</artifactId>
		</dependency>
		
		@EanbleBinding(Sink.class)
		@IntegrationComponentScan - using Spring Integration
		
		@MessageEndpoint
		class ReservationProcessor {
		
			@ServiceActivator(inputChannel = Sink.INPUT)
			public void acceptNewReservations(String rn) {
				this.reservationRepository.save(new Reservation(rn));
			}
		}
		

Hystrix dashboard, H2 console - good stuff, start.spring.io starters
Spring cloud handles Single Sign on, Oath2 is dead simple



********************************
Spring cloud deployment
********************************

Cloud Foundry: PaaS platform
BOSH: how you automate, install and congfigure a CF system (among other things, it does a lot of stuff)



********************************
Spring IO
********************************

Spring IO Platform brings together the core Spring APIs into a cohesive platform for modern applications. 
It provides versions of numerous projects in the Spring portfolio along with their dependencies that are tested and known to work together.

Overriding a version using maven
	<properties>
		<foo.version>1.1.0.RELEASE</foo.version>
	</properties>
	
	
	
********************************
Spring Data
********************************

The goal of Spring Data repository abstraction is to significantly reduce the amount of boilerplate code required to implement data 
access layers for various persistence stores.

Auditing: 
	We provide @CreatedBy, @LastModifiedBy to capture the user who created or modified the entity as well as 
	@CreatedDate and @LastModifiedDate to capture the point in time this happened.
	
	@Entity
	@EntityListeners(AuditingEntityListener.class)
	public class MyEntity { }
	
	interface UserRepository extends Repository<User, Long> {
		// Redeclaration of a CRUD method
		@Lock(LockModeType.READ);
		List<User> findAll();
	}
	

	
Autogenerate sqls: CrudRepository, PagingAndSortingRepository

Async query results: @Async
					 CompletableFuture<User> findOneByFirstname(String firstname)
					 
Adding custom behavior to all repositories
	@NoRepositoryBean
	public interface MyRepository<T, ID extends Serializable>
		extends PagingAndSortingRepository<T, ID> {

		void sharedCustomMethod(ID id);
	}
	
	public class MyRepositoryImpl<T, ID extends Serializable> extends SimpleJpaRepository<T, ID> implements MyRepository<T, ID> {

		private final EntityManager entityManager;

		public MyRepositoryImpl(JpaEntityInformation entityInformation, EntityManager entityManager) {
			super(entityInformation, entityManager);

			// Keep the EntityManager around to used from the newly introduced methods.
			this.entityManager = entityManager;
		}

		public void sharedCustomMethod(ID id) {
			// implementation goes here
		}
	}
	
	
The results of query methods can be processed incrementally by using a Java 8 Stream<T> as return type. 
Instead of simply wrapping the query results in a Stream data store specific methods are used to perform the streaming.	
	@Query("select u from User u")
	Stream<User> findAllByCustomQueryAndStream();
	
	Stream<User> readAllByFirstnameNotNull();
	
	
@Query("select u from User u where u.firstname = :firstname or u.lastname = :lastname")
User findByLastnameOrFirstname(@Param("lastname") String lastname, @Param("firstname") String firstname);
								 
@Query(value = "SELECT * FROM USERS WHERE LASTNAME = ?1",
	   countQuery = "SELECT count(*) FROM USERS WHERE LASTNAME = ?1",
       nativeQuery = true)
Page<User> findByLastname(String lastname, Pageable pageable);


	
********************************
Spring Data Rest - good for integration: consumer can easily discover our API - HATEOAS
********************************

HATEOAS (Hypermedia as the Engine of Application State) is a constraint of the REST application architecture.

A hypermedia-driven site provides information to navigate the site's REST interfaces dynamically by 
including hypermedia links with the responses. This capability differs from that of SOA-based systems and WSDL-driven interfaces. 
With SOA, servers and clients usually must access a fixed specification that might be staged somewhere else on the website, on another website, 
or perhaps distributed by email.

A core principle of HATEOAS is that resources should be discoverable through the publication of links that point to the available resources. 
There are a few competing de-facto standards of how to represent links in JSON. By default, 
Spring Data REST uses HAL to render responses. HAL defines links to be contained in a property of the returned document.


Spring Data REST officially supports: Spring Data Jpa, Spring Data MongoDB, GemFire, Cassandra, Neo4j

public interface OrderRepository extends CrudRepository<Order, Long> { }. For this repository, Spring Data REST exposes a collection resource at /orders.

curl -v http://localhost:8080/

	< HTTP/1.1 200 OK
	< Content-Type: application/hal+json

	{ "_links" : {
		"orders" : {
		"href" : "http://localhost:8080/orders"
		},
		"profile" : {
		"href" : "http://localhost:8080/api/alps"
		}
	  }
	}


	
********************************
Spring Batch
********************************

Spring Batch is not a scheduling framework.
Usage:
	A typical batch program generally reads a large number of records from a database, file, or queue, processes the data in some fashion, 
	and then writes back data in a modified form. Spring Batch automates this basic batch iteration, providing the capability to process similar 
	transactions as a set, typically in an offline environment without any user interaction. 
	
Business Scenarios:
	Commit batch process periodically
	Concurrent batch processing: parallel processing of a job
	Staged, enterprise message-driven processing
	Massively parallel batch processing
	Manual or scheduled restart after failure
	Sequential processing of dependent steps (with extensions to workflow-driven batches)
	Partial processing: skip records (e.g. on rollback)
	Whole-batch transaction: for cases with a small batch size or existing stored procedures/scripts
	
Processing options:
	1. Normal processing in a batch window during off-line
	2. Concurrent batch / on-line processing
	3. Parallel processing of many different batch runs or jobs at the same time
	4. Partitioning (i.e. processing of many instances of the same job at the same time)
	
	1. For simple batch processes running in a separate batch window, where the data being updated is not required by on-line users or other batch processes, 
		concurrency is not an issue and a single commit can be done at the end of the batch run.
		
	2. Batch applications processing data that can simultaneously be updated by on-line users, should not lock any data (either in the database or in files) which 
		could be required by on-line users for more than a few seconds. Also updates should be committed to the database at the end of every few transaction. 
		This minimizes the portion of data that is unavailable to other processes and the elapsed time the data is unavailable.
		
	3. Parallel processing allows multiple batch runs / jobs to run in parallel to minimize the total elapsed batch processing time. This is not a problem as long 
		as the jobs are not sharing the same files, db-tables or index spaces. If they do, this service should be implemented using partitioned data. 
	
	4. Using partitioning allows multiple versions of large batch applications to run concurrently. The purpose of this is to reduce the elapsed time required to 
		process long batch jobs. Processes which can be successfully partitioned are those where the input file can be split and/or the main database tables partitioned 
		to allow the application to run against different sets of data.

		
Job: A Job is an entity that encapsulates an entire batch process. It contains one or more steps.

JobIstance: JobInstance = Job + identifying JobParameters (starting time of the job). A JobInstance refers to the concept of a logical job run. Persisted in the database.

JobExecution: A JobExecution refers to the technical concept of a single attempt to run a Job's instance. Persisted in the database.
	Each JobInstance can have multiple JobExecutions.
	The ideal number is one, but if the job's instance fails and are rerun, another execution is created for the same instance.
	An execution may end in failure or success, but the JobInstance corresponding to a given execution will not be considered complete unless the execution completes successfully.
	
JobParameters: distinguishes a particaluar job's instances from each other. JobInstance gets it, it is the starting time of the job.

Setp: ItemReader + ItemProcessor + ItemWriter. A Job has one or more Steps.

StepExecution: represents a single attempt to execute a Step. JobExecution has one or more StepExecutions. 
	A new StepExecution will be created each time a Step is run, similar to JobExecution. 
	However, if a step fails to execute because the step before it fails, there will be no execution persisted for it. 
	A StepExecution will only be created when its Step is actually started.
	
JobRepository: JobRepository is the persistence mechanism for all of the Stereotypes mentioned above.
	It provides CRUD operations for JobLauncher, Job, and Step implementations. 
	When a Job is first launched, a JobExecution is obtained from the repository, and during the course of execution 
	StepExecution and JobExecution implementations are persisted by passing them to the repository.
	
JobLauncher represents a simple interface for launching a Job with a given set of JobParameters.

ItemReader is an abstraction that represents the retrieval of input for a Step, one item at a time. When the ItemReader has exhausted the items it can provide, it will indicate this by returning null.
ItemWriter is an abstraction that represents the output of a Step, one batch or chunk of items at a time.
ItemProcessor is an abstraction that represents the business processing of an item. While the ItemReader reads one item, and the ItemWriter writes them, the ItemProcessor 
	provides access to transform or apply other business processing. If, while processing the item, it is determined that the item is not valid, returning null indicates that the item should not be written out.
	
ExecutionContext: An ExecutionContext represents a collection of key/value pairs that are persisted and controlled by the framework in order to allow developers a 
	place to store persistent state that is scoped to a StepExecution or JobExecution. For those familiar with Quartz, it is very similar to JobDataMap. 
	The best usage example is to facilitate restart. Using flat file input as an example, while processing individual lines, 
	the framework periodically persists the ExecutionContext at commit points. This allows the ItemReader to store its state in case a fatal error occurs during the run, 
	or even if the power goes out. All that is needed is to put the current number of lines read into the context, and the framework will do the rest:
		executionContext.putLong(getKey(LINES_READ_COUNT), reader.getPosition());
	
4.1.1 Restartability
	One key issue when executing a batch job concerns the behavior of a Job when it is restarted. The launching of a Job is considered to be a 'restart' if a JobExecution already exists for the particular JobInstance.
	
4.1.2 Intercepting Job Execution

4.3.3 In-Memory Repository
	In-Memory Repository: There are scenarios in which you may not want to persist your domain objects to the database.
		<bean id="jobRepository" class="org.springframework.batch.core.repository.support.MapJobRepositoryFactoryBean">
			<property name="transactionManager" ref="transactionManager"/>
		</bean>
		
4.6.1 Querying the Repository
	Use the JobExplorer interface.
	
	
5. Configuring a Step
5.1 Chunk-Oriented Processing
	Spring Batch uses a 'Chunk Oriented' processing style within its most common implementation. Chunk oriented processing refers to reading the data one at a time,
	and creating 'chunks' that will be written out, within a transaction boundary. One item is read in from an ItemReader, handed to an ItemProcessor, and aggregated. 
	Once the number of items read equals the commit interval, the entire chunk is written out via the ItemWriter, and then the transaction is committed.
	
6. ItemReaders and ItemWriters
	All batch processing can be described in its most simple form as reading in large amounts of data, performing some type of calculation or transformation, 
	and writing the result out. Spring Batch provides three key interfaces to help perform bulk reading and writing: ItemReader, ItemProcessor and ItemWriter.
	
6.3.1 Chaining ItemProcessors
	Use the CompositeItemProcessor.
	
6.3.2 Filtering Records
	To filter a record, one simply returns "null" from the ItemProcessor.
	
7. Scaling and Parallel Processing
	7.1 Multi-threaded Step
		The result of the above configuration will be that the Step executes by reading, processing and writing each chunk of items (each commit interval)
		in a separate thread of execution. Note that this means there is no fixed order for the items to be processed, and a chunk might contain items that are 
		non-consecutive compared to the single-threaded case. In addition to any limits placed by the task executor (e.g. if it is backed by a thread pool), 
		there is a throttle limit in the tasklet configuration which defaults to 4. You may need to increase this to ensure that a thread pool is fully utilised.
					 
	7.2 Parallel Steps
		Steps execute parallel.
		As long as the application logic that needs to be parallelized can be split into distinct responsibilities, 
		and assigned to individual steps then it can be parallelized in a single process.
		

	7.3 Remote Chunking
		In Remote Chunking the Step processing is split across multiple processes, communicating with each other through some middleware.

	7.4 Paritioning: 
		Spring Batch also provides an SPI for partitioning a Step execution and executing it remotely.
	
11. Common Batch Patterns
11.1 Logging Item Processing and Failures
	public class ItemFailureLoggerListener extends ItemListenerSupport {

		private static Log logger = LogFactory.getLog("item.error");

		public void onReadError(Exception ex) {
			logger.error("Encountered error on read", e);
		}

		public void onWriteError(Exception ex, Object item) {
			logger.error("Encountered error on write", ex);
		}

	}



********************************
Spring 	Integration	
********************************

	In addition to wiring together fine-grained components, Spring Integration provides a wide selection of channel adapters and gateways to 
	communicate with external systems. Channel Adapters are used for one-way integration (send or receive); 
	gateways are used for request/reply scenarios (inbound or outbound).


	Spring Integration provides an extension of the Spring programming model to support the well-known Enterprise Integration Patterns. 
	It enables lightweight messaging within Spring-based applications and supports integration with external systems via declarative adapters. 
	Those adapters provide a higher-level of abstraction over Spring’s support for remoting, messaging, and scheduling.

	Spring Integration is motivated by the following goals:
		Provide a simple model for implementing complex enterprise integration solutions.
		Facilitate asynchronous, message-driven behavior within a Spring-based application.
		Promote intuitive, incremental adoption for existing Spring users.
	Spring Integration is guided by the following principles:
		Components should be loosely coupled for modularity and testability.
		The framework should enforce separation of concerns between business logic and integration logic.
		Extension points should be abstract in nature but within well-defined boundaries to promote reuse and portability.
		
	Message: In Spring Integration, a Message is a generic wrapper for any Java object combined with metadata used by the framework while handling 
			 that object. It consists of a payload and headers.
	Message Channel: A Message Channel represents the "pipe" of a pipes-and-filters architecture. 
					 Producers send Messages to a channel, and consumers receive Messages from a channel. 
					 The Message Channel therefore decouples the messaging components, and also provides a convenient point for interception 
					 and monitoring of Messages.
					 
					 A Message Channel may follow either Point-to-Point or Publish/Subscribe semantics. With a Point-to-Point channel, 
					 at most one consumer can receive each Message sent to the channel. Publish/Subscribe channels, on the other hand, 
					 will attempt to broadcast each Message to all of its subscribers. Spring Integration supports both of these.
					 will attempt to broadcast each Message to all of its subscribers. Spring Integration supports both of these.
	Message Endpoint: One of the primary goals of Spring Integration is to simplify the development of enterprise integration solutions 
					  through inversion of control. This means that you should not have to implement consumers and producers directly,
					  and you should not even have to build Messages and invoke send or receive operations on a Message Channel. 
					  Instead, you should be able to focus on your specific domain model with an implementation based on plain Objects. 
					  Then, by providing declarative configuration, you can "connect" your domain-specific code to the messaging infrastructure
					  provided by Spring Integration. The components responsible for these connections are Message Endpoints.
					  
	Message Endpoints: A Message Endpoint represents the "filter" of a pipes-and-filters architecture. As mentioned above, the endpoint’s 
					   primary role is to connect application code to the messaging framework and to do so in a non-invasive manner. 
					   In other words, the application code should ideally have no awareness of the Message objects or the Message Channels.
					   This is similar to the role of a Controller in the MVC paradigm. Just as a Controller handles HTTP requests, 
					   the Message Endpoint handles Messages. Just as Controllers are mapped to URL patterns, Message Endpoints are mapped 
					   to Message Channels.
	Transformer: A Message Transformer is responsible for converting a Message’s content or structure and returning the modified Message.
	Filter: A Message Filter determines whether a Message should be passed to an output channel at all. 
	Router: A Message Router is responsible for deciding what channel or channels should receive the Message next (if any). 
	Service Activator: A Service Activator is a generic endpoint for connecting a service instance to the messaging system.
	Channel Adapter: A Channel Adapter is an endpoint that connects a Message Channel to some other system (external system) or transport. 
					 Channel Adapters may be either inbound or outbound. Typically, the Channel Adapter will do some mapping between the 
					 Message and whatever object or resource is received-from or sent-to the other system (File, HTTP Request, JMS Message, etc).
					 Depending on the transport, the Channel Adapter may also populate or extract Message header values. 
					 Spring Integration provides a number of Channel Adapters, and they will be described in upcoming chapters.

	@EnableIntegration
	@IntegrationComponentScan
	@EnablePublisher

	MessagingTemplate: send, receive, sendAndReceive

	Channel Adapter: A Channel Adapter is a Message Endpoint that enables connecting a single sender or receiver to a Message Channel. 
					 Spring Integration provides a number of adapters out of the box to support various transports, such as JMS, File, HTTP,
					 Web Services, Mail, and more. 
	Messaging Bridge: A Messaging Bridge is a relatively trivial endpoint that simply connects two Message Channels or Channel Adapters.
	MessageBuilder 


	- uses messaging to communicate between services
		- JMS or AMQP (Java Messaging Service, Advanced Message Queuing Protocol)
			- JMS works only between java-based components
			- AMQP (Advanced Message Queuing Protocol) works between any kind of services
				- RabbitMQ is one implementation (Spring supports it), or ActiveMQ
			- Amazon has an implementation too that Spring supports
			
	Spring Cloud Stream: a way of describing messaging based services and compose them outside of the actual code.
		It builds on Spring Integration and alleviates the need to specify the tedious work of adapters (Inbound and Outbound channels - Spring Integration uses these - they are still there tough if needed).
		We don't have to worry have the channels talk to other nodes, services, that connectivity comes from conventions and configuration file.
		Spring Cloud Stream Binder handles the communication: notably RabbitMQ, Apache Kafka.
		
	Spring Cloud Data Flow: coyorgraphing microservices based on Spring Cloud Stream.
		They can be maven based Stream Applications with RabbitMQ Binder or with Apache Kafka Binder.
		Or Docker based Stream Applications with RabbitMQ Binder or with Apache Kafka Binder.
		Or Maven based Task Applications.
		Or Docker based Task Applications.
		
		Maven produces a jar as for the output whereas in case of Docker the output is a Docker image.
		
		Stream vs Task: Stream is something that is infinite, like messaging while Task is finite, like Spring Batch jobs.
		
	
	
********************************
Spring Framework
********************************

The syntax ${x:${y}} is Spring property shorthand for ${x} != null ? ${x} : ${y}.
eureka:
  instance:
    metadataMap:
      instanceId: ${spring.application.name}:${spring.application.instance_id:${server.port}}

Dependency Injection:
	@PostConstruct
	@PreDestroy
	

Components: 
	Core Container: consists of the spring-core, spring-beans, spring-context, spring-context-support, and spring-expression 
					(Spring Expression Language) modules. he Context module also supports Java EE features such as EJB, JMX, and basic remoting.
	AOP and Instrumentation: aspect-oriented programming implementation allowing you to define, for example, method interceptors and pointcuts to cleanly decouple code that implements functionality that should be separated.
	Messaging: Spring Framework 4 includes a spring-messaging module with key abstractions from the Spring Integration project such as Message, MessageChannel, MessageHandler, and others to serve as a foundation for messaging-based applications.
	Data Access/Integration: The Data Access/Integration layer consists of the JDBC, ORM, OXM, JMS, and Transaction modules.
	Web: The Web layer consists of the spring-web, spring-webmvc, spring-websocket, and spring-webmvc-portlet modules.
		The spring-web module provides basic web-oriented integration features such as multipart file upload functionality and the 
			initialization of the IoC container using Servlet listeners and a web-oriented application context. 
			It also contains an HTTP client and the web-related parts of Spring’s remoting support.
		The spring-webmvc module (also known as the Web-Servlet module) contains Spring’s model-view-controller (MVC) and REST Web Services
			implementation for web applications. Spring’s MVC framework provides a clean separation between domain model code and 
			web forms and integrates with all of the other features of the Spring Framework.
	Test: The spring-test module supports the unit testing and integration testing of Spring components with JUnit or TestNG. It provides consistent 
		loading of Spring ApplicationContexts and caching of those contexts. It also provides mock objects that you can use to test your code in isolation.
	
	
For logging JCL (Jakarta Common Logging) library is used, but it was a mistake. It can be excluded from the dependencies of spring-core and use
SLF4J  instead.
		
JMS improvements: Synchronous request-reply operations support in JmsTemplate
Caching improvements

Beans by default are Singletons and eagerly initialized. Use @Lazy for lazy initialization.
Bean scopes: singleton, prototype, request, session, globalsession, application, websocket

Method injection: used typically when a Singleton bean (A) has prototype dependency (B) and A needs new B instances.
	- inject the ApplicationContext and use the Service Locator pattern is the only solution
	
To interact with the container’s management of the bean lifecycle, you can implement the Spring InitializingBean and DisposableBean interfaces.
	BUT: The JSR-250 @PostConstruct and @PreDestroy annotations are generally considered best practice for receiving lifecycle callbacks in a modern 
	Spring application. Using these annotations means that your beans are not coupled to Spring specific interfaces.
	
	
7.6.3 Other Aware interfaces: ApplicationContextAware, BeanNameAware, ServletConfigAware, ServletContextAware
7.9 Annotation-based container configuration

@Required, 
@Autowired - resolves dependencies by type
@Primary - indicates that a particular bean should be given preference when multiple beans are candidates to be autowired to a single-valued dependency
@Qualifier - specify the name of the dependency (use @Beans(name = "..."), @Component("myComp"))
@Bean - can be used on methods, by default the beans's name is the name of the method
@Resource - takes a name attribute, and by default Spring interprets that value as the bean name to be injected. 
			In other words, it follows by-name semantics, like this:
				@Resource(name="myMovieFinder")
				public void setMovieFinder(MovieFinder movieFinder) {
					this.movieFinder = movieFinder;
				}
@Component and further stereotype annotations: @Service, @Repository, @Controller
@Component: is a generic stereotype for any Spring-managed component.
@Repository annotation is a marker for any class that fulfills the role or stereotype of a repository (also known as Data Access Object or DAO). 
	Among the uses of this marker is the automatic translation of exceptions as described in Section 20.2.2, “Exception translation”.
	(unchecked exceptions for @Transactional to rollback the commit)

	
7.10.3 Automatically detecting classes and registering bean definitions
	To autodetect these classes and register the corresponding beans, you need to add @ComponentScan to your @Configuration class, 
	where the basePackages attribute is a common parent package for the two classes. 
	If basePackages is not specified on the @ComponentScan, then the package of the class it is applied on gets used.
	
7.10.4 Using filters to customize scanning

7.10.5 Defining metadata
	@Bean, @Lazy, @Qualifier, @Scope can be used together

	@Service("myMovieLister")
	public class SimpleMovieLister - bean's name is "myMovieLister"

	@Repository
	public class MovieFinderImpl - bean's name is "movieFinderImpl"


7.11 Using JSR 330 Standard Annotations
	@Inject vs @Autowired
	@Named vs @Component - the two are identical
	
	
7.11.3 Limitations of JSR-330 standard annotations

7.12 Java-based container configuration
	The central artifacts in Spring’s new Java-configuration support are @Configuration-annotated classes and @Bean-annotated methods.
	
	@Bean - method-level annotation and is used to indicate that a method instantiates, configures and initializes a new component that gets stored in the spring container
			to be managed by the Spring IoC container.
		  - spring intercepts the @Bean methods and invokes the container first
			- @Bean methods can call each other and Spring ensures the correct behavior - the bean is returned from the container if already registered,
			  otherwise the specified @Bean factory method is invoked
	@Bean(initMethod = "init")
	@Bean(destroyMethod = "cleanup")
	@Configuration - indicates that its primary purpose is as a source of bean definitions. 
					 Furthermore, @Configuration classes allow inter-bean dependencies to be defined by simply calling other 
					 @Bean methods in the same class. 
					 
		
	Full @Configuration vs 'lite' @Beans mode?
	When @Bean methods are declared within classes that are not annotated with @Configuration they are referred to as being processed in a 'lite' mode.
	For example, bean methods declared in a @Component or even in a plain old class will be considered 'lite'.
	Unlike full @Configuration, lite @Bean methods cannot easily declare inter-bean dependencies. 
	Usually one @Bean method should not invoke another @Bean method when operating in 'lite' mode.
	Only using @Bean methods within @Configuration classes is a recommended approach of ensuring that 'full' mode is always used. 
	This will prevent the same @Bean method from accidentally being invoked multiple times and helps to reduce subtle bugs that can be hard 
	to track down when operating in 'lite' mode.

	@Import - annotation allows for loading @Bean definitions from another configuration class
	
Conditionally include @Configuration classes or @Bean methods
	It is often useful to conditionally enable or disable a complete @Configuration class, or even individual @Bean methods, 
	based on some arbitrary system state.
	
	@Profile - activate @Bean beans from a configuration class at startup only - scan the @Configuration class only - when a specific profile has been enabled in the Spring Environment
		spring.profiles=dev,prod			(application-dev.properties, application-prod.yml)
		spring.profiles.active=dev
	@Conditional, @ConditionalOnClass, @ConditionalOnMissingClass, @ConditionalOnBean, @ConditionalOnMissingBean, ...
	
	
Configuration injection

	@Configuration
	@ConfigurationProperties(prefix = "spring.dsMsSQL")
	public class MsSQLDataSourceConfiguration extends DatabaseConfig {
		// DatabaseConfig's fields are propagated with config properties from application.properties that match the prefix
		// like spring.dsMsSQL.password <--- "password" field gets filled with the value of this
		
		@Bean
		public SqlSessionFactoryBean mssqlSessionFactory() throws SQLException {
			SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();
			factoryBean.setDataSource(mssqlDataSource());
			return factoryBean;
		}
	}

	@Configuration
	@PropertySource("classpath:neo4j.properties")
	public class Neo4jConfig {
		@Autowired
		Environment environment;
	}
	
	@PropertySource - provides a convenient and declarative mechanism for adding a PropertySource to Spring’s Environment
	
	
7.15.1 Internationalization using MessageSource

	MessageSource, HierarchicalMessageSource interfaces
	
	
8.2 The Resource interface

	Spring’s Resource interface is meant to be a more capable interface for abstracting access to low-level resources.
	
	UrlResource: The UrlResource wraps a java.net.URL, and may be used to access any object that is normally accessible via a URL, 
				 such as files, an HTTP target, an FTP target, etc.
	ClassPathResource
	FileSystemResource: his is a Resource implementation for java.io.File handles. It obviously supports resolution as a File, and as a URL.
	ServletContextResource
	InputStreamResource
	ByteArrayResource
	
	ResourceLoader: The ResourceLoader interface is meant to be implemented by objects that can return (i.e. load) Resource instances.
		Resource template = ctx.getResource("classpath:some/resource/path/myTemplate.txt");
		Resource template = ctx.getResource("file:///some/resource/path/myTemplate.txt");
		Resource template = ctx.getResource("http://myhost.com/resource/path/myTemplate.txt");
		
		
9. Validation, Data Binding, and Type Conversion
		
	Spring Framework 4.0 supports Bean Validation 1.0 (JSR-303) and Bean Validation 1.1 (JSR-349) in terms of setup support, 
	also adapting it to Spring’s Validator interface.
	
9.5.1 Converter SPI
	org.springframework.core.convert.converter.Converter interface
	
11. Aspect Oriented Programming with Spring
	Aspect: a modularization of a concern that cuts across multiple classes. Transaction management is a good example of a crosscutting 
			concern in enterprise Java applications. In Spring AOP, aspects are implemented using regular classes 
			(the schema-based approach) or regular classes annotated with the @Aspect annotation (the @AspectJ style).
	Join point: a point during the execution of a program, such as the execution of a method or the handling of an exception. 
			In Spring AOP, a join point always represents a method execution.
	Advice: action taken by an aspect at a particular join point. Different types of advice include "around," "before" and "after" advice.
			(Advice types are discussed below.) Many AOP frameworks, including Spring, model an advice as an interceptor, maintaining a chain 
			of interceptors around the join point.
	Pointcut: a predicate that matches join points. Advice is associated with a pointcut expression and runs at any join point matched by 
			the pointcut (for example, the execution of a method with a certain name). The concept of join points as matched by pointcut 
			expressions is central to AOP, and Spring uses the AspectJ pointcut expression language by default.
	Introduction: declaring additional methods or fields on behalf of a type. Spring AOP allows you to introduce new interfaces 
			(and a corresponding implementation) to any advised object. For example, you could use an introduction to make a bean implement 
			an IsModified interface, to simplify caching. (An introduction is known as an inter-type declaration in the AspectJ community.)
	Target object: object being advised by one or more aspects. Also referred to as the advised object. Since Spring AOP is implemented 
			using runtime proxies, this object will always be a proxied object.
	AOP proxy: an object created by the AOP framework in order to implement the aspect contracts (advise method executions and so on). 
			In the Spring Framework, an AOP proxy will be a JDK dynamic proxy or a CGLIB proxy.
	Weaving: linking aspects with other application types or objects to create an advised object. This can be done at compile time 
			(using the AspectJ compiler, for example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks, 
			performs weaving at runtime.
	
	
	Types of advice:
		Before advice: Advice that executes before a join point, but which does not have the ability to prevent execution 
			flow proceeding to the join point (unless it throws an exception).
		After returning advice: Advice to be executed after a join point completes normally: for example, if a method returns without
			throwing an exception.
		After throwing advice: Advice to be executed if a method exits by throwing an exception.
		After (finally) advice: Advice to be executed regardless of the means by which a join point exits (normal or exceptional return).
		Around advice: Advice that surrounds a join point such as a method invocation. This is the most powerful kind of advice. 
			Around advice can perform custom behavior before and after the method invocation. It is also responsible for choosing 
			whether to proceed to the join point or to shortcut the advised method execution by returning its own return value or 
			throwing an exception.
			
	@Configuration
	@EnableAspectJAutoProxy
	public class AppConfig {
	}
	
	@Aspect
	public class NotVeryUsefulAspect {
	
		@Pointcut("execution(public * *(..))")
		private void anyPublicOperation() {}

		@Pointcut("within(com.xyz.someapp.trading..*)")
		private void inTrading() {}

		@Pointcut("anyPublicOperation() && inTrading()")
		private void tradingOperation() {}
		
		@Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
		public void doAccessCheck() {
		}
		
		@AfterReturning("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
		public void doAccessCheck() {
		}
		
		@AfterReturning(pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()", returning="retVal")
		public void doAccessCheck(Object retVal) {
		}
		
		@AfterThrowing("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
		public void doRecoveryActions() {
		}
	
		@After("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
		public void doReleaseLock() {
		}
	
		@Around("com.xyz.myapp.SystemArchitecture.businessService()")
		public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {
			// start stopwatch
			Object retVal = pjp.proceed();
			// stop stopwatch
			return retVal;
    }
}


Transaction Management

	PlatformTransactionManager: JtaTransactionManager, HibernateTransactionManager
	
17.4.2 Low-level synchronization approach

	DataSourceUtils (for JDBC), EntityManagerFactoryUtils (for JPA), SessionFactoryUtils, PersistenceManagerFactoryUtils (for JDO)
	
	For example, in the case of JDBC, instead of the traditional JDBC approach of calling the getConnection() method on the DataSource, 
	you instead use Spring’s org.springframework.jdbc.datasource.DataSourceUtils class as follows:
		Connection conn = DataSourceUtils.getConnection(dataSource);
		
	@Transactional - declarative transaction support are that this support is enabled via AOP proxies
	
		- Propagation setting is REQUIRED.
		- Isolation level is DEFAULT.
		- Transaction is read/write. - not read-only by default
		- Transaction timeout defaults to the default timeout of the underlying transaction system, or none if timeouts are not supported.
		- Any RuntimeException triggers rollback, and any checked Exception does not.
		
		When using proxies, you should apply the @Transactional annotation only to methods with public visibility. 
		If you do annotate protected, private or package-visible methods with the @Transactional annotation, no error is raised, 
		but the annotated method does not exhibit the configured transactional settings. 
		Consider the use of AspectJ (see below) if you need to annotate non-public methods.
		
		Spring recommends that you only annotate concrete classes (and methods of concrete classes) with the @Transactional annotation, as opposed 
		to annotating interfaces. You certainly can place the @Transactional annotation on an interface (or an interface method), but this works only 
		as you would expect it to if you are using interface-based proxies. The fact that Java annotations are not inherited from interfaces means that
		if you are using class-based proxies ( proxy-target-class="true") or the weaving-based aspect ( mode="aspectj"), then the transaction 
		settings are not recognized by the proxying and weaving infrastructure, and the object will not be wrapped in a transactional proxy, 
		which would be decidedly bad.
		
		In proxy mode (which is the default), only external method calls coming in through the proxy are intercepted. This means that 
		self-invocation, in effect, a method within the target object calling another method of the target object, will not lead to an
		actual transaction at runtime even if the invoked method is marked with @Transactional. Also, the proxy must be fully initialized
		to provide the expected behaviour so you should not rely on this feature in your initialization code, i.e. @PostConstruct.
		
		Consider the use of AspectJ mode (see mode attribute in table below) if you expect self-invocations to be wrapped with transactions
		as well. In this case, there will not be a proxy in the first place; instead, the target class will be weaved (that is, its byte 
		code will be modified) in order to turn @Transactional into runtime behavior on any kind of method.


		If you find you are repeatedly using the same attributes with @Transactional on many different methods, then 
		Spring’s meta-annotation support allows you to define custom shortcut annotations for your specific use cases. 
		For example, defining the following annotations		
			@Target({ElementType.METHOD, ElementType.TYPE})
			@Retention(RetentionPolicy.RUNTIME)
			@Transactional("account")
			public @interface AccountTx {
			}
			
			
17.5.7 Transaction propagation
	PROPAGATION_REQUIRED: However, in the case where an inner transaction scope sets the rollback-only marker, the outer transaction has not decided on 
		the rollback itself, and so the rollback (silently triggered by the inner transaction scope) is unexpected. 
		A corresponding UnexpectedRollbackException is thrown at that point. 
	PROPAGATION_REQUIRES_NEW: uses a completely independent transaction for each affected transaction scope. In that case, the underlying 
		physical transactions are different and hence can commit or roll back independently, with an outer transaction not affected by an 
		inner transaction’s rollback status.
	PROPAGATION_NESTED : uses a single physical transaction with multiple savepoints that it can roll back to. Such partial rollbacks 
		allow an inner transaction scope to trigger a rollback for its scope, with the outer transaction being able to continue the physical 
		transaction despite some operations having been rolled back. This setting is typically mapped onto JDBC savepoints, so will only work 
		with JDBC resource transactions. See Spring’s DataSourceTransactionManager.
			
			
17.6 Programmatic transaction management

	Using the TransactionTemplate.
	Using a PlatformTransactionManager implementation directly.
	
18.3 Annotations used for configuring DAO or Repository classes
	@Repository
	Any DAO or repository implementation will need to access to a persistence resource, depending on the persistence technology used; 
	for example, a JDBC-based repository will need access to a JDBC DataSource; a JPA-based repository will need access to an EntityManager. 
	The easiest way to accomplish this is to have this resource dependency injected using one of the
	@Autowired,, @Inject, @Resource or @PersistenceContext annotations. Here is an example for a JPA repository:
	
	@Repository
	public class JpaMovieFinder implements MovieFinder {
    @PersistenceContext
		private EntityManager entityManager;
	}
	
	
DataSource
	DriverManagerDataSource dataSource = new DriverManagerDataSource();
	dataSource.setDriverClassName("org.hsqldb.jdbcDriver");
	dataSource.setUrl("jdbc:hsqldb:hsql://localhost:");
	dataSource.setUsername("sa");
	dataSource.setPassword("");
	
	Only use the DriverManagerDataSource class should only be used for testing purposes since it does not provide pooling and will perform poorly 
	when multiple requests for a connection are made.
	Always use the DataSource provided by the container via JNDI
	

	DataSourceUtils
		The DataSourceUtils class is a convenient and powerful helper class that provides static methods to obtain connections from JNDI 
		and close connections if necessary. It supports thread-bound connections with, for example, DataSourceTransactionManager.
	
	
	JPA: 3 ways to set up JPA with spring: LocalEntityManagerFactoryBean, EntityManagerFactory from JNDI, LocalContainerEntityManagerFactoryBean
		Use this latter option for full JPA capabilities in a Spring-based application environment. 
	
	
21.2 Marshaller and Unmarshaller
	As stated in the introduction, a marshaller serializes an object to XML, and an unmarshaller deserializes XML stream to an object. 
	In this section, we will describe the two Spring interfaces used for this purpose.
	

********************************
Spring MVC:
********************************

	It looks like the 1st folder inside the src/main/resources gets served automatically. 
	However with @RequestMapping and viewtechnology (like thymeleaf) used together it is possible to manipulate which html gets sent for which request.
	For example: localhost:8080/index.html and localhost:8080 can return the same content!

	The WebMvcConfigurerAdapter is for configuring Spring MVC, the replacement of the xml file loaded by the 
		DispatcherServlet for configuring Spring MVC. The WebMvcConfigurerAdapter should be used for a @Configuration class.
		@EnableWebMvc //<mvc:annotation-driven />
		@Configuration
		@ComponentScan({ "com.mkyong.helloworld.web" })
		public class SpringWebConfig extends WebMvcConfigurerAdapter

	ServletInitializer: necessary in order for Spring to generate web.xml (project is dynamic webproject and packaging is war - app is deployed to an existing servlet container)
						Without this the war is either not generated or doesn’t work at all (not sure what Gabor said)
						however probably this can be omitted by using "AbstractAnnotationConfigDispatcherServletInitializer" as demonstrated above

	AbstractAnnotationConfigDispatcherServletInitializer (ServletInitializer) is the replacement of web.xml. Initializes the servlet container.
	public class MyWebInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

		@Override
		protected Class<?>[] getRootConfigClasses() {
			return new Class[] { SpringRootConfig.class };
		}

		@Override
		protected Class<?>[] getServletConfigClasses() {
			return new Class[] { SpringWebConfig.class };
		}

		@Override
		protected String[] getServletMappings() {
			return new String[] { "/" };
		}
	}


	WebDataBinder binds custom validators.
	To do this, we create a method in controller and annotate it with @InitBinder which plays the role to identify WebDataBinder method in our controller.


	Controller:

		// this is used to add stuff to spring's model and it ultimately goes into the HttpServletRequest object after the handler executes
		@ModelAttribute("myRequestObject")
		public MyCommandBean addStuffToRequestScope() {
			System.out.println("Inside of addStuffToRequestScope");
			MyCommandBean bean = new MyCommandBean("Hello World",42);
			return bean;
		}
		
		@ModelAttribute refers to a property of the Model object (the M in MVC ;) so let's say we have a form with a form backing object that is called "Person" 
		Then you can have Spring MVC supply this object to a Controller method by using the @ModelAttribute annotation:

		public String processForm(@ModelAttribute("person") Person person){
			person.getStuff();
		}
		Check here for an example (Spring 2.5), also see "Using @ModelAttribute on a method argument" (Spring 3.1).

		On the other hand the annotation is used to define objects which should be part of a Model. So if you want to have a Person object referenced in the Model you can use the following method:
		@ModelAttribute("person")
		public Person getPerson(){
			return new Person();
		}

	@Valid asks spring to validate the associated object(Employee). 
	BindingResult contains the outcome of this validation and any error that might have occurred during this validation. 
	Notice that BindingResult must come right after the validated object else spring won’t be able to validate and an exception been thrown.
	Custom errors can be added to the BindingResult: bindingResult.addError(new FieldError(...));		
	
	
SessionAuthenticationStrategy
	Allows pluggable support for HttpSession-related behaviour when an authentication occurs.
	Typical use would be to make sure a session exists or to change the session Id to guard against session-fixation attacks.


22. Web MVC framework

	The Spring Web model-view-controller (MVC) framework is designed around a DispatcherServlet that dispatches requests to handlers, 
	with configurable handler mappings, view resolution, locale, time zone and theme resolution as well as support for uploading files.
	
	Spring’s view resolution is extremely flexible. A Controller is typically responsible for preparing a model Map with data 
	and selecting a view name but it can also write directly to the response stream and complete the request. @Controller, @ResponseBody or just @Restcontroller
	
	View name resolution is highly configurable through file extension or Accept header content type negotiation, through bean names, 
	a properties file, or even a custom ViewResolver implementation. The model (the M in MVC) is a Map interface, which allows for 
	the complete abstraction of the view technology. You can integrate directly with template based rendering technologies such as JSP, 
	Velocity and Freemarker, or directly generate XML, JSON, Atom, and many other types of content. The model Map is simply transformed 
	into an appropriate format, such as JSP request attributes, a Velocity template model.
	
	
DispatcherServlet
	Spring’s web MVC framework is, like many other web MVC frameworks, request-driven, designed around a central Servlet that 
	dispatches requests to controllers and offers other functionality that facilitates the development of web applications. 
	Spring’s DispatcherServlet however, does more than just that. It is completely integrated with the Spring IoC container and as 
	such allows you to use every other feature that Spring has.
	
	The DispatcherServlet is an actual Servlet (it inherits from the HttpServlet base class), and as such is declared in your web application. 
	You need to map requests that you want the DispatcherServlet to handle, by using a URL mapping. Here is a standard Java EE Servlet 
	configuration in a Servlet 3.0+ environment
	
	public class MyWebApplicationInitializer implements WebApplicationInitializer {
		@Override
		public void onStartup(ServletContext container) {
			ServletRegistration.Dynamic registration = container.addServlet("dispatcher", new DispatcherServlet());
			registration.setLoadOnStartup(1);
			registration.addMapping("/example/*");
		}
	}
	
	WebApplicationInitializer is an interface provided by Spring MVC that ensures your code-based configuration is detected and automatically 
	used to initialize any Servlet 3 container.
	
	As detailed in Section 7.15, “Additional Capabilities of the ApplicationContext”, ApplicationContext instances in Spring can be scoped.
	n the Web MVC framework, each DispatcherServlet has its own WebApplicationContext, which inherits all the beans already defined in the root
	WebApplicationContext. The root WebApplicationContext should contain all the infrastructure beans that should be shared 
	between your other contexts and Servlet instances. These inherited beans can be overridden in the servlet-specific scope, and 
	you can define new scope-specific beans local to a given Servlet instance.
	
	
	Upon initialization of a DispatcherServlet, Spring MVC looks for a file named [servlet-name]-servlet.xml in the WEB-INF directory 
	of your web application and creates the beans defined there, overriding the definitions of any beans defined with the same name in the
	global scope.
	Consider the following DispatcherServlet Servlet configuration (in the web.xml file):
	<web-app>
		<servlet>
			<servlet-name>golfing</servlet-name>
			<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
			<load-on-startup>1</load-on-startup>
		</servlet>
		<servlet-mapping>
			<servlet-name>golfing</servlet-name>
			<url-pattern>/golfing/*</url-pattern>
		</servlet-mapping>
	</web-app>
	With the above Servlet configuration in place, you will need to have a file called /WEB-INF/golfing-servlet.xml in your application; 
	this file will contain all of your Spring Web MVC-specific components (beans).
	
	
	It is also possible to have just one root context for single DispatcherServlet scenarios.
	<web-app>
		<context-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>/WEB-INF/root-context.xml</param-value>
		</context-param>
		<servlet>
			<servlet-name>dispatcher</servlet-name>
			<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
			<init-param>
				<param-name>contextConfigLocation</param-name>
				<param-value></param-value>
			</init-param>
			<load-on-startup>1</load-on-startup>
		</servlet>
		<servlet-mapping>
			<servlet-name>dispatcher</servlet-name>
			<url-pattern>/*</url-pattern>
		</servlet-mapping>
		<listener>
			<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
		</listener>
	</web-app>
	
	
	
	
	Instead of xml this can be achieved by using java-based configurations:
	public class GolfingWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
		@Override
		protected Class<?>[] getRootConfigClasses() {
			// GolfingAppConfig defines beans that would be in root-context.xml
			return new Class[] { GolfingAppConfig.class };
		}
		@Override
		protected Class<?>[] getServletConfigClasses() {
			// GolfingWebConfig defines beans that would be in golfing-servlet.xml
			return new Class[] { GolfingWebConfig.class };
		}
		@Override
		protected String[] getServletMappings() {
			return new String[] { "/golfing/*" };
		}
	}
	
22.1. Special bean types in the WebApplicationContext
	
	HandlerMapping
	ViewResolver - Resolves logical String-based view names to actual View types.
	LocaleResolver & LocaleContextResolver - Resolves the locale a client is using and possibly their time zone, in order to be able to offer internationalized views
	MultipartResolver - Parses multi-part requests for example to support processing file uploads from HTML forms.
	FlashMapManager - Stores and retrieves the "input" and the "output" FlashMap that can be used to pass attributes from one request to another, usually across a redirect.
	
	
22.3.2 Mapping Requests With @RequestMapping
	@GetMapping("/owners/{ownerId}")
	public String findOwner(@PathVariable String ownerId, Model model) {	
	
	/owners/*/pets/{petId})
	
	When a URL matches multiple patterns, a sort is used to find the most specific match.
		If two patterns have the same count, the one that is longer is considered more specific. For example /foo/bar* is longer and considered more specific than /foo/*.
		The default mapping pattern /** is less specific than any other pattern. For example /api/{a}/{b}/{c} is more specific
		
	Path Patterns with Placeholders

	Patterns in @RequestMapping annotations support ${…​} placeholders against local properties and/or system properties and 
		variables. This may be useful in cases where the path a controller is mapped to may need to be customized through configuration. 
		For more information on placeholders, see the javadocs of the PropertyPlaceholderConfigurer class.
 
	By default Spring MVC performs ".*" suffix pattern matching so that a controller mapped to /person is also implicitly mapped to /person.*. 
		This makes it easy to request different representations of a resource through the URL path (e.g. /person.pdf, /person.xml).


Matrix variables
			// GET /pets/42;q=11;r=22
			@GetMapping("/pets/{petId}")
			public void findPet(@PathVariable String petId, @MatrixVariable int q) {
				// petId == 42
				// q == 11
			}
			
			// GET /owners/42;q=11/pets/21;q=22
			@GetMapping("/owners/{ownerId}/pets/{petId}")
			public void findPet(
					@MatrixVariable(name="q", pathVar="ownerId") int q1,
					@MatrixVariable(name="q", pathVar="petId") int q2) {
				// q1 == 11
				// q2 == 22
			}
			
Consumable Media Types
	@PostMapping(path = "/pets", consumes = "application/json")
	
Producible Media Types
	@GetMapping(path = "/pets/{petId}", produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
	
Request Parameters and Header Values
	You can narrow request matching through request parameter conditions such as "myParam", "!myParam", or "myParam=myValue". 
	The first two test for request parameter presence/absence and the third for a specific parameter value.
	Here is an example with a request parameter value condition:
	
	@GetMapping(path = "/pets/{petId}", params = "myParam=myValue")
    public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) {
	
	@GetMapping
    public String setupForm(@RequestParam("petId") int petId, ModelMap model) {
	When an @RequestParam annotation is used on a Map<String, String> or MultiValueMap<String, String> argument, the map is populated with all request parameters.
	
	@PutMapping("/something")
	public void handle(@RequestBody String body, Writer writer) throws IOException {
	
	The @ResponseBody annotation is similar to @RequestBody. This annotation can be placed on a method and indicates that the return 
		type should be written straight to the HTTP response body (and not placed in a Model, or interpreted as a view name). For example:
	@GetMapping("/something")
	@ResponseBody
	public String helloWorld() {
		return "Hello World";
	}
	
	@RequestMapping("/something")
	public ResponseEntity<String> handle(HttpEntity<byte[]> requestEntity) throws UnsupportedEncodingException {
		String requestHeader = requestEntity.getHeaders().getFirst("MyRequestHeader"));
		byte[] requestBody = requestEntity.getBody();

		// do something with request header and body

		HttpHeaders responseHeaders = new HttpHeaders();
		responseHeaders.set("MyResponseHeader", "MyValue");
		return new ResponseEntity<String>("Hello World", responseHeaders, HttpStatus.CREATED);
	}
	

Supported method argument types
	Request or response objects (Servlet API). Choose any specific request or response type, for example ServletRequest or HttpServletRequest.
	Session object (Servlet API): of type HttpSession.
	org.springframework.web.context.request.WebRequest or org.springframework.web.context.request.NativeWebRequest. Allows for generic request parameter access as well as request/session attribute access, without ties to the native Servlet/Portlet API.
	java.util.Locale for the current request locale, determined by the most specific locale resolver available, in effect, the configured LocaleResolver / LocaleContextResolver in an MVC environment.
	java.util.TimeZone (Java 6+) / java.time.ZoneId (on Java 8) for the time zone associated with the current request, as determined by a LocaleContextResolver.
	java.io.InputStream / java.io.Reader for access to the request’s content. This value is the raw InputStream/Reader as exposed by the Servlet API.
	java.io.OutputStream / java.io.Writer for generating the response’s content. This value is the raw OutputStream/Writer as exposed by the Servlet API.
	org.springframework.http.HttpMethod for the HTTP request method.
	java.security.Principal containing the currently authenticated user.
	@PathVariable annotated parameters for access to URI template variables. See the section called “URI Template Patterns”.
	@MatrixVariable annotated parameters for access to name-value pairs located in URI path segments. See the section called “Matrix Variables”.
	@RequestParam annotated parameters for access to specific Servlet request parameters. Parameter values are converted to the declared method argument type. See the section called “Binding request parameters to method parameters with @RequestParam”.
	@RequestHeader annotated parameters for access to specific Servlet request HTTP headers. Parameter values are converted to the declared method argument type. See the section called “Mapping request header attributes with the @RequestHeader annotation”.
	@RequestBody annotated parameters for access to the HTTP request body. Parameter values are converted to the declared method argument type using HttpMessageConverters. See the section called “Mapping the request body with the @RequestBody annotation”.
	@RequestPart annotated parameters for access to the content of a "multipart/form-data" request part. See Section 22.10.5, “Handling a file upload request from programmatic clients” and Section 22.10, “Spring’s multipart (file upload) support”.
	@SessionAttribute annotated parameters for access to existing, permanent session attributes (e.g. user authentication object) as opposed to model attributes temporarily stored in the session as part of a controller workflow via @SessionAttributes.
	@RequestAttribute annotated parameters for access to request attributes.
	HttpEntity<?> parameters for access to the Servlet request HTTP headers and contents. The request stream will be converted to the entity body using HttpMessageConverters. See the section called “Using HttpEntity”.
	java.util.Map / org.springframework.ui.Model / org.springframework.ui.ModelMap for enriching the implicit model that is exposed to the web view.
	org.springframework.web.servlet.mvc.support.RedirectAttributes to specify the exact set of attributes to use in case of a redirect and also to add flash attributes (attributes stored temporarily on the server-side to make them available to the request after the redirect). See the section called “Passing Data To the Redirect Target” and Section 22.6, “Using flash attributes”.
	Command or form objects to bind request parameters to bean properties (via setters) or directly to fields, with customizable type conversion, depending on @InitBinder methods and/or the HandlerAdapter configuration. See the webBindingInitializer property on RequestMappingHandlerAdapter. Such command objects along with their validation results will be exposed as model attributes by default, using the command class name - e.g. model attribute "orderAddress" for a command object of type "some.package.OrderAddress". The ModelAttribute annotation can be used on a method argument to customize the model attribute name used.
	org.springframework.validation.Errors / org.springframework.validation.BindingResult validation results for a preceding command or form object (the immediately preceding method argument).
	org.springframework.web.bind.support.SessionStatus status handle for marking form processing as complete, which triggers the cleanup of session attributes that have been indicated by the @SessionAttributes annotation at the handler type level.
	org.springframework.web.util.UriComponentsBuilder a builder for preparing a URL relative to the current request’s host, port, scheme, context path, and the literal part of the servlet mapping.
	
Supported method return types
	A ModelAndView object, with the model implicitly enriched with command objects and the results of @ModelAttribute annotated reference data accessor methods.
	A Model object, with the view name implicitly determined through a RequestToViewNameTranslator and the model implicitly enriched with command objects and the results of @ModelAttribute annotated reference data accessor methods.
	A Map object for exposing a model, with the view name implicitly determined through a RequestToViewNameTranslator and the model implicitly enriched with command objects and the results of @ModelAttribute annotated reference data accessor methods.
	A View object, with the model implicitly determined through command objects and @ModelAttribute annotated reference data accessor methods. The handler method may also programmatically enrich the model by declaring a Model argument (see above).
	A String value that is interpreted as the logical view name, with the model implicitly determined through command objects and @ModelAttribute annotated reference data accessor methods. The handler method may also programmatically enrich the model by declaring a Model argument (see above).
	void if the method handles the response itself (by writing the response content directly, declaring an argument of type ServletResponse / HttpServletResponse for that purpose) or if the view name is supposed to be implicitly determined through a RequestToViewNameTranslator (not declaring a response argument in the handler method signature).
	If the method is annotated with @ResponseBody, the return type is written to the response HTTP body. The return value will be converted to the declared method argument type using HttpMessageConverters. See the section called “Mapping the response body with the @ResponseBody annotation”.
	An HttpEntity<?> or ResponseEntity<?> object to provide access to the Servlet response HTTP headers and contents. The entity body will be converted to the response stream using HttpMessageConverters. See the section called “Using HttpEntity”.
	An HttpHeaders object to return a response with no body.
	A Callable<?> can be returned when the application wants to produce the return value asynchronously in a thread managed by Spring MVC.
	A DeferredResult<?> can be returned when the application wants to produce the return value from a thread of its own choosing.
	A ListenableFuture<?> can be returned when the application wants to produce the return value from a thread of its own choosing.
	A ResponseBodyEmitter can be returned to write multiple objects to the response asynchronously; also supported as the body within a ResponseEntity.
	An SseEmitter can be returned to write Server-Sent Events to the response asynchronously; also supported as the body within a ResponseEntity.
	A StreamingResponseBody can be returned to write to the response OutputStream asynchronously; also supported as the body within a ResponseEntity.
	Any other return type is considered to be a single model attribute to be exposed to the view, using the attribute name specified through @ModelAttribute at the method level (or the default attribute name based on the return type class name). The model is implicitly enriched with command objects and the results of @ModelAttribute annotated reference data accessor methods.	
	

	Using @ModelAttribute on a method

		The @ModelAttribute annotation can be used on methods or on method arguments. 
		This section explains its usage on methods while the next section explains its usage on method arguments.
		
		// Add one attribute
		// The return value of the method is added to the model under the name "account"
		// You can customize the name via @ModelAttribute("myAccount")
		// each route will its model populated with the Account object
		@ModelAttribute
		public Account addAccount(@RequestParam String number) {
			return accountManager.findAccount(number);
		}

		// Add multiple attributes

		@ModelAttribute
		public void populateModel(@RequestParam String number, Model model) {
			model.addAttribute(accountManager.findAccount(number));
			// add more ...
		}
		@ModelAttribute methods are used to populate the model with commonly needed attributes for example to fill a drop-down with 
		states or with pet types, or to retrieve a command object like Account in order to use it to represent the data on an HTML form. 
		The latter case is further discussed in the next section.
		A controller can have any number of @ModelAttribute methods. All such methods are invoked before @RequestMapping methods of the same controller.
	
	Using @ModelAttribute on a method argument
	
		PostMapping("/owners/{ownerId}/pets/{petId}/edit")
		public String processSubmit(@ModelAttribute Pet pet) { }
		
		An @ModelAttribute on a method argument indicates the argument should be retrieved from the model. 
		If not present in the model, the argument should be instantiated first and then added to the model. 
		Once present in the model, the argument’s fields should be populated from all request parameters that have matching names. 
		This is known as data binding in Spring MVC, a very useful mechanism that saves you from having to parse each form field individually.
	
	
	Note that in some cases it may be useful to gain access to an attribute in the model without data binding. 
	For such cases you may inject the Model into the controller or alternatively use the binding flag on the annotation:
		@ModelAttribute
		public AccountForm setUpForm() {
			return new AccountForm();
		}
		
		@ModelAttribute
		public Account findAccount(@PathVariable String accountId) {
			return accountRepository.findOne(accountId);
		}

		@PostMapping("update")
		public String update(@Valid AccountUpdateForm form, BindingResult result, @ModelAttribute(binding=false) Account account) {

			// ...
		}
	
	n addition to data binding you can also invoke validation using your own custom validator passing the same BindingResult that was used to 
	record data binding errors. That allows for data binding and validation errors to be accumulated in one place and subsequently reported back 
	to the user:
		@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
		public String processSubmit(@ModelAttribute("pet") Pet pet, BindingResult result) {

			new PetValidator().validate(pet, result);
			if (result.hasErrors()) {
				return "petForm";
			}
			// ...
		}
		
		Or you can have validation invoked automatically by adding the JSR-303 @Valid annotation:
		@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
		public String processSubmit(@Valid @ModelAttribute("pet") Pet pet, BindingResult result) {
			if (result.hasErrors()) {
				return "petForm";
			}
			// ...
		}
	
Using @SessionAttributes to store model attributes in the HTTP session between requests
	The type-level @SessionAttributes annotation declares session attributes used by a specific handler. 
	This will typically list the names of model attributes or types of model attributes which should be transparently 
	stored in the session or some conversational storage, serving as form-backing beans between subsequent requests.
	@Controller
	@RequestMapping("/editPet.do")
	@SessionAttributes("pet")
	public class EditPetForm {
		// ...
	}
	
Using @SessionAttribute to access pre-existing global session attributes
	@RequestMapping("/")
	public String handle(@SessionAttribute User user) {
		// ...
	}
	
Using @RequestAttribute to access request attributes

Similar to @SessionAttribute the @RequestAttribute annotation can be used to access pre-existing request attributes created by a filter 
	or interceptor:
	@RequestMapping("/")
	public String handle(@RequestAttribute Client client) {
		// ...
	}
	
	
	@CookieValue annotation allows a method parameter to be bound to the value of an HTTP cookie.
		@RequestMapping("/displayHeaderInfo.do")
		public void displayHeaderInfo(@CookieValue("JSESSIONID") String cookie) {
		
	@RequestHeader annotation allows a method parameter to be bound to a request header.
		@RequestMapping("/displayHeaderInfo.do")
		public void displayHeaderInfo(@RequestHeader("Accept-Encoding") String encoding, @RequestHeader("Keep-Alive") long keepAlive) {
		
	@InitBinder - allows you to configure web data binding directly within your controller class
		The following example demonstrates the use of @InitBinder to configure a CustomDateEditor for all java.util.Date form properties.
		@Controller
		public class MyFormController {

			@InitBinder
			protected void initBinder(WebDataBinder binder) {
				SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
				dateFormat.setLenient(false);
				binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
			}

			// ...
		}

Advising controllers with @ControllerAdvice and @RestControllerAdvice

	@ControllerAdvice annotation is a component annotation allowing implementation classes to be auto-detected through classpath scanning. 
	It is automatically enabled when using the MVC namespace or the MVC Java config.
	
	Classes annotated with @ControllerAdvice can contain @ExceptionHandler, @InitBinder, and @ModelAttribute annotated methods, 
	and these methods will apply to @RequestMapping methods across all controller hierarchies as opposed to the controller hierarchy within which they are declared.
	@RestControllerAdvice is an alternative where @ExceptionHandler methods assume @ResponseBody semantics by default.
	Both @ControllerAdvice and @RestControllerAdvice can target a subset of controllers:
	
	// Target all Controllers annotated with @RestController
	@ControllerAdvice(annotations = RestController.class)
	public class AnnotationAdvice {}

	// Target all Controllers within specific packages
	@ControllerAdvice("org.example.controllers")
	public class BasePackageAdvice {}

	// Target all Controllers assignable to specific classes
	@ControllerAdvice(assignableTypes = {ControllerInterface.class, AbstractController.class})
	public class AssignableTypesAdvice {}
	
	
22.3.4 Asynchronous Request Processing
	Spring MVC 3.2 introduced Servlet 3 based asynchronous request processing. 
	Instead of returning a value, as usual, a controller method can now return a java.util.concurrent.Callable and produce the return value 
	from a Spring MVC managed thread. 
	
	@PostMapping
	public Callable<String> processUpload(final MultipartFile file) {
	
	
	Another option is for the controller method to return an instance of DeferredResult. In this case the return value will also be produced
	from any thread, i.e. one that is not managed by Spring MVC. For example the result may be produced in response to some external event
	such as a JMS message, a scheduled task, and so on. Here is an example of such a controller method:
	
		@RequestMapping("/quotes")
		@ResponseBody
		public DeferredResult<String> quotes() {
			DeferredResult<String> deferredResult = new DeferredResult<String>();
			// Save the deferredResult somewhere..
			return deferredResult;
		}

		// In some other thread...
		deferredResult.setResult(data);
		
		
	With the above in mind, the following is the sequence of events for async request processing with a Callable:
		Controller returns a Callable.
		Spring MVC starts asynchronous processing and submits the Callable to a TaskExecutor for processing in a separate thread.
		The DispatcherServlet and all Filter’s exit the Servlet container thread but the response remains open.
		The Callable produces a result and Spring MVC dispatches the request back to the Servlet container to resume processing.
		The DispatcherServlet is invoked again and processing resumes with the asynchronously produced result from the Callable.
		
	The sequence for DeferredResult is very similar except it’s up to the application to produce the asynchronous result from any thread:
		Controller returns a DeferredResult and saves it in some in-memory queue or list where it can be accessed.
		Spring MVC starts async processing.
		The DispatcherServlet and all configured Filter’s exit the request processing thread but the response remains open.
		The application sets the DeferredResult from some thread and Spring MVC dispatches the request back to the Servlet container.
		The DispatcherServlet is invoked again and processing resumes with the asynchronously produced result.
		- But since the Thread is not Spring managed, all thread-context is lost, right? E.g current user, Locale, etc.
		
		
HTTP Streaming
	What if you wanted to push multiple events on a single HTTP response? This is a technique related to "Long Polling" that is 
	known as "HTTP Streaming". Spring MVC makes this possible through the ResponseBodyEmitter return value type which can be used to 
	send multiple Objects, instead of one as is normally the case with @ResponseBody, where each Object sent is written to the response 
	with an HttpMessageConverter.
	
	
	@RequestMapping("/events")
	public ResponseBodyEmitter handle() {
		ResponseBodyEmitter emitter = new ResponseBodyEmitter();
		// Save the emitter somewhere..
		return emitter;
	}
	// In some other thread
	emitter.send("Hello once");

	// and again later on
	emitter.send("Hello again");

	// and done at some point
	emitter.complete();
	
	
HTTP Streaming Directly To The OutputStream
	ResponseBodyEmitter allows sending events by writing Objects to the response through an HttpMessageConverter. 
	This is probably the most common case, for example when writing JSON data. However sometimes it is useful to bypass message 
	conversion and write directly to the response OutputStream for example for a file download. 
	This can be done with the help of the StreamingResponseBody return value type.
	
	@RequestMapping("/download")
	public StreamingResponseBody handle() {
		return new StreamingResponseBody() {
			@Override
			public void writeTo(OutputStream outputStream) throws IOException {
				// write...
			}
		};
	}
	
22.4.1 Intercepting requests with a HandlerInterceptor
	Interceptors located in the handler mapping must implement HandlerInterceptor from the org.springframework.web.servlet package. 
	This interface defines three methods: preHandle(..) is called before the actual handler is executed; postHandle(..) is called after 
	the handler is executed; and afterCompletion(..) is called after the complete request has finished.
	
22.6 Using flash attributes - this is like TempData in .NET
	Flash attributes provide a way for one request to store attributes intended for use in another. 
	This is most commonly needed when redirecting — for example, the Post/Redirect/Get pattern. 
	Flash attributes are saved temporarily before the redirect (typically in the session) to be made 
	available to the request after the redirect and removed immediately.
	
		redirectAttributes.addFlashAttribute("customer", customer); - then the next request which is a GET due to a redirect can access this customer
		return "redirect:showcustomer.html";	
	
	
22.8 Using locales
	Most parts of Spring’s architecture support internationalization, just as the Spring web MVC framework does.
	DispatcherServlet enables you to automatically resolve messages using the client’s locale. This is done with LocaleResolver objects.
	
	AcceptHeaderLocaleResolver, CookieLocaleResolver, SessionLocaleResolver, LocaleChangeInterceptor
	
22.10 Spring’s multipart (file upload) support - this is enabled by default with Spring boot

	 @PostMapping("/form")
    public String handleFormUpload(@RequestParam("name") String name, @RequestParam("file") MultipartFile file) {
	
22.11 Handling exceptions
	HandlerExceptionResolver, @ExceptionHandler
	
	@ControllerAdvice or @Controller
	public class SimpleController {

		// @RequestMapping methods omitted ...

		@ExceptionHandler(IOException.class)
		public ResponseEntity<String> handleIOException(IOException ex) {
			// prepare responseEntity
			return responseEntity;
		}
	}
	
	A business exception can be annotated with @ResponseStatus. When the exception is raised, the ResponseStatusExceptionResolver 
	handles it by setting the status of the response accordingly. 
	
22.14 HTTP caching support
		@Configuration
		@EnableWebMvc
		public class WebConfig extends WebMvcConfigurerAdapter {

			@Override
			public void addResourceHandlers(ResourceHandlerRegistry registry) {
				registry.addResourceHandler("/resources/**")
						.addResourceLocations("/public-resources/")
						.setCacheControl(CacheControl.maxAge(1, TimeUnit.HOURS).cachePublic());
			}

		}
		
22.15 Code-based Servlet container initialization
	public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
		@Override
		protected Class<?>[] getRootConfigClasses() {
			return null;
		}
		@Override
		protected Class<?>[] getServletConfigClasses() {
			return new Class[] { MyWebConfig.class };
		}
		@Override
		protected String[] getServletMappings() {
			return new String[] { "/" };
		}
	}
	
22.16.1 Enabling the MVC Java Config or the MVC XML Namespace
	@Configuration
	@EnableWebMvc
	public class WebConfig extends WebMvcConfigurerAdapter {
		// Override configuration methods..
		@Override
		public void addFormatters(FormatterRegistry registry) {
			// Add formatters and/or converters
		}
	}
	
22.16.4 Validation

	Spring provides a Validator interface that can be used for validation in all layers of an application. 
	In Spring MVC you can configure it for use as a global Validator instance, to be used whenever an @Valid or @Validated 
	controller method argument is encountered, and/or as a local Validator within a controller through an @InitBinder method. 
	Global and local validator instances can be combined to provide composite validation.
	
	Alternatively you can configure your own global Validator instance:
	@Configuration
	@EnableWebMvc
	public class WebConfig extends WebMvcConfigurerAdapter {
		@Override
		public Validator getValidator(); {
			// return "global" validator
		}
	}
	
	To combine global with local validation, simply add one or more local validator(s):
	@Controller
	public class MyController {
		@InitBinder
		protected void initBinder(WebDataBinder binder) {
			binder.addValidators(new FooValidator());
		}
	}
	
I22.16.5 Interceptors

	Interceptors vs Servlet Filters:
		- Interceptors belong to the Spring framework and are executed regarding only @Controller endpoints.
		- Whereas javax.servlet.Filter is executed on each request (even on static resources like css, js, images, etc.)
			Actually this can be tweaked by applying the UrlPattern - in spring boot this can be done via @Bean FilterRegistrationBean
				@Bean
				public FilterRegistrationBean staticResoureFilter() {
					FilterRegistrationBean frb = new FilterRegistrationBean();
					frb.setUrlPatterns(Collections.singleton("/dist/*"));
					frb.setFilter(new StaticResourceFilter());
					return frb;
				}

	@Configuration
	@EnableWebMvc
	public class WebConfig extends WebMvcConfigurerAdapter {

		@Override
		public void addInterceptors(InterceptorRegistry registry) {
			registry.addInterceptor(new LocaleInterceptor());
			registry.addInterceptor(new ThemeInterceptor()).addPathPatterns("/**").excludePathPatterns("/admin/**");
			registry.addInterceptor(new SecurityInterceptor()).addPathPatterns("/secure/*");
		}
		
    	@Override
		public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
			configurer.mediaType("json", MediaType.APPLICATION_JSON);
		}
		
		@Override
		public void addViewControllers(ViewControllerRegistry registry) {
			registry.addViewController("/").setViewName("home");
		}
		
		@Override
		public void configureViewResolvers(ViewResolverRegistry registry) {
			registry.enableContentNegotiation(new MappingJackson2JsonView());
			registry.freeMarker().cache(false);
		}

		@Bean
		public FreeMarkerConfigurer freeMarkerConfigurer() {
			FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
			configurer.setTemplateLoaderPath("/WEB-INF/");
			return configurer;
		}
		
		// 22.16.9 Serving of Resources
   	    @Override
		public void addResourceHandlers(ResourceHandlerRegistry registry) {
			registry.addResourceHandler("/resources/**").addResourceLocations("/public-resources/");
		}
		
		// 22.16.12 Message Converters
	    @Override
		public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
			Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder()
					.indentOutput(true)
					.dateFormat(new SimpleDateFormat("yyyy-MM-dd"))
					.modulesToInstall(new ParameterNamesModule());
			converters.add(new MappingJackson2HttpMessageConverter(builder.build()));
			converters.add(new MappingJackson2XmlHttpMessageConverter(builder.xml().build()));
		}
	}
	
23.10 Document views (PDF/Excel)

	Returning an HTML page isn’t always the best way for the user to view the model output, and Spring makes it simple to generate a PDF document or an 
	Excel spreadsheet dynamically from the model data. The document is the view and will be streamed from the server with the correct content type to 
	In order to use Excel views, you need to add the 'poi' library to your classpath, and for PDF generation, the iText library.
	(hopefully) enable the client PC to run their spreadsheet or PDF viewer application in response.
	
26. WebSocket Support
	This part of the reference documentation covers Spring Framework’s support for WebSocket-style messaging in web applications including use of 
	STOMP as an application level WebSocket sub-protocol.
	
26.1.2 A Messaging Architecture
	Today REST is a widely accepted, understood, and supported architecture for building web applications. It is an architecture that relies on having many 
	URLs (nouns), a handful of HTTP methods (verbs), and other principles such as using hypermedia (links), remaining stateless, etc.

	By contrast a WebSocket application may use a single URL only for the initial HTTP handshake. All messages thereafter share and flow on the same TCP connection. 
	This points to an entirely different, asynchronous, event-driven, messaging architecture. One that is much closer to traditional
	messaging applications (e.g. JMS, AMQP).

	Spring Framework 4 includes a new spring-messaging module with key abstractions from the Spring Integration project such as Message, MessageChannel, MessageHandler,
	and others that can serve as a foundation for such a messaging architecture. The module also includes a set of annotations for mapping messages to methods,
	similar to the Spring MVC annotation based programming model.
	
	
27. CORS Support

	You can add an @CrossOrigin annotation to your @RequestMapping annotated handler method in order to enable CORS on it. 
	By default @CrossOrigin allows all origins and the HTTP methods specified in the @RequestMapping annotation:
	
	@RestController
	@RequestMapping("/account")
	public class AccountController {
		@CrossOrigin
		@RequestMapping("/{id}")
		public Account retrieve(@PathVariable Long id) {
			// ...
		}
	}
	
	It is also possible to enable CORS for the whole controller:
	@CrossOrigin(origins = "http://domain2.com", maxAge = 3600)
	@RestController
	@RequestMapping("/account")
	public class AccountController {
	
	You can even use both controller-level and method-level CORS configurations; Spring will then combine attributes from both annotations to create merged CORS configuration.
	CORS support is enabled for both the retrieve() and the remove() handler methods, and you can also see how you can customize the CORS configuration using @CrossOrigin attributes.
	@CrossOrigin(maxAge = 3600)
	@RestController
	@RequestMapping("/account")
	public class AccountController {

		@CrossOrigin("http://domain2.com")
		@RequestMapping("/{id}")
		public Account retrieve(@PathVariable Long id) {
			// ...
		}

		@RequestMapping(method = RequestMethod.DELETE, path = "/{id}")
		public void remove(@PathVariable Long id) {
			// ...
		}
	}
	
27.3 Global CORS configuration
	@Configuration
	@EnableWebMvc
	public class WebConfig extends WebMvcConfigurerAdapter {

		@Override
		public void addCorsMappings(CorsRegistry registry) {
			registry.addMapping("/api/**")
				.allowedOrigins("http://domain2.com")
				.allowedMethods("PUT", "DELETE")
				.allowedHeaders("header1", "header2", "header3")
				.exposedHeaders("header1", "header2")
				.allowCredentials(false).maxAge(3600);
		}
	}

	
Part VII. Integration

28.5 Web services
	@WebService(serviceName="AccountService")
	public class AccountServiceEndpoint extends SpringBeanAutowiringSupport {

		@Autowired
		private AccountService biz;

		@WebMethod
		public void insertAccount(Account acc) {
			biz.insertAccount(acc);
		}

		@WebMethod
		public Account[] getAccounts(String name) {
			return biz.getAccounts(name);
		}

	}
	
30. JMS

	Asynchronous message processing via annotation:
	@JmsListener - The easiest way to receive a message asynchronously is to use the annotated listener endpoint infrastructure. In a nutshell, it allows you to expose a method of a managed bean as a JMS listener endpoint.
	
	To enable support for @JmsListener annotations add @EnableJms to one of your @Configuration classes.
	@Configuration
	@EnableJms
	public class AppConfig {

		@Bean
		public DefaultJmsListenerContainerFactory jmsListenerContainerFactory() {
			DefaultJmsListenerContainerFactory factory =
					new DefaultJmsListenerContainerFactory();
			factory.setConnectionFactory(connectionFactory());
			factory.setDestinationResolver(destinationResolver());
			factory.setConcurrency("3-10");
			return factory;
		}
	}
	

32. JCA CCI
	Java EE provides a specification to standardize access to enterprise information systems (EIS): the JCA (Java EE Connector Architecture). This specification is divided into several different parts:
		SPI (Service provider interfaces) that the connector provider must implement. 
		CCI (Common Client Interface) that an application can use to interact with the connector and thus communicate with an EIS. 
		
33. Email
	JavaMailSenderImpl sender = new JavaMailSenderImpl();
	sender.setHost("mail.host.com");

	MimeMessage message = sender.createMimeMessage();

	// use the true flag to indicate you need a multipart message
	MimeMessageHelper helper = new MimeMessageHelper(message, true);
	helper.setTo("test@host.com");

	helper.setText("Check out this image!");

	// let's attach the infamous windows Sample file (this time copied to c:/)
	FileSystemResource file = new FileSystemResource(new File("c:/Sample.jpg"));
	helper.addAttachment("CoolImage.jpg", file);

	sender.send(message);

	
34. Task Execution and Scheduling
	The Spring Framework provides abstractions for asynchronous execution and scheduling of tasks with the TaskExecutor and TaskScheduler interfaces, respectively. 
	
	To enable support for @Scheduled and @Async annotations add @EnableScheduling and @EnableAsync to one of your @Configuration classes:
	@Configuration
	@EnableAsync
	@EnableScheduling
	public class AppConfig {
	}
	
	@Scheduled(fixedDelay=5000)
	public void doSomething() {
		// something that should execute periodically
	}
	
	
34.4.3 The @Async Annotation	
	The @Async annotation can be provided on a method so that invocation of that method will occur asynchronously.
	 In other words, the caller will return immediately upon invocation and the actual execution of the method will occur in a task that has been submitted to a Spring TaskExecutor. In the simplest case, the annotation may be applied to a void-returning method.
	 @Async
	void doSomething() {
		// this will be executed asynchronously
	}
	
	@Async
	Future<String> returnSomething(int i) {
		// this will be executed asynchronously
	}

34.4.5 Exception management with @Async
	When an @Async method has a Future typed return value, it is easy to manage an exception that was thrown during the method execution as this exception 
	will be thrown when calling get on the Future result. With a void return type however, the exception is uncaught and cannot be transmitted.
	For those cases, an AsyncUncaughtExceptionHandler can be provided to handle such exceptions.
	
	public class MyAsyncUncaughtExceptionHandler implements AsyncUncaughtExceptionHandler {
		@Override
		public void handleUncaughtException(Throwable ex, Method method, Object... params) {
			// handle exception
		}
	}
	
36. Cache Abstraction
	Cache vs Buffer
		Buffer is used traditionally as an intermediate temporary store for data between a fast and a slow entity. As one party would have to wait for the other 
	affecting performance, the buffer alleviates this by allowing entire blocks of data to move at once rather then in small chunks. The data is written and 
	read only once from the buffer. Furthermore, the buffers are visible to at least one party which is aware of it.
		A cache on the other hand by definition is hidden and neither party is aware that caching occurs.It as well improves performance but does that 
	by allowing the same data to be read multiple times in a fast fashion.
	
	@Cacheable("books")
	public Book findBook(ISBN isbn) {...}
	
37.3

	@AuthenticationPrincipal - Spring injects the current user with this

	@RequestMapping("/messages/inbox")
	public ModelAndView findMessagesForUser(@AuthenticationPrincipal CustomUser customUser) {

		// .. find messags for this user and return them ...
	}
	
	
Localization
	
	src/main/resources/messages.properties
	src/main/resources/messages_{lang}.properties
	
	application.properties: spring.messages.basename=messages	#this is the default

	@Configuration
	public class LocalizationConfig extends WebMvcConfigurerAdapter {
	
		@Bean
		public LocaleResolver localeResolver() {
			SessionLocaleResolver slr = new SessionLocaleResolver();
			slr.setDefaultLocale(Locale.US);
			return slr;
		}
		
		// this is auto-configured by Spring Boot
		@Bean
		public ReloadableResourceBundleMessageSource messageSource() {
			ReloadableResourceBundleMessageSource messageSource = new ReloadableResourceBundleMessageSource();
			messageSource.setBasename("classpath:locale/messages");
			messageSource.setCacheSeconds(3600); //refresh cache once per hour
			return messageSource;
		}
		
		@Bean
		public LocaleChangeInterceptor localeChangeInterceptor() {
			LocaleChangeInterceptor lci = new LocaleChangeInterceptor();
			lci.setParamName("lang");
			return lci;
		}
		
		@Override
		public void addInterceptors(InterceptorRegistry registry) {
			registry.addInterceptor(localeChangeInterceptor());
		}
	}
	
	@Component
	public class Localizer {
	
		private MessageSource messageSource;
		private Localze localze;
		
		@Autowired
		public Localizer(MessageSource messageSource, Locale locale) {
			this.messageSource = messageSource;
			this.locale = locale;
		}
		

		public String getMessage(String id) {
			Locale locale = LocaleContextHolder.getLocale();
			return messageSource.getMessage(id,null,locale);
		}
	}
	

	
********************************
Spring Boot
********************************

To create a deployable war:

	@SpringBootApplication
	public class Application extends SpringBootServletInitializer {

		@Override
		protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
			return application.sources(Application.class);
		}

		public static void main(String[] args) throws Exception {
			SpringApplication.run(Application.class, args);
		}
	}
	
	pom.xml:
		<packaging>war</packaging>
		<build>
			<dependency>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-starter-tomcat</artifactId>
				<scope>provided</scope>
			</dependency>
		</build>
		
	build.gradle:
		apply plugin: 'war'
		dependencies {
			// …
			providedRuntime 'org.springframework.boot:spring-boot-starter-tomcat'
			// …
		}
		
Boot deploy:
	
	when creating a jar, everything just works. application.properties is taken into consideration by spring and configures the embedded tomcat/jetty/undertow accordingly:
		server.contextPath=/VMC			<-- this sets the context path (virtualdirectory) of our app
		server.port=8080				<--- this sets the port of our app
		
		The app will be available on: http://localhost:8080/VMC
		
	If creating then deploying a war file, the "server.contextPath" and "server.port" mean nothing, the servlet container gives the contextPath and port.
	In case of Tomcat the default context path is the war's name, and the port is set in /conf/server.xml. This can be overridden, see java_goodies/Tomcat for more details.
	So we can say that the configs from application.properties starting with "server.*" are only taken into account if the servlet container is embedded.
	

Spring Boot allows you to externalize your configuration so you can work with the same application code in different environments. 
You can use properties files, YAML files, environment variables and command-line arguments to externalize configuration. 
Property values can be injected directly into your beans using the @Value annotation, accessed via Spring’s Environment abstraction or bound to 
structured objects via @ConfigurationProperties.

Boot priorities:
	1. @TestPropertySource annotations on your tests.
	2. Commandline args
	3. Properties from SPRING_APPLICATION_JSON (inline JSON embedded in an environment variable or system property)
	4. ServletConfig init parameters.
	5. ServletContext init parameters.
	6. JNDI attributes from java:comp/env.
	7. Java System properties		- System.getProperty("path.separator");
	8. OS Environment variables		- System.getenv();
	9. A RandomValuePropertySource that only has properties in random.*.
	10. Profile-specific application properties outside of your packaged jar (application-{profile}.properties and YAML variants)
	11. Profile-specific application properties packaged inside your jar (application-{profile}.properties and YAML variants)
	12. Application properties outside of your packaged jar (application.properties and YAML variants).
	13. Application properties packaged inside your jar (application.properties and YAML variants).
	14. @PropertySource annotations on your @Configuration classes. - @PropertySource("classpath:/com/myco/app.properties"), then in the config java file: @Autowired Environment env;
	15. Default properties (specified using SpringApplication.setDefaultProperties).
	
@Component
public class MyBean {

    @Value("${name}")
    private String name;

    // ...

}
	
To run a boot project from the command line with Maven: 
	java -jar XXX.jar
	mvn spring-boot:run
	mvn spring-boot:run --debug
	
With Gradle:
	gradle bootRun
	gradle bootRun --debug
	
To debug without the maven/gradle parameters:
	just command line: --debug=true
	or application.properties: debug=true
	or in IntelliJ: Spring Boot Run Configurations --> check the "Enable debug output" checkbox
	
	The --debug switch will make Spring Boot log to the console which AutoConfiguration files got matched, which didn't and which were excluded.
	
To create an executable jar just use the maven/gradle plugin provided by Spring:
	Maven plugin binds to the "repackage" goal
	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>
	
13.1. Spring Boot application starters
	
@EnableAutoConfiguration - This annotation tells Spring Boot to “guess” how you will want to configure Spring, based on the jar dependencies that you have added.
	To exclude a matched AutoConfiguration: @SpringBootApplication(exclude = {MultipartAutoConfiguration.class})
@SpringBootApplication = @EnableAutoConfiguration + @ComponentScan + @Configuration
@ComponentScan: what packages to scan for @Component. The default is the package that the class having @ComponentScan is defined
@EntityScan: what packages to scan for JPA entities

We generally recommend that you locate your main application class in a root package above other classes. 
	The @EnableAutoConfiguration annotation is often placed on your main class, and it implicitly defines a base “search package” for certain items.
	For example, if you are writing a JPA application, the package of the @EnableAutoConfiguration annotated class will be used to search for @Entity items.
	
	Using a root package also allows the @ComponentScan annotation to be used without needing to specify a basePackage attribute. 
	You can also use the @SpringBootApplication annotation if your main class is in the root package.
	
	Many Spring configuration examples have been published on the Internet that use XML configuration. Always try to use the equivalent Java-based configuration if possible.
	Searching for enable* annotations can be a good starting point.

@Import: You don’t need to put all your @Configuration into a single class. The @Import annotation can be used to import additional configuration classes. 
	Alternatively, you can use @ComponentScan to automatically pick up all Spring components, including @Configuration classes.
		
You should only ever add one @EnableAutoConfiguration annotation. We generally recommend that you add it to your primary @Configuration class.

16.1 Gradually replacing auto-configuration
	Auto-configuration is noninvasive, at any point you can start to define your own configuration to replace specific parts of the auto-configuration. 
	For example, if you add your own DataSource bean, the default embedded database support will back away.

	If you need to find out what auto-configuration is currently being applied, and why, start your application with the --debug switch. 
	This will enable debug logs for a selection of core loggers and log an auto-configuration report to the console.
	
	
16.2 Disabling specific auto-configuration
	@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
	
	
18. Using te @SpringBeanAutowiringSupport annotation
	Many Spring Boot developers always have their main class annotated with @Configuration, @EnableAutoConfiguration and @ComponentScan. 
	Since these annotations are so frequently used together (especially if you follow the best practices above), 
	Spring Boot provides a convenient @SpringBootApplication alternative.
	The @SpringBootApplication annotation is equivalent to using @Configuration, @EnableAutoConfiguration and @ComponentScan with their default attributes:


20. Developer tools

	spring-boot-devtools

	Developer tools are automatically disabled when running a fully packaged application. If your application is launched using java -jar or if it’s started 
	using a special classloader, then it is considered a “production application”. Flagging the dependency as optional is a best practice that prevents 
	devtools from being transitively applied to other modules using your project. Gradle does not support optional dependencies out-of-the-box so you may 
	want to have a look to the propdeps-plugin in the meantime.
	
20.1 Property defaults
	Several of the libraries supported by Spring Boot use caches to improve performance. For example, Thymeleaf will cache templates to save repeatedly parsing XML source files.
	This can be overridden in application.properties.
	
20.2 Automatic restart
	Applications that use spring-boot-devtools will automatically restart whenever files on the classpath change. 
		Triggering a restart
		As DevTools monitors classpath resources, the only way to trigger a restart is to update the classpath. 
		The way in which you cause the classpath to be updated depends on the IDE that you are using. 
		In Eclipse, saving a modified file will cause the classpath to be updated and trigger a restart. 
		In IntelliJ IDEA, building the project (Build → Make Project) will have the same effect.
		
	Restart vs Reload
		The restart technology provided by Spring Boot works by using two classloaders. Classes that don’t change (for example, those from third-party jars) are 
		loaded into a base classloader. Classes that you’re actively developing are loaded into a restart classloader. When the application is restarted, 
		the restart classloader is thrown away and a new one is created. This approach means that application restarts are typically much faster than “cold starts” 
		since the base classloader is already available and populated.
		If you find that restarts aren’t quick enough for your applications, or you encounter classloading issues, you could consider reloading technologies 
		such as JRebel from ZeroTurnaround. These work by rewriting classes as they are loaded to make them more amenable to reloading. Spring Loaded provides 
		another option, however it doesn’t support as many frameworks and it isn’t commercially supported.
	
	
20.2.1 Excluding resources	

	Certain resources don’t necessarily need to trigger a restart when they are changed. For example, Thymeleaf templates can just be edited in-place. 
	By default changing resources in /META-INF/maven, /META-INF/resources ,/resources ,/static ,/public or /templates will not trigger a restart but will trigger a live reload.
	
20.2.2 Watching additional paths
		You may want your application to be restarted or reloaded when you make changes to files that are not on the classpath. 
		To do so, use the spring.devtools.restart.additional-paths property to configure additional paths to watch for changes. 
		
23.4 Application events and listeners

23.6 Accessing application arguments
	Inject ApplicationArguments bean.
	
23.7 Using the ApplicationRunner or CommandLineRunner
	Both interfaces work in the same way and offer a single run method which will be called just before SpringApplication.run(…​) completes.
	
23.9 Admin features
	spring.application.admin.enabled
	
24. Externalized Configuration
	Even if the configuration above will create a regular bean for ConnectionProperties, we recommend that @ConfigurationProperties
	only deal with the environment and in particular does not inject other beans from the context. Having said that, The @EnableConfigurationProperties
	annotation is also automatically applied to your project so that any existing bean annotated with @ConfigurationProperties will be configured from
	the Environment properties. You could shortcut MyConfiguration above by making sure ConnectionProperties is a already a bean:
		@Component		// according to this talk: (https://www.infoq.com/presentations/spring-boot-dev-tools-productivity) DO NOT make a properties pojo a @Component
						// instead use on the Boot application class: @EnableConfigurationProperties({ConnectionProperties.class})
		@ConfigurationProperties(prefix="connection")
		public class ConnectionProperties {

			// ... getters and setters

		}

		To work with @ConfigurationProperties beans you can just inject them in the same way as any other bean.		
		@Service
		public class MyService {

			private final ConnectionProperties connection;

			@Autowired
			public MyService(ConnectionProperties connection) {
				this.connection = connection;
			}

			 //...

			@PostConstruct
			public void openConnection() {
				Server server = new Server();
				this.connection.configure(server);
			}

		}
	
24.7 Type-safe Configuration Properties
	
	@Configuration
	@EnableConfigurationProperties(ConnectionProperties.class)	- necessary if ConnectionProperties is not a @Bean, @Component
	@SpringBootApplication
	public class MyConfiguration {
	}
	
	@Component - so this is injectable to other beans, but avoid it, prefer to use @EnableConfigurationProperties
	@ConfigurationProperties(prefix="connection")
	public class ConnectionProperties {

		private String username;

		private InetAddress remoteAddress;

		// ... getters and setters
	}
	
Nested @ConfigurationProperties
	@ConfigurationProperties("my.config")
	class MyConfig {

		private final Github github = new Github();
		private final Work work = new Work();

		public Github getGithub() {
			return github;
		}

		public Work getWork() {
			return work;
		}

		private static class Github {
			private int userName;
			private int password;
			private int repoUrl;

			public int getUserName() {
				return userName;
			}

			public int getPassword() {
				return password;
			}

			public int getRepoUrl() {
				return repoUrl;
			}
		}

		private static class Work {
			private int location;
			private int hours;

			public int getLocation() {
				return location;
			}

			public int getHours() {
				return hours;
			}
		}
	}

24.7.4 @ConfigurationProperties Validation
	You can simply add JSR-303 javax.validation constraint annotations to your @ConfigurationProperties class
	
	@ConfigurationProperties(prefix="connection")
	public class ConnectionProperties {

		@NotNull
		private InetAddress remoteAddress;

		// ... getters and setters

	}
	
	In order to validate values of nested properties, you must annotate the associated field as @Valid to trigger its validation. For example, building upon the above ConnectionProperties example:
	@ConfigurationProperties(prefix="connection")
	public class ConnectionProperties {

		@NotNull
		@Valid
		private RemoteAddress remoteAddress;

		// ... getters and setters

		public static class RemoteAddress {

			@NotEmpty
			public String hostname;

			// ... getters and setters

		}

	}

24.7.5 @ConfigurationProperties vs. @Value
	@Value is a core container feature and it does not provide the same features as type-safe Configuration Properties. 
	
25. Profiles
	Spring Profiles provide a way to segregate parts of your application configuration and make it only available in certain environments. 
	Any @Component or @Configuration can be marked with @Profile to limit when it is loaded:
	@Configuration
	@Profile("production")
	public class ProductionConfiguration {
	
25.1 Adding active profiles
	The spring.profiles.active property follows the same ordering rules as other properties, the highest PropertySource will win. This means that you can specify active profiles in application.properties then replace them using the command line switch.
	
26. Logging
	Spring by default uses Logback but this can be changed to Log4J 2
	
	To enable logging DEBUG messages (by default only ERROR, WARN, and INFO are logged), specify this:
		logging.level.<base-package>
		logging.level.hu.regens.edgemicro=DEBUG

26.2 Console output
		The default log configuration will echo messages to the console as they are written. By default ERROR, WARN and INFO level messages are logged. 
		To be able to log DEBUG messages: logging.level.{package[.sub-package]} can be changed
		logging.file=logs/practice.log - spring will log here (both its internal logs and the org.slf4j.LoggerFactory used by the application)
		
		You can also enable a “debug” mode by starting your application with a --debug flag.
			you can also specify debug=true in your application.properties.
			java -jar myapp.jar --debug
			
		
	How to retrieve a logger:
		
		class HomeController {
			private static Logger logger = LoggerFactory.getLogger(HomeController.class);
		}
		
		or we can do even better with DI (since Spring Boot 1.4.2):
			@Bean
			@Scope("prototype")
			public Logger getLogger(InjectionPoint ip) {
				Member member = ip.getMember();
				if (member != null)
					return LoggerFactory.getLogger(member.getDeclaringClass());

				return LoggerFactory.getLogger(ip.getDeclaredType().getName());
			}
			
			now Logger is injectable to all components:
			class HomeController {
			
				@Autowired
				private Logger logger;
			}
			
			
26.3 File output
	logging.file
	
26.5 Custom log configuration
	logging.config can be set to for example "logback-spring.xml"

	
27.1 The ‘Spring Web MVC framework’
27.1.2 HttpMessageConverters
	pring MVC uses the HttpMessageConverter interface to convert HTTP requests and responses. Sensible defaults are included out of the box, 
	for example Objects can be automatically converted to JSON (using the Jackson library) or XML (using the Jackson XML extension if available, else using JAXB). 
	Strings are encoded using UTF-8 by default.
	
27.1.5 Static Content
	By default Spring Boot will serve static content from a directory called /static (or /public or /resources or /META-INF/resources) in the classpath or 
	from the root of the ServletContext. It uses the ResourceHttpRequestHandler from Spring MVC so you can modify that behavior by adding your own 
	WebMvcConfigurerAdapter and overriding the addResourceHandlers method.
	
	Do not use the src/main/webapp directory if your application will be packaged as a jar. Although this directory is a common standard, 
	it will only work with war packaging and it will be silently ignored by most build tools if you generate a jar.
	

27.3 Embedded servlet container support
	When using an embedded servlet container you can register Servlets, Filters and all the listeners from the Servlet spec (e.g. HttpSessionListener)
	either by using Spring beans or by scanning for Servlet components.
	
	If convention-based mapping is not flexible enough you can use the ServletRegistrationBean, FilterRegistrationBean and ServletListenerRegistrationBean classes for complete control.
	
27.3.2 Servlet Context Initialization

27.3.4 Customizing embedded servlet containers
	server.port
	server.address
	server.session.persistence
	server.session.timeout
	server.session.cookie.*
	server.session.store-dir
	

28. Security
	If Spring Security is on the classpath then web applications will be secure by default with ‘basic’ authentication on all HTTP endpoints. 
	To add method-level security to a web application you can also add @EnableGlobalMethodSecurity with your desired settings: @Secured("ROLE_TELLER")
	
	@EnableWebSecurity, @EnableGlobalMethodSecurity - the latter is for method-based authorization
	
29. Working with SQL databases

29.3.3 Creating and dropping JPA databases
	By default, JPA databases will be automatically created only if you use an embedded database (H2, HSQL or Derby). 
	You can explicitly configure JPA settings using spring.jpa.* properties. For example, to create and drop tables you can add the following to your application.properties.
		spring.jpa.hibernate.ddl-auto=create-drop
		
	spring.jpa.properties.hibernate.globally_quoted_identifiers=true - passes hibernate.globally_quoted_identifiers to the Hibernate entity manager.
	
31. Caching
	@EnableCaching
	You can either use the standard JSR-107 (JCache) annotations or Spring’s own caching annotations transparently. We strongly advise you however to not mix and match them.
	
Part V. Spring Boot Actuator: Production-ready features
	Spring Boot includes a number of additional features to help you monitor and manage your application when it’s pushed to production. 
	You can choose to manage and monitor your application using HTTP endpoints, with JMX or even by remote shell (SSH or Telnet). 
	Auditing, health and metrics gathering can be automatically applied to your application.

	Actuator HTTP endpoints are only available with a Spring MVC-based application. In particular, it will not work with Jersey unless you enable Spring MVC as well.
	
	
82.1 Create a deployable war file
	The first step in producing a deployable war file is to provide a SpringBootServletInitializer subclass and override its configure method.
	This makes use of Spring Framework’s Servlet 3.0 support and allows you to configure your application when it’s launched by the servlet container. 
	Typically, you update your application’s main class to extend SpringBootServletInitializer:
	
	@SpringBootApplication
	public class Application extends SpringBootServletInitializer {

		@Override
		protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
			return application.sources(Application.class);
		}

		public static void main(String[] args) throws Exception {
			SpringApplication.run(Application.class, args);
		}

	}
	
69.4 Create a non-web application
	Not all Spring applications have to be web applications (or web services). If you want to execute some code in a main method, but also bootstrap a 
	Spring application to set up the infrastructure to use, then it’s easy with the SpringApplication features of Spring Boot. A SpringApplication changes 
	its ApplicationContext class depending on whether it thinks it needs a web application or not. The first thing you can do to help it is to just leave the
	servlet API dependencies off the classpath.
	
71.1.1 Add a Servlet, Filter or Listener using a Spring bean
	In the case of Filters and Servlets you can also add mappings and init parameters by adding a FilterRegistrationBean or ServletRegistrationBean
	instead of or as well as the underlying component.
		If no dispatcherType is specified on a filter registration, it will match FORWARD,INCLUDE and REQUEST. If async has been enabled, it will match ASYNC as well.
		
71.5 Configure SSL
	server.port=8443
	server.ssl.key-store=classpath:keystore.jks
	server.ssl.key-store-password=secret
	server.ssl.key-password=another-secret
	
72.2 Write an XML REST service
	<dependency>
		<groupId>com.fasterxml.jackson.dataformat</groupId>
		<artifactId>jackson-dataformat-xml</artifactId>
	</dependency>

72.4 Customize the @ResponseBody rendering
	Spring uses HttpMessageConverters to render @ResponseBody (or responses from @RestController). You can contribute additional converters by simply adding beans
	of that type in a Spring Boot context. If a bean you add is of a type that would have been included by default anyway (like MappingJackson2HttpMessageConverter 
	for JSON conversions) then it will replace the default value.
	
72.7 Switch off the Default MVC configuration
	The easiest way to take complete control over MVC configuration is to provide your own @Configuration with the @EnableWebMvc annotation. 
	This will leave all MVC configuration in your hands.
	
74. Logging
	Spring Boot has no mandatory logging dependency, except for the Commons Logging API, of which there are many implementations to choose from. 
	To use Logback you need to include it and jcl-over-slf4j (which implements the Commons Logging API) on the classpath. 
	The simplest way to do that is through the starters which all depend on spring-boot-starter-logging. 
	For a web application you only need spring-boot-starter-web since it depends transitively on the logging starter. For example, using Maven:

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		
	logging.level.org.springframework.web=DEBUG
	logging.level.org.hibernate=ERROR
	
75.2 Configure Two DataSources
	@Bean
	@Primary
	@ConfigurationProperties(prefix="datasource.primary")
	public DataSource primaryDataSource() {
		return DataSourceBuilder.create().build();
	}

	@Bean
	@ConfigurationProperties(prefix="datasource.secondary")
	public DataSource secondaryDataSource() {
		return DataSourceBuilder.create().build();
	}
	
75.4 Separate @Entity definitions from Spring configuration
	Spring Boot tries to guess the location of your @Entity definitions, based on the @EnableAutoConfiguration it finds. To get more control, you can use the @EntityScan annotation, e.g.

	@Configuration
	@EnableAutoConfiguration
	@EntityScan(basePackageClasses=City.class)
	public class Application {
	
75.5 Configure JPA properties
	spring.jpa.hibernate.ddl-auto=create-drop
	spring.jpa.hibernate.naming.physical-strategy=com.example.MyPhysicalNamingStrategy
	spring.jpa.database=H2
	spring.jpa.show-sql=true
	
	The ddl-auto setting is a special case in that it has different defaults depending on whether you are using an embedded database (create-drop) or not (none). In addition all properties in spring.jpa.properties.* are passed through as normal JPA properties (with the prefix stripped) when the local EntityManagerFactory is created.
	
	Spring Boot provides a consistent naming strategy regardless of the Hibernate generation that you are using. 
	If you are using Hibernate 4, you can customize it using spring.jpa.hibernate.naming.strategy; Hibernate 5 defines a Physical and Implicit naming strategies: 
	Spring Boot configures SpringPhysicalNamingStrategy by default. This implementation provides the same table structure as Hibernate 4. I
	f you’d rather use Hibernate 5’s default instead, set the following property:
	
		spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
		
75.7 Use Two EntityManagers
	@Bean
	public LocalContainerEntityManagerFactoryBean customerEntityManagerFactory(
			EntityManagerFactoryBuilder builder) {
		return builder
				.dataSource(customerDataSource())
				.packages(Customer.class)
				.persistenceUnit("customers")
				.build();
	}

	@Bean
	public LocalContainerEntityManagerFactoryBean orderEntityManagerFactory(
			EntityManagerFactoryBuilder builder) {
		return builder
				.dataSource(orderDataSource())
				.packages(Order.class)
				.persistenceUnit("orders")
				.build();
	}
	
76.1 Initialize a database using JPA
	JPA has features for DDL generation, and these can be set up to run on startup against the database. This is controlled through two external properties:
	spring.jpa.generate-ddl (boolean) switches the feature on and off and is vendor independent.
	spring.jpa.hibernate.ddl-auto (enum) is a Hibernate feature that controls the behavior in a more fine-grained way. See below for more detail.
	

76.2 Initialize a database using Hibernate

	You can set spring.jpa.hibernate.ddl-auto explicitly and the standard Hibernate property values are none, validate, update, create, create-drop. 
	Spring Boot chooses a default value for you based on whether it thinks your database is embedded (default create-drop) or not (default none). 
	An embedded database is detected by looking at the Connection type: hsqldb, h2 and derby are embedded, the rest are not. 
	Be careful when switching from in-memory to a ‘real’ database that you don’t make assumptions about the existence of the tables and data in the new platform. 
	You either have to set ddl-auto explicitly, or use one of the other mechanisms to initialize the database.
	
76.4 Initialize a Spring Batch database
	If you are using Spring Batch then it comes pre-packaged with SQL initialization scripts for most popular database platforms. Spring Boot will detect your database type, and execute those scripts by default, and in this case will switch the fail fast setting to false (errors are logged but do not prevent the application from starting). 
	You can switch off the initialization explicitly using spring.batch.initializer.enabled=false.
	
77.1 Execute Spring Batch jobs on startup
	Spring Batch auto-configuration is enabled by adding @EnableBatchProcessing (from Spring Batch) somewhere in your context.
	
		
80. Hot swapping
	There are several options for hot reloading. The recommended approach is to use spring-boot-devtools as it provides additional development-time features such as support for fast application restarts and LiveReload as well as sensible development-time configuration (e.g. template caching).
	
	80.2.1 Thymeleaf templates
		If you are using Thymeleaf, then set spring.thymeleaf.cache to false. See ThymeleafAutoConfiguration for other Thymeleaf customization options.
		
		
		
********************************
Thymeleaf
********************************

${message} - read "message" from the Model
#${field1} - for localization, read "field1" from the messages_{lang}.properties 		//  <label for="field1" th:text="#{field1}"></label>
*{} - selection expression
	
	Values for th:field attributes must be selection expressions (*{...}), which makes sense given the fact that they will be evaluated on the form-backing bean
	and not on the context variables (or model attributes in Spring MVC jargon).


	<form th:action="@{/save}" method="post" th:object="${gizmo}">
	instead of writing ${gizmo.datePlanted} we can write *{datePlanted} on elements inside the <form> tag
		<input type="text" th:field="*{datePlanted}" /> - good
		<input type="text" th:field="${gizmo.datePlanted}" /> - good as well
	
		
There are special objects that thymeleaf exposes in the views like:
	#field for form validation:	
		<input type="text" th:field="*{datePlanted}" th:class="${#fields.hasErrors('datePlanted')}? fieldError" />
	#httpServletRequest
		<p>[[${#httpServletRequest.remoteUser}]]</p> 
	#authentication by Spring Security
		<span>[[${#authentication.firstName}]]</span>




********************************
Spring Reactive
********************************

Will be available from Spring Framework 5.

Another source of pain is that if we ever make a mistake and block in one of our Reactive callbacks, 
we will be holding up all requests on the same thread. With the servlet-based containers every request is isolated to a thread, 
and blocking doesn’t hold up other requests because they are be processed on different threads. 
Blocking all requests is still a recipe for trouble, but it only shows up as increased latency with roughly a constant factor per request. 
In the Reactive world, blocking a single request can lead to increased latency for all requests, 
and blocking all requests can bring a server to its knees because the extra layers of buffers and threads are not there to take up the slack.

2 entites: Subscriber, Publisher

Backpressure: allows the Subscriber to indicate to the Publisher source whether it is ready to consume more data or not. 
			  If the subscriber/consumer is not able to consume, the publisher is not supposed to produce.
	
	
	
********************************
Gradle
********************************

Gradle wrapper: makes it possible to execute gradle tasks without having gradle installed
	If a Gradle project has set up the Wrapper (and we recommend all projects do so), you can execute the build using one of the following commands from the root of the project:

		./gradlew <task> (on Unix-like platforms such as Linux and Mac OS X)
		gradlew <task> (on Windows using the gradlew.bat batch file)
		
		Each Wrapper is tied to a specific version of Gradle, so when you first run one of the commands above for a given Gradle version, 
		it will download the corresponding Gradle distribution and use it to execute the build.

	
	
********************************
Cloud: IaaS, PaaS, Clound Foundry
********************************

IaaS support: eIMS can be deployed on a cloud-based infrastructure. With this approach only the hardware is provided and scaling the 
	application means firing up more virtual machine instances, and after that each instance needs to be configured: 
	install an operating system, configure the connection to the datafarm, install, the Java runtime and all the necessary packages needed. 
	IaaS provides only the infrastructure (CPU, RAM, storage) but not the platform.
	
PaaS support: through Cloud Foundry which is an open source PaaS implementation. PaaS sits above the infrastructure (IaaS) and provides an 
	operating system for applications on top of that with all the tooling needed to scale the deployed applications. When scaling the application 
	is needed we can forget about installing new virtual machines and post-configurations. The application is the new unit of scale here, 
	we just say we need more instances of this component and the platform will automatically set things up.
	In a microservices world, where there are more components, we can even tell the system which component needs to be scaled up or down.
	What this means for the eIMS is that let’s say Alert Management microservice is having increased requests and struggles to serve them. 
	We can tell the platform that we need more instances of the Alert Management microservice and the platform will handle firing them up.
	Cloud Foundry is host-agnostic, meaning that it can run on VMWare, AWS, OpenStack, ...
	
	
	
********************************
H2, HSQL in-memory databases
********************************

localhost:8080/h2-console to access the web console

H2:
	Driver class: org.h2.Driver
	Jdbc Url: jdbc:h2:mem:testdb
	name: sa
	
HSQL:
	Driver class: org.hsqldb.jdbc.JDBCDriver
	Jdbc Url: jdbc:hsqldb:mem:testdb
	name: sa



	
********************************
Useful utils
********************************

FileCopyUtils	
org.springframework.util.FileSystemUtils
org.springframework.beans.BeanUtils
org.springframework.validation.ValidationUtils
DataSourceUtils (for JDBC), EntityManagerFactoryUtils (for JPA), SessionFactoryUtils, PersistenceManagerFactoryUtils (for JDO)



********************************
Asynchronous http processing
********************************

Return RxJava Observable
Spring Reactive, coming in Spring 5
Mono, Flux: they both implement the Publisher interface, however Mono is for dealing with 1 item in the stream whereas Flux is for N items.



********************************
Eclipse multi maven project with Spring, TDPraktiker
********************************
1. workspace resolution works, eclipse sees, maven also sees the dependencies being in the same workspace: 
2. install the dependency into  the local repo with "mvn install" --> update the consumer project via "maven update" then voila, works!

TDPraktiker: parentPom/pom.xml: only for jenkins build
					
OAuth2 is basically a protocol that supports authorization workflows. What this means is that it gives you a way to ensure that 
a specific user has permissions to do something. That’s it. 
OAuth2 isn’t meant to do stuff like validate a user’s identity — that’s taken care of by an Authentication service. 
Authentication is when you validate a user’s identity (like asking for a username / password to log in), 
whereas authorization is when you check to see what permissions an existing user already has.
Just remember that OAuth2 is a protocol for authorization.



class Convert<M, R> {

	public R convert(M model, Class<R> aClass) {
		R result;
		try {
			result = aClass.newInstance();
			org.springframework.beans.BeanUtils.copyProperties(model, result);
			return result;
		} catch (InstantiationException | IllegalAccessException e) {
			e.printStackTrace();
		}
		return null;
	}
}