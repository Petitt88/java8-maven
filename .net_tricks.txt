1. The runtime version is determined by the starting project. No matter what the runtime of the other referenced dlls are, they will use the same as the starting project.
2. Similarly, only the starting app's config is taken into consideration.

Assembly loading process:

	It is based on strong name, the CLR uses the strong name of the assembly to load it
		strong name: assembly name + version + optional culture + public key of the digital signature
	1. the CLR checks whether the assembly has been loaded
	2. if not, checks the GAC that belongs to the starting app's runtime version (v2 or v4)
			GAC is located in C:\Windows\Microsoft.NET\assembly
	3. if not found in the GAC, probably probes the paths specified in the PATH environment variable
	4. if not found, tries in the same folder where the app is running
	
	
machine.config:

	Contains machine level settings.
	The Machine.config file contains the ASP.NET schema for all of the Web applications on the server. This file is at the top of the configuration merge hierarchy.
	
	location for the v4 runtime:
		C:\Windows\Microsoft.NET\Framework\v4.0.30319\Config
		C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config
		
	location for the v2 runtime:
		C:\Windows\Microsoft.NET\Framework\v2.0.50727\CONFIG
		C:\Windows\Microsoft.NET\Framework64\v2.0.50727\CONFIG
	
good to know:
	1. certain apps register their providers, config sections, etc. in the machine.config. It is good to check it over time.
	2. Also it is a good practice to in the web.config or app.config place a <clear /> tag in whatever provider section.
	3. The best approuch is to tell the installer if possible (for example to the Oracle client or to the MySql when installing the providers) not to include machine level settings -->
		--> machine.config won't get polluted with pre-registered providers like this:
			<runtime>
				<assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
				  <dependentAssembly xmlns="urn:schemas-microsoft-com:asm.v1">
					<assemblyIdentity name="MySql.Data" publicKeyToken="c5687fc88969c44d" culture="neutral" />
					<bindingRedirect oldVersion="6.7.4.0" newVersion="6.9.9.0" />
				  </dependentAssembly>
				  <dependentAssembly xmlns="urn:schemas-microsoft-com:asm.v1">
					<assemblyIdentity name="MySql.Data.Entity" publicKeyToken="c5687fc88969c44d" culture="neutral" />
					<bindingRedirect oldVersion="6.7.4.0" newVersion="6.9.9.0" />
				  </dependentAssembly>
				  <dependentAssembly xmlns="urn:schemas-microsoft-com:asm.v1">
					<assemblyIdentity name="MySql.Web" publicKeyToken="c5687fc88969c44d" culture="neutral" />
					<bindingRedirect oldVersion="6.7.4.0" newVersion="6.9.9.0" />
				  </dependentAssembly>
				</assemblyBinding>
			</runtime>
			<DbProviderFactories>
				<add name="MySQL Data Provider" invariant="MySql.Data.MySqlClient" description=".Net Framework Data Provider for MySQL" type="MySql.Data.MySqlClient.MySqlClientFactory, MySql.Data, Version=6.9.9.0, 			Culture=neutral, PublicKeyToken=c5687fc88969c44d" />
			</DbProviderFactories>
		And so on...
	4. use client providers from nuget if available:
		- for example we do not have to install the ODP.NET (Oracle Data Provider for .NET) which is several hundred megabytes big (http://www.oracle.com/technetwork/topics/dotnet/index-085163.html)
		- instead we could install just 2 nuget packages and the Oracle providers will get packaged with out application:
			1. Oracle.ManagedDataAccess							- if only ADO.NET is needed, then this is enought
			2. Oracle.ManagedDataAccess.EntityFramework			- if we want to use Oracle with EntityFramework we will need this one as well
		
		
applicationhost.config:

	IIS: 
		ApplicationHost.config is the root file of the IIS 7.0 configuration system. It includes definitions of all sites, applications, virtual directories, and application pools, as well as global defaults for the Web server settings. It is in the following location: %windir%\system32\inetsrv\config.
		
			<sites>
				<site name="Admin-Site" id="2">
					<application path="/" applicationPool="Clr4IntegratedAppPool">
						<virtualDirectory path="/" physicalPath="C:\Users\pkongyik\Documents\My Web Sites\Empty folder" />
					</application>
					<application path="/Admin" applicationPool="Clr4IntegratedAppPool">
						<virtualDirectory path="/" physicalPath="C:\Projects\CemtPalyazat\src\Admin" />
					</application>
					<bindings>
						<binding protocol="https" bindingInformation="*:44317:localhost" />
						<binding protocol="http" bindingInformation="*:60435:localhost" />
					</bindings>
				</site>
			</sites>
	
	Client application directory: 
		The ApplicationName.config file contains settings for a Windows client application (not a Web application).
	
	
web.config:

	Web site: 
		The Web.config file for a specific Web site contains settings that apply to the Web site and inherit downward through all of the ASP.NET applications and subdirectories of the site.
	
	ASP.NET application root directory:
		The Web.config file for a specific ASP.NET application is located in the root directory of the application and contains settings that apply to the Web application and inherit downward through all of the subdirectories in its branch.
	
	ASP.NET application subdirectory:
		The Web.config file for an application subdirectory contains settings that apply to this subdirectory and inherit downward through all of the subdirectories in its branch.
		

Dump files, what assemblies are loaded in runtime:
	Place a breakpoint somewhere:
		Debug --> Windows --> Modules: we can check the loaded managed assmeblies here
		Debug --> Save Dump As... we can save a dump file of the current state of the memory then load this dumpfile back into Visual Studio. This time we will see even the unmanaged native libraries that got loaded.
	
	
Sysinternals, Resource monitor

	Download the Sysinternals: google "Windows Sysinternals download" --> Sysinternals Suite
		This contains a lot of system utilities, even the Process monitor
		
	Process Explorer (procexp64.exe): considered to be a more advanced form of the Windows Task Manager
		we can find out which file is being held by which process
		Find --> Find Handle or DLL...
		
	Process monitor (Procmon.exe):
	
	TcpView (Tcpview.exe)
		lets us find out which process uses which port
		
	Resource monitor:
		Task Mananger --> Performance --> Open Resource Monitor
		Network tab --> Listening Ports: just like with TcpView we can see which ports are being used by which application
			Moreover, this even show us whether the port is allowed in our firewall (Firewall Status column)



.NET Standard

	If you're reading this post, you have hopefully already heard of .NET Standard. This is acts as an interface to .NET Platforms, and aims to define a unified set of APIs that those platforms must implement. 
	It is the spiritual successor to PCLs, and allow you to target .NET Framework, .NET Core, and other .NET platforms with the same library code base.

	The NETStandard.Library metapackage references a set of NuGet packages that define the .NET Standard library. Like the Microsoft.AspNetCore package from my last post, 
	the package does not contain dlls itself, but rather references a number of other packages, hence the name metapackage. Depending on the target platform of your project, 
	different packages will be added to the project, in line with the appropriate version of .NET Standard the platform implements.

Reference assmeblies:

	 The reference dlls just define the various APIs that these platforms (.NET Framework, .NET Core, Mono, etc) must expose for a given version of .NET Standard.
	 The classes have literally empty method bodies.
	 
	 These placeholder assemblies are are a key part of the the .NET Standard infrastructure. They provide concrete APIs against which you can compile your projects, 
	 without tying you to a specific implementation (i.e. .NET Framework or .NET Core).