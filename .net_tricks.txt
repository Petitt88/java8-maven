1. The runtime version is determined by the starting project. No matter what the runtime of the other referenced dlls are, they will use the same as the starting project.
2. Similarly, only the starting app's config is taken into consideration.

Assembly loading process:

	It is based on strong name, the CLR uses the strong name of the assembly to load it
		strong name: assembly name + version + optional culture + public key of the digital signature
	1. the CLR checks whether the assembly has been loaded
	2. if not, checks the GAC that belongs to the starting app's runtime version (v2 or v4)
			GAC is located in C:\Windows\Microsoft.NET\assembly
	3. if not found in the GAC, probably probes the paths specified in the PATH environment variable
	4. if not found, tries in the same folder where the app is running
	
	
machine.config:

	Contains machine level settings.
	The Machine.config file contains the ASP.NET schema for all of the Web applications on the server. This file is at the top of the configuration merge hierarchy.
	
	location for the v4 runtime:
		C:\Windows\Microsoft.NET\Framework\v4.0.30319\Config
		C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config
		
	location for the v2 runtime:
		C:\Windows\Microsoft.NET\Framework\v2.0.50727\CONFIG
		C:\Windows\Microsoft.NET\Framework64\v2.0.50727\CONFIG
	
good to know:
	1. certain apps register their providers, config sections, etc. in the machine.config. It is good to check it over time.
	2. Also it is a good practice to in the web.config or app.config place a <clear /> tag in whatever provider section.
	3. The best approuch is to tell the installer if possible (for example to the Oracle client or to the MySql when installing the providers) not to include machine level settings -->
		--> machine.config won't get polluted with pre-registered providers like this:
			<runtime>
				<assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
				  <dependentAssembly xmlns="urn:schemas-microsoft-com:asm.v1">
					<assemblyIdentity name="MySql.Data" publicKeyToken="c5687fc88969c44d" culture="neutral" />
					<bindingRedirect oldVersion="6.7.4.0" newVersion="6.9.9.0" />
				  </dependentAssembly>
				  <dependentAssembly xmlns="urn:schemas-microsoft-com:asm.v1">
					<assemblyIdentity name="MySql.Data.Entity" publicKeyToken="c5687fc88969c44d" culture="neutral" />
					<bindingRedirect oldVersion="6.7.4.0" newVersion="6.9.9.0" />
				  </dependentAssembly>
				  <dependentAssembly xmlns="urn:schemas-microsoft-com:asm.v1">
					<assemblyIdentity name="MySql.Web" publicKeyToken="c5687fc88969c44d" culture="neutral" />
					<bindingRedirect oldVersion="6.7.4.0" newVersion="6.9.9.0" />
				  </dependentAssembly>
				</assemblyBinding>
			</runtime>
			<DbProviderFactories>
				<add name="MySQL Data Provider" invariant="MySql.Data.MySqlClient" description=".Net Framework Data Provider for MySQL" type="MySql.Data.MySqlClient.MySqlClientFactory, MySql.Data, Version=6.9.9.0, 			Culture=neutral, PublicKeyToken=c5687fc88969c44d" />
			</DbProviderFactories>
		And so on...
	4. use client providers from nuget if available:
		- for example we do not have to install the ODP.NET (Oracle Data Provider for .NET) which is several hundred megabytes big (http://www.oracle.com/technetwork/topics/dotnet/index-085163.html)
		- instead we could install just 2 nuget packages and the Oracle providers will get packaged with out application:
			1. Oracle.ManagedDataAccess							- if only ADO.NET is needed, then this is enought
			2. Oracle.ManagedDataAccess.EntityFramework			- if we want to use Oracle with EntityFramework we will need this one as well
	5. If the target framework of some projects inside a solution differs the entry project's target version wins at runtime.
	6. This situation is the same with App.config/Web.config files: the settings defined in the entry project wins.
		So for example the <connectionStrings>, <system.serviceModel>, etc. all comes from the entry project at runtime.
		The designer however uses the settings defined in the corresponding project.
	
		
applicationhost.config:

	IIS: 
		ApplicationHost.config is the root file of the IIS 7.0 configuration system. It includes definitions of all sites, applications, virtual directories, and application pools, as well as global defaults for the Web server settings. It is in the following location: %windir%\system32\inetsrv\config.
		
			<sites>
				<site name="Admin-Site" id="2">
					<application path="/" applicationPool="Clr4IntegratedAppPool">
						<virtualDirectory path="/" physicalPath="C:\Users\pkongyik\Documents\My Web Sites\Empty folder" />
					</application>
					<application path="/Admin" applicationPool="Clr4IntegratedAppPool">
						<virtualDirectory path="/" physicalPath="C:\Projects\CemtPalyazat\src\Admin" />
					</application>
					<bindings>
						<binding protocol="https" bindingInformation="*:44317:localhost" />
						<binding protocol="http" bindingInformation="*:60435:localhost" />
					</bindings>
				</site>
			</sites>
	
	Client application directory: 
		The ApplicationName.config file contains settings for a Windows client application (not a Web application).
	
	
web.config:

	Web site: 
		The Web.config file for a specific Web site contains settings that apply to the Web site and inherit downward through all of the ASP.NET applications and subdirectories of the site.
	
	ASP.NET application root directory:
		The Web.config file for a specific ASP.NET application is located in the root directory of the application and contains settings that apply to the Web application and inherit downward through all of the subdirectories in its branch.
	
	ASP.NET application subdirectory:
		The Web.config file for an application subdirectory contains settings that apply to this subdirectory and inherit downward through all of the subdirectories in its branch.
		

Dump files, what assemblies are loaded in runtime:
	Place a breakpoint somewhere:
		Debug --> Windows --> Modules: we can check the loaded managed assmeblies here
		Debug --> Save Dump As... we can save a dump file of the current state of the memory then load this dumpfile back into Visual Studio. This time we will see even the unmanaged native libraries that got loaded.
	
	
Sysinternals, Resource monitor

	Download the Sysinternals: google "Windows Sysinternals download" --> Sysinternals Suite
		This contains a lot of system utilities, even the Process monitor
		
	Process Explorer (procexp64.exe): considered to be a more advanced form of the Windows Task Manager
		we can find out which file is being held by which process
		Find --> Find Handle or DLL...
		
	Process monitor (Procmon.exe):
	
	TcpView (Tcpview.exe)
		lets us find out which process uses which port
		
	Resource monitor:
		Task Mananger --> Performance --> Open Resource Monitor
		Network tab --> Listening Ports: just like with TcpView we can see which ports are being used by which application
			Moreover, this even show us whether the port is allowed in our firewall (Firewall Status column)



.NET Standard:

	If you're reading this post, you have hopefully already heard of .NET Standard. This is acts as an interface to .NET Platforms, and aims to define a unified set of APIs that those platforms must implement. 
	It is the spiritual successor to PCLs (Portable Class Library), and allows you to target .NET Framework, .NET Core, and other .NET platforms with the same library code base.

	The NETStandard.Library metapackage references a set of NuGet packages that define the .NET Standard library. Like the Microsoft.AspNetCore package from my last post, 
	the package does not contain dlls itself, but rather references to a number of other packages, hence the name metapackage. 
	Depending on the target platform of your project, different packages will be added to the project, in line with the appropriate version of .NET Standard the platform implements.

	
Reference assmeblies:

	 The reference dlls just define the various APIs that these platforms (.NET Framework, .NET Core, Mono, etc) must expose for a given version of .NET Standard.
	 The classes have literally empty method bodies. It will be decided in runtime which implementation will get used.
	 
	 These placeholder assemblies are a key part of the the .NET Standard infrastructure. They provide concrete APIs against which you can compile your projects, 
	 without tying you to a specific implementation (i.e. .NET Framework or .NET Core).
	 
	 
.NET Core:
	
	The runtime is made up of:
		- CoreCLR: the Common Language Runtime for .NET Core, takes the IL generated by the compiler and translates it into code your CPU can understand
		- CoreFX: the .NET Core Framework, containing pretty much everything in the System. namespace. This is the part that is growing massively between .NET Core (and Standard) 1.x and 2.x
		- Roslyn: the .NET compiler platform
		- libuv: the async I/O library that Kestrel (ASP.NET Core's server) runs
	The others:
		- core-setup: build tools to pull in all of the above and combine it into the .NET Core Runtime
		- CLI: the .NET Command Line Interface, so you can dotnet whatever as part of the SDK
	 
	 
Date handling

	DateTime vs DateTimeOffset
	
		Use DateTimeOffset is timezone information is needed.
	
		A DateTime value defines a particular date and time. Starting with version 2.0 of the .NET Framework, it includes a Kind property that provides limited information about the time zone to which that date and time belongs. 
		The DateTimeKind value returned by the Kind property indicates whether the DateTime value represents the local time (DateTimeKind.Local), Coordinated Universal Time (UTC) (DateTimeKind.Utc), or an unspecified time (DateTimeKind.Unspecified).
		
		The DateTimeOffset structure represents a date and time value, together with an offset that indicates how much that value differs from UTC. Thus, the value always unambiguously identifies a single point in time.
	

	
MSBuild
	
	.Target files: https://msdn.microsoft.com/en-us/library/ms164312.aspx
		MSBuild includes several .targets files that contain items, properties, targets, and tasks for common scenarios. These files are automatically imported into most Visual Studio project files to simplify maintenance and readability.
		Projects typically import one or more .targets files to define their build process. For example a Visual C# project created by Visual Studio will import Microsoft.CSharp.targets which imports Microsoft.Common.targets. The Visual C# project itself will define the items and properties specific to that project, but the standard build rules for a Visual C# project are defined in the imported .targets files.
		
	ItemGroup element: https://msdn.microsoft.com/en-us/library/646dk05y.aspx
		Contains a set of user-defined Item elements. Every item used in a MSBuild project must be specified as a child of an ItemGroup element.
		
	PropertyGroup element: https://msdn.microsoft.com/en-us/library/t4w159bs.aspx
		Contains a set of user-defined Property elements. Every Property element used in an MSBuild project must be a child of a PropertyGroup element.
		
	VS2015 uses "dotnet.exe" whereas VS2017 uses MSBuild.
		MSBuild.exe runs on .NET Framework
		dotnet msbuild runs on .NET Core
		
		If you update the dotnet cli, VS2017 won't benefit from it because it does not use it. You need to update VS2017 as well.
		
dotnet cli:
	dotnet --help

	1. create a new project: dotnet new ...
	2. dotnet restore
	3. dotnet run --> and the app runs
	
	3. dotnet build --> creates the dlls in the bin\Debug\netcoreapp1.1 folder
	
	3. dotnet clean --> cleans the bin\Debug\netcoreapp1.1 folder
	
	3. dotnet publish --> packages the application that can be copied to iis or run from the cli (location is bin\Debug\netcoreapp1.1\publish)
	4. dotnet {myApplication.dll} --> runs the packaged application (after cd-ing into the bin\Debug\netcoreapp1.1\publish folder)
	
Docker with Asp.Net Core
	- download docker for windows
	- keep using Linux containers! do not switch to Windows containers (there is a bug and the app from VS just won't start)
	- when pressing F5 is VS:
		- VS uses the linux container and deploys everything there
		- builds the Dockerfile on the MobyLinuxVM.vhdx and the image gets pulled into docker (docker images will display the newly created image)
			- the name of the image is located in the docker-compose project's "docker-compose.yml" file
		- creates a container from the image (docker run [image_name])
		- starts the container (docker start [container_id])
	- when shutting down the app from VS
		- the container keeps running
			docker stop [container_id] - to stop the container
			docker rm [container_id] - to remove the container
			docker rmi [image_id] - to remove the image
			
			
launchsettings.json:

	{
	  "iisSettings": {
		"windowsAuthentication": false,
		"anonymousAuthentication": true,
		"iisExpress": {
		  "applicationUrl": "http://localhost:54435/",
		  "sslPort": 0
		}
	  },
	  "profiles": {
		"IIS Express": {
		  "commandName": "IISExpress",
		  "launchBrowser": true,
		  "environmentVariables": {
			"ASPNETCORE_ENVIRONMENT": "Development"
		  }
		},
		"WebAppDocker": {
		  "commandName": "Project",
		  "launchBrowser": true,
		  "environmentVariables": {
			"ASPNETCORE_ENVIRONMENT": "Development"
		  },
		  "applicationUrl": "http://localhost:54436"
		}
	  }
	}

	The "WebAppDocker" profile tell VS to run the project (i.e. via dotnet.exe) instead of starting up IIS Express and deploy the app to it.
